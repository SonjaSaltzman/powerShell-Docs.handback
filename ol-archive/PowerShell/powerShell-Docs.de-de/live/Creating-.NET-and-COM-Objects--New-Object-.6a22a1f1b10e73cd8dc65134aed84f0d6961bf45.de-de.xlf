<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c0f405a46e16935211b3886a40c9f7d1afc7260</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Creating-.NET-and-COM-Objects--New-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">347f4a678fd237b2bfb5407124967071cba4a72e</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects  New Object</source>
          <target state="translated">Erstellen von .NET- und COM-Objekten  New-Object</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects (New-Object)</source>
          <target state="translated">Erstellen von .NET- und COM-Objekten (New-Object)</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.</source>
          <target state="translated">Es gibt Softwarekomponenten mit .NET Framework- und COM-Schnittstellen, mit denen Sie viele Systemverwaltungsaufgaben ausführen können.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.</source>
          <target state="translated">Mit Windows PowerShell können Sie diese Komponenten verwenden und sind somit nicht auf die Aufgaben beschränkt, die mithilfe von Cmdlets ausgeführt werden können.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.</source>
          <target state="translated">Viele der Cmdlets in der ursprünglichen Version von Windows PowerShell funktionieren nicht auf Remotecomputern.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> class directly from Windows PowerShell.</source>
          <target state="translated">Wir zeigen, wie diese Einschränkung beim Verwalten von Ereignisprotokollen mithilfe der .NET Framework-Klasse <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> direkt aus Windows PowerShell heraus umgangen werden können.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Using New-Object for Event Log Access</source>
          <target state="translated">Verwenden von „New-Object“ für den Zugriff auf das Ereignisprotokoll</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library includes a class named <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> that can be used to manage event logs.</source>
          <target state="translated">Die .NET Framework-Klassenbibliothek enthält eine Klasse namens <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept>, die zum Verwalten von Ereignisprotokollen verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can create a new instance of a .NET Framework class by using the <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> parameter.</source>
          <target state="translated">Zum Erstellen einer neuen Instanz einer .NET Framework-Klasse können Sie das Cmdlet <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> mit dem Parameter <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> verwenden.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, the following command creates an event log reference:</source>
          <target state="translated">Der folgende Befehl erstellt z. B. einen Ereignisprotokollverweis:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Although the command has created an instance of the EventLog class, the instance does not include any data.</source>
          <target state="translated">Obwohl der Befehl eine Instanz der EventLog-Klasse erstellt hat, enthält die Instanz keine Daten.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>That is because we did not specify a particular event log.</source>
          <target state="translated">Der Grund hierfür ist, dass wir kein bestimmtes Ereignisprotokoll angegeben haben.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How do you get a real event log?</source>
          <target state="translated">Wie erhalten Sie ein echtes Ereignisprotokoll?</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Using Constructors with New-Object</source>
          <target state="translated">Verwenden von Konstruktoren mit „New-Object“</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To refer to a specific event log, you need to specify the name of the log.</source>
          <target state="translated">Um auf ein bestimmtes Ereignisprotokoll zu verweisen, müssen Sie den Namen des Protokolls angeben.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has an <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> parameter.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> verfügt über einen <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept>-Parameter.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The arguments you pass as values to this parameter are used by a special startup method of the object.</source>
          <target state="translated">Die Argumente, die Sie als Werte an diesen Parameter übergeben, werden von einer speziellen Startmethode des Objekts verwendet.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The method is called a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> because it is used to construct the object.</source>
          <target state="translated">Die Methode wird als <bpt id="p1">*</bpt>Konstruktor<ept id="p1">*</ept> bezeichnet, da sie zum Konstruieren des Objekts dient.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, to get a reference to the Application log, you specify the string 'Application' as an argument:</source>
          <target state="translated">Um beispielsweise einen Verweis auf das Anwendungsprotokoll zu erhalten, geben Sie die Zeichenfolge „Application“ als Argument ein:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.</source>
          <target state="translated">Da die meisten .NET Framework Core-Klassen im System-Namespace enthalten sind, versucht Windows PowerShell automatisch, Klassen zu finden, die Sie im System-Namespace angeben, wenn keine Übereinstimmung für den angegebenen Typnamen gefunden wird.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.</source>
          <target state="translated">Dies bedeutet, dass Sie „Diagnostics.EventLog“ anstelle von „System.Diagnostics.EventLog“ angeben können.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Storing Objects in Variables</source>
          <target state="translated">Speichern von Objekten in Variablen</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You might want to store a reference to an object, so you can use it in the current shell.</source>
          <target state="translated">Möglicherweise möchten Sie einen Verweis auf ein Objekt speichern, damit Sie es in der aktuellen Shell verwenden können.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.</source>
          <target state="translated">Obwohl Windows PowerShell Ihnen ermöglicht, viele Aufgaben mit Pipelines zu erledigen und damit die Notwendigkeit von Variablen zu verringern, erleichtert das Speichern von Verweisen auf Objekte in Variablen manchmal die Bearbeitung dieser Objekte.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables that are essentially named objects.</source>
          <target state="translated">Mit Windows PowerShell können Sie Variablen erstellen, die im Prinzip benannte Objekte sind.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The output from any valid Windows PowerShell command can be stored in a variable.</source>
          <target state="translated">Die Ausgabe eines beliebigen gültigen Windows PowerShell-Befehls kann in einer Variablen gespeichert werden.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Variable names always begin with $.</source>
          <target state="translated">Namen von Variablen beginnen immer mit $.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:</source>
          <target state="translated">Wenn Sie den Verweis auf ein Anwendungsprotokoll in einer Variablen namens „$AppLog“ speichern möchten, geben Sie den Namen der Variablen an, gefolgt von einem Gleichheitszeichen und dem Befehl zum Erstellen des Anwendungsprotokollobjekts:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you then type $AppLog, you can see that it contains the Application log:</source>
          <target state="translated">Wenn Sie dann „$AppLog“ eingeben, sehen Sie, dass es das Anwendungsprotokoll enthält:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Accessing a Remote Event Log with New-Object</source>
          <target state="translated">Zugreifen auf ein Remoteereignisprotokoll mit „New-Object“</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The commands used in the preceding section target the local computer; the <bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> cmdlet can do that.</source>
          <target state="translated">Die im vorherigen Abschnitt verwendeten Befehle hatten den lokalen Computer als Ziel. Dazu kann auch das Cmdlet <bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> verwendet werden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.</source>
          <target state="translated">Um auf das Anwendungsprotokoll auf einem Remotecomputer zuzugreifen, müssen Sie sowohl den Namen des Protokolls als auch einen Computernamen (oder eine IP-Adresse) als Argumente bereitstellen.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?</source>
          <target state="translated">Welche Aufgaben können wir nun mit dem Verweis auf ein in der Variablen $RemoteAppLog gespeichertes Ereignisprotokoll ausführen?</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Clearing an Event Log with Object Methods</source>
          <target state="translated">Löschen eines Ereignisprotokolls mit Objektmethoden</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Objects often have methods that can be called to perform tasks.</source>
          <target state="translated">Objekte verfügen oft über Methoden, die aufgerufen werden können, um Aufgaben auszuführen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> to display the methods associated with an object.</source>
          <target state="translated">Sie können <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> verwenden, um die einem Objekt zugeordneten Methoden anzuzeigen.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following command and selected output show some the methods of the EventLog class:</source>
          <target state="translated">Mit dem folgenden Befehl und der ausgewählten Ausgabe werden einige der Methoden der EventLog-Klasse angezeigt:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> method can be used to clear the event log.</source>
          <target state="translated">Die Methode <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> kann zum Löschen des Ereignisprotokolls verwendet werden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.</source>
          <target state="translated">Beim Aufrufen einer Methode müssen dem Methodennamen immer Klammern folgen, auch wenn die Methode keine Argumente erfordert.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This lets Windows PowerShell distinguish between the method and a potential property with the same name.</source>
          <target state="translated">So kann Windows PowerShell zwischen der Methode und einer möglichen Eigenschaft mit gleichem Namen unterscheiden.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Type the following to call the <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> method:</source>
          <target state="translated">Geben Sie Folgendes ein, um die Methode <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> aufzurufen:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Type the following to display the log.</source>
          <target state="translated">Geben Sie Folgendes ein, um das Protokoll anzuzeigen.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You will see that the event log was cleared, and now has 0 entries instead of 262:</source>
          <target state="translated">Sie können erkennen, dass das Ereignisprotokoll gelöscht wurde und jetzt statt 262 Einträgen 0 Einträge enthält:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Creating COM Objects with New-Object</source>
          <target state="translated">Erstellen von COM-Objekten mit „New-Object“</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> to work with Component Object Model (COM) components.</source>
          <target state="translated">Sie können <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> verwenden, um mit Component Object Model-Komponenten (COM) zu arbeiten.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.</source>
          <target state="translated">Die Komponenten reichen von den verschiedenen in Windows Script Host (WSH) enthaltenen Bibliotheken bis hin zu ActiveX-Anwendungen wie Internet Explorer, die auf den meisten Systemen installiert sind.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> verwendet zum Erstellen von COM-Objekten .NET Framework Runtime Callable Wrapper, es gelten somit die gleichen Einschränkungen wie für .NET Framework beim Aufrufen von COM-Objekten.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To create a COM object, you need to specify the <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> parameter with the Programmatic Identifier or <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> of the COM class you want to use.</source>
          <target state="translated">Zum Erstellen eines COM-Objekts müssen Sie den Parameter <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> mit dem programmatischen Bezeichner bzw. der <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> der COM-Klasse angeben, die Sie verwenden möchten.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well-known objects from environments such as WSH can be used within Windows PowerShell.</source>
          <target state="translated">Eine vollständige Erläuterung der Einschränkungen der COM-Verwendung und Informationen zu den auf einem System verfügbaren ProgIDs würden den Rahmen dieses Handbuchs sprengen, aber die meisten bekannten Objekte aus Umgebungen wie WSH können in Windows PowerShell verwendet werden.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can create the WSH objects by specifying these progids: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</source>
          <target state="translated">Sie können die WSH-Objekte erstellen, indem Sie diese ProgIDs angeben: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept> und <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following commands create these objects:</source>
          <target state="translated">Mit den folgenden Befehlen werden diese Objekte erstellt:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.</source>
          <target state="translated">Die meisten Funktionen dieser Klassen werden zwar auch auf andere Weise in Windows PowerShell bereitgestellt, aber einige Aufgaben wie das Erstellen einer Verknüpfung lassen sich mit den WSH-Klassen einfacher erledigen.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Creating a Desktop Shortcut with WScript.Shell</source>
          <target state="translated">Erstellen einer Desktopverknüpfung mit „WScript.Shell“</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>One task that can be performed quickly with a COM object is creating a shortcut.</source>
          <target state="translated">Eine Aufgabe, die mit einem COM-Objekt schnell und einfach ausgeführt werden kann, ist das Erstellen einer Verknüpfung.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.</source>
          <target state="translated">Angenommen, Sie möchten auf dem Desktop eine Verknüpfung zum Basisordner für Windows PowerShell erstellen.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You first need to create a reference to <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, which we will store in a variable named <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</source>
          <target state="translated">Zuerst müssen Sie einen Verweis auf <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept> erstellen, den wir in einer Variablen namens <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept> speichern:</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Get-Member works with COM objects, so you can explore the members of the object by typing:</source>
          <target state="translated">„Get-Member“ funktioniert mit COM-Objekten, sodass Sie die Elemente des Objekts untersuchen können, indem Sie folgendes eingeben:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> has an optional <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> parameter you can use instead of piping to provide input to <bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> verfügt über einen optionalen <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept>-Parameter, den Sie anstelle von Piping als Eingabe für <bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept> verwenden können.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You would get the same output as shown above if you instead used the command <bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept>.</source>
          <target state="translated">Dieselbe Ausgabe wie oben hätten Sie auch über den Befehl <bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept> erhalten.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, it treats its argument as a single item.</source>
          <target state="translated">Wenn Sie <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept> verwenden, wird das Argument als ein einzelnes Element behandelt.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This means that if you have several objects in a variable, <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> treats them as an array of objects.</source>
          <target state="translated">Dies bedeutet, dass bei mehreren Objekte in einer Variablen diese von <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> als ein Array von Objekten behandelt werden.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Beispiel:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> method accepts a single argument, the path to the shortcut file to create.</source>
          <target state="translated">Die Methode <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> akzeptiert ein einziges Argument, und zwar, den Pfad zur zu erstellenden Verknüpfungsdatei.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>We could type in the full path to the desktop, but there is an easier way.</source>
          <target state="translated">Wir könnten den vollständigen Pfad zum Desktop eingeben, aber es gibt einen einfacheren Weg.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The desktop is normally represented by a folder named Desktop inside the home folder of the current user.</source>
          <target state="translated">Der Desktop wird normalerweise durch einen Ordner namens „Desktop“ im Basisordner des aktuellen Benutzers dargestellt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has a variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> that contains the path to this folder.</source>
          <target state="translated">Windows PowerShell verfügt über eine Variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept>, die den Pfad zu diesem Ordner enthält.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:</source>
          <target state="translated">Sie können den Pfad zum Basisordner mithilfe dieser Variablen angeben und dann den Namen des Ordners „Desktop“ sowie den Namen für die zu erstellende Verknüpfung hinzufügen. Geben Sie dazu Folgendes ein:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When you use something that looks like a variable name inside double-quotes, Windows PowerShell tries to substitute a matching value.</source>
          <target state="translated">Wenn Sie ein Element, das wie ein Variablenname aussieht, in doppelten Anführungszeichen angeben, versucht Windows PowerShell, dieses Element durch einen entsprechenden Wert zu ersetzen.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you use single-quotes, Windows PowerShell does not try to substitute the variable value.</source>
          <target state="translated">Wenn Sie einzelne Anführungszeichen verwenden, versucht Windows PowerShell nicht, den Variablenwert zu ersetzen.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, try typing the following commands:</source>
          <target state="translated">Geben Sie beispielsweise die folgenden Befehle ein:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>We now have a variable named <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> that contains a new shortcut reference.</source>
          <target state="translated">Wir verfügen jetzt über eine Variable namens <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept>, die einen neuen Verknüpfungsverweis enthält.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you want to see its members, you can pipe it to <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept>.</source>
          <target state="translated">Wenn Sie die zugehörigen Elemente anzeigen möchten, können Sie sie über die Pipeline an <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> übergeben.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The output below shows the members we need to use to finish creating our shortcut:</source>
          <target state="translated">In der folgenden Ausgabe werden die zum Abschließen der Erstellung unserer Verknüpfung zu verwendenden Elemente angezeigt:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</source>
          <target state="translated">PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>We need to specify the <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> by calling the <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> method.</source>
          <target state="translated">Sie müssen den <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept> angeben, d.h. den Anwendungsordner für Windows PowerShell, und dann die Verknüpfung <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> durch Aufrufen der Methode <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> speichern.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell application folder path is stored in the variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, so we can do this by typing:</source>
          <target state="translated">Der Pfad des Windows PowerShell-Anwendungsordners ist in der Variablen <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept> gespeichert, also geben Sie Folgendes ein:</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>$lnk.TargetPath = $PSHome $lnk.Save()</source>
          <target state="translated">$lnk.TargetPath = $PSHome $lnk.Save()</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Using Internet Explorer from Windows PowerShell</source>
          <target state="translated">Verwenden von Internet Explorer in Windows PowerShell</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.</source>
          <target state="translated">Viele Anwendungen (einschließlich der Microsoft Office-Anwendungen und Internet Explorer) können mithilfe von COM automatisiert werden.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Internet Explorer illustrates some of the typical techniques and issues involved in working with COM-based applications.</source>
          <target state="translated">Internet Explorer verdeutlicht einige der typischen Techniken und Probleme im Zusammenhang mit COM-basierten Anwendungen.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</source>
          <target state="translated">Sie erstellen eine Internet Explorer-Instanz, indem Sie die ProgID von Internet Explorer angeben, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This command starts Internet Explorer, but does not make it visible.</source>
          <target state="translated">Dieser Befehl startet Internet Explorer, zeigt die Anwendung macht aber nicht an.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If you type Get-Process, you can see that a process named iexplore is running.</source>
          <target state="translated">Wenn Sie „Get-Process“ eingeben, können Sie sehen, dass ein Prozess mit dem Namen „iexplore“ ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In fact, if you exit Windows PowerShell, the process will continue to run.</source>
          <target state="translated">Auch wenn Sie Windows PowerShell beenden, wird der Prozess weiterhin ausgeführt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You must reboot the computer or use a tool like Task Manager to end the iexplore process.</source>
          <target state="translated">Sie müssen den Computer neu starten oder ein Tool wie Task-Manager verwenden, um den Prozess „iexplore“ zu beenden.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>COM objects that start as separate processes, commonly called <bpt id="p1">*</bpt>ActiveX executables<ept id="p1">*</ept>, may or may not display a user interface window when they start up.</source>
          <target state="translated">Für COM-Objekte, die als separate Prozesse gestartet werden, so genannte <bpt id="p1">*</bpt>ActiveX-EXE-Dateien<ept id="p1">*</ept>, kann beim Start ein Benutzeroberflächenfenster angezeigt werden, muss aber nicht.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.</source>
          <target state="translated">Wenn ein Objekt ein Fenster erstellt, dieses aber nicht anzeigt, wie Internet Explorer, geht der Fokus in der Regel an den Windows-Desktop, und Sie müssen das Fenster einblenden, um mit ihm zu interagieren.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>By typing <bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept>, you can view properties and methods for Internet Explorer.</source>
          <target state="translated">Durch Eingabe von <bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept> können Sie Eigenschaften und Methoden für Internet Explorer anzeigen.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>To see the Internet Explorer window, set the Visible property to $true by typing:</source>
          <target state="translated">Um das Internet Explorer-Fenster anzuzeigen, legen Sie die Eigenschaft „Visible“ auf „$true“ fest. Geben Sie dazu Folgendes ein:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can then navigate to a specific Web address by using the Navigate method:</source>
          <target state="translated">Anschließend können Sie mithilfe der Methode „Navigate“ zu einer bestimmten Webadresse navigieren:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.</source>
          <target state="translated">Unter Verwendung anderer Elemente des Internet Explorer-Objektmodells können Sie Text-Inhalt von der Website abrufen.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The following command will display the HTML text in the body of the current Web page:</source>
          <target state="translated">Mit dem folgenden Befehl können Sie den HTML-Text im Hauptteil der aktuellen Webseite anzeigen:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To close Internet Explorer from within PowerShell, call its Quit() method:</source>
          <target state="translated">Rufen Sie die Methode „Quit()“ auf, um Internet Explorer aus PowerShell heraus zu schließen:</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This will force it to close.</source>
          <target state="translated">Dadurch wird das Schließen von Internet Explorer erzwungen.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The $ie variable no longer contains a valid reference even though it still appears to be a COM object.</source>
          <target state="translated">Die Variable „$ie“ enthält keinen gültigen Verweis mehr, obwohl es sich noch um ein COM-Objekt zu handeln scheint.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>If you attempt to use it, you will get an automation error:</source>
          <target state="translated">Wenn Sie die Variable verwenden, erhalten Sie einen Automatisierungsfehler:</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You can either remove the remaining reference with a command like $ie = $null, or completely remove the variable by typing:</source>
          <target state="translated">Sie können entweder den verbleibenden Verweis mit einem Befehl wie „$ie = $null“ oder die Variable durch folgende Eingabe entfernen:</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.</source>
          <target state="translated">Es gibt keinen allgemeinen Standard, der festlegt, ob ActiveX-EXE-Dateien beendet oder weiterhin ausgeführt werden, wenn Sie einen Verweis darauf entfernen.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.</source>
          <target state="translated">Je nach Situation, also z. B. abhängig davon, ob die Anwendung angezeigt, ein bearbeitetes Dokument darin ausgeführt oder Windows PowerShell noch ausgeführt wird, wird die Anwendung beendet oder auch nicht.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.</source>
          <target state="translated">Aus diesem Grund sollten Sie das Abbruchverhalten für jede ActiveX-EXE-Datei testen, die Sie in Windows PowerShell verwenden möchten.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Getting Warnings About .NET Framework-Wrapped COM Objects</source>
          <target state="translated">Abrufen von Warnungen zu von .NET Framework umschlossenen COM-Objekten</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In some cases, a COM object might have an associated .NET Framework <bpt id="p1">*</bpt>Runtime-Callable Wrapper<ept id="p1">*</ept> or RCW, and this will be used by <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept>.</source>
          <target state="translated">In einigen Fällen verfügt ein COM-Objekt möglicherweise über einen zugeordneten .NET Framework <bpt id="p1">*</bpt>Runtime-Callable Wrapper<ept id="p1">*</ept> oder RCW, und dieser wird von <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept> verwendet.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has a <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> parameter to warn you about RCW access.</source>
          <target state="translated">Da das Verhalten des RCW möglicherweise vom Verhalten des normalen COM-Objekts abweicht, verfügt <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> über einen <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept>-Parameter, der Sie auf den RCW-Zugriff hinweist.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:</source>
          <target state="translated">Wenn Sie den Parameter <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> angeben und dann ein COM-Objekt erstellen, das einen RCW verwendet, wird eine Warnung angezeigt:</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Although the object is still created, you are warned that it is not a standard COM object.</source>
          <target state="translated">Das Objekt wird zwar erstellt, Sie werden jedoch darauf hingewiesen, dass es sich nicht um ein Standard-COM-Objekt handelt.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>