<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fc0a1ae3bba1fed7ba846dd601774ee8268276</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Break.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">96ef8ce26be1424de16362503a74c06e22eefffe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0dba048828eed5dd6a6486a27d382a58d84af6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell-Cmdlets</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Break</source>
          <target state="translated">Zum Unterbrechen</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>TOPIC</source>
          <target state="translated">THEMA</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">KURZE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Describes a statement you can use to immediately exit Foreach, For, While, Do, or Switch statements.</source>
          <target state="translated">Beschreibt eine-Anweisung Sie zum sofortigen Beenden von Foreach, für können While, führen oder Switch-Anweisungen.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">LANGE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When a Break statement appears in a loop, such as a Foreach, For, Switch, or While loop, the Break statement causes Windows PowerShell to immediately exit the loop.</source>
          <target state="translated">Wenn eine Break-Anweisung wird in einer Schleife, z. B. ein Foreach, Switch, oder während der Schleife, die Break-Anweisung bewirkt, dass Windows PowerShell sofort Beenden der Schleife.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In a Switch construct that does not loop, Break causes Windows PowerShell to exit the Switch code block.</source>
          <target state="translated">In einem Switch-Konstrukt, das keine Schleife ist, Break wird Windows PowerShell, um die Switch-Code-Block zu beenden.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label that lets you exit embedded loops.</source>
          <target state="translated">Eine Break-Anweisung kann eine Bezeichnung einfügen, die eingebettete Schleifen beenden können.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A label can specify any loop keyword, such as Foreach, For, or While, in a script.</source>
          <target state="translated">Eine Bezeichnung kann alle Loop-Schlüsselwort, wie z. B. Foreach, for- oder While-, in einem Skript angeben.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you use a label, Break exits the specified loop.</source>
          <target state="translated">Wenn Sie eine Bezeichnung verwenden, wird die break-Anweisung angegebene Schleife.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Break exits the specified loop, regardless of which loop the Break statement is in.</source>
          <target state="translated">Break wird unabhängig von der Schleife die Break-Anweisung, in ist die angegebene Schleife beendet.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example shows how to use a Break statement to exit a For statement:</source>
          <target state="translated">Das folgende Beispiel zeigt, wie eine Break-Anweisung verwendet, um eine For-Anweisung zu beenden:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>for($i=1; $i -le 10; $i++) { Write-Host $i break }</source>
          <target state="translated">für ($i = 1; $i-le 10; $i++) {Write-Host $i Break}</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the Break statement exits the For loop when the $i variable equals 1.</source>
          <target state="translated">In diesem Beispiel wird die Break-Anweisung die For-Schleife beendet, wenn die Variable $i gleich 1 ist.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the For statement evaluates to True until $i is greater than 10, Windows PowerShell reaches the break statement the first time the For loop is run.</source>
          <target state="translated">Obwohl die For-Anweisung True ergibt bis $i größer als 10 ist, erreicht Windows PowerShell die Break-Anweisung die erste Mal, das die For-Schleife ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is more common to use the Break statement in a loop where an inner condition must be met.</source>
          <target state="translated">Es ist üblicher, verwenden die Break-Anweisung in einer Schleife, in dem eine interne Bedingung erfüllt sein muss.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Consider the following Foreach statement example:</source>
          <target state="translated">Betrachten Sie das folgende Beispiel der Foreach-Anweisung aus:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$i=0 $varB = 10,20,30,40 foreach ($val in $varB) { $i++ if ($val -eq 30) { break } } Write-Host "30 was found in array position $i"</source>
          <target state="translated">$i = 0 $varB = 10.20.30.40 Foreach ($val in $varB) {$i++ Wenn (30 $val - Eq) {Break}} Write-Host "30 wurde in Arrayposition $i gefunden"</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach statement iterates the $varB array.</source>
          <target state="translated">In diesem Beispiel durchläuft die Foreach-Anweisung das $varB-Array.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each time the code block is run, the $i variable is incremented by 1.</source>
          <target state="translated">Jedes Mal, wenn der Codeblock ausgeführt wird, wird die Variable $i um 1 erhöht.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The If statement evaluates to False the first two times the loop is run.</source>
          <target state="translated">Die Wenn-Anweisung die erste auf "false" ergibt die Schleife zwei Mal ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The third time the loop is run, $i equals 3, and the $val variable equals 30.</source>
          <target state="translated">Das dritte Mal, das die Schleife ausgeführt wird, das $i gleich 3 ist, und die Variable $val entspricht 30.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the Break statement runs, and the Foreach loop exits.</source>
          <target state="translated">Die Break-Anweisung ausgeführt wird und die Foreach-Schleife an diesem Punkt beendet.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You break out of the other looping statements in the same way you break out of the Foreach loop.</source>
          <target state="translated">Sie unterbrechen die Schleifen anderen Anweisungen auf die gleiche Weise, die Sie aus der Foreach-Schleife zu unterbrechen.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following example, the Break statement exits a While statement when a DivideByZeroException exception is trapped using the Trap statement.</source>
          <target state="translated">Im folgenden Beispiel die Break-Anweisung beendet eine While-Anweisung, wenn eine DivideByZeroException-Ausnahme abgefangen wird mithilfe der Trap-Anweisung.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>$i = 3 while ($true) { trap [DivideByZeroException] { Write-Host "divide by zero trapped" break } 1 / $i-- }</source>
          <target state="translated">$i = 3 beim ($true) {trap [DivideByZeroException] {Write-Host "Division durch 0 (null) aufgefangen" Break} 1 / $i--}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label.</source>
          <target state="translated">Eine Break-Anweisung kann eine Bezeichnung einfügen.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you use the Break keyword with a label, Windows PowerShell exits the labeled loop instead of exiting the current loop.</source>
          <target state="translated">Wenn Sie das Schlüsselwort "Break" mit einer Bezeichnung verwenden, schließt Windows PowerShell die bezeichnete Schleife anstatt der aktuellen Schleife zu beenden.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The syntax for a label is as follows (this example shows a label in a While loop):</source>
          <target state="translated">Die Syntax für die Bezeichnung lautet wie folgt (in diesem Beispiel wird eine Beschriftung in einer While-Schleife):</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>:myLabel while (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">: beim MyLabel (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The label is a colon followed by a name that you assign.</source>
          <target state="translated">Die Bezeichnung ist ein Doppelpunkt, gefolgt von einem Namen, den Sie zuweisen.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The label must be the first token in a statement, and it must be followed by the looping keyword, such as While.</source>
          <target state="translated">Die Bezeichnung muss das erste Token in einer Anweisung sein und es muss darauf folgen die Schleife Schlüsselwort wie z. B. während.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, only loop keywords, such as Foreach, For, and While can have a label.</source>
          <target state="translated">In Windows PowerShell können nur Schleife Schlüsselwörtern wie Foreach, für, und wenn Sie eine Bezeichnung aufweisen.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Break moves execution out of the labeled loop.</source>
          <target state="translated">Unterbrechen Sie verschiebt Ausführung bezeichnete Schleife.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In embedded loops, this has a different result than the Break keyword has when it is used by itself.</source>
          <target state="translated">Eingebettete Schleifen hat dies ein anderes Ergebnis als die Break-Schlüsselwort enthält, wenn er allein verwendet wird.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This schematic example has a While statement with a For statement:</source>
          <target state="translated">Dieses Schema Beispiel umfasst eine While-Anweisung mit einer For-Anweisung:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>:myLabel while (&lt;condition 1&gt;) { for ($item in $items) { if (&lt;condition 2&gt;) { break myLabel } $item = $x   # A statement inside the For-loop } } $a = $c  # A statement after the labeled While-loop</source>
          <target state="translated">: MyLabel beim (&lt; Bedingung 1 &gt;) {für ($item in $items) {Wenn (&lt; Bedingung 2 &gt;) {unterbrechen MyLabel} $item = $x # eine Anweisung innerhalb der For-Schleife}} $einer = $c # eine Anweisung nach der bezeichneten While-Schleife</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If condition 2 evaluates to True, the execution of the script skips down to the statement after the labeled loop.</source>
          <target state="translated">Wenn Bedingung 2 zu True ausgewertet wird, springt die Ausführung des Skripts an die Anweisung nach der Schleife mit Bezeichnung.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the example, execution starts again with the statement "$a = $c".</source>
          <target state="translated">Im Beispiel Ausführung beginnt wieder mit der Anweisung "$ein $c =".</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can nest many labeled loops, as shown in the following schematic example.</source>
          <target state="translated">Viele bezeichnete Schleifen können geschachtelt werden, wie im folgenden Beispiel schematische Darstellung gezeigt.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>:red while (<ph id="ph1">&lt;condition1&gt;</ph>) { :yellow while (<ph id="ph2">&lt;condition2&gt;</ph>) { while (<ph id="ph3">&lt;condition3&gt;</ph>) { if ($a) {break} if ($b) {break red} if ($c) {break yellow} } After innermost loop } After "yellow" loop } After "red" loop</source>
          <target state="translated">: beim Rot (<ph id="ph1">&lt;condition1&gt;</ph>) {: Gelb beim (<ph id="ph2">&lt;condition2&gt;</ph>) {während (<ph id="ph3">&lt;condition3&gt;</ph>) {Wenn ($eine) {Break} Wenn ($b) {Break Rot} Wenn ($c) {Break Gelb}} nach innersten Schleife} nach "Gelb" Schleife} nach "Rot" Schleife</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If the $b variable evaluates to True, execution of the script resumes after the loop that is labeled "red".</source>
          <target state="translated">Wenn die Variable $b True ergibt, wird die Ausführung des Skripts nach der Schleife mit der Bezeichnung "Rot".</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the $c variable evaluates to True, execution of the script control resumes after the loop that is labeled "yellow".</source>
          <target state="translated">Wenn die Variable $c True ergibt, wird die Ausführung des Steuerelements Skript nach der Schleife mit der Bezeichnung "Gelb gekennzeichnet".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the $a variable evaluates to True, execution resumes after the innermost loop.</source>
          <target state="translated">Wenn der $eine Variable auf "true" ergibt, wird die Ausführung nach der innersten Schleife.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No label is needed.</source>
          <target state="translated">Keine Bezeichnung ist erforderlich.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows PowerShell does not limit how far labels can resume execution.</source>
          <target state="translated">Windows PowerShell ist nicht beschränkt, wie weit Bezeichnungen Ausführung fortgesetzt werden können.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The label can even pass control across script and function call boundaries.</source>
          <target state="translated">Die Bezeichnung kann sogar Steuerelement über Skript und die Funktion Grenzen Aufruf übergeben.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Break keyword is used to leave the Switch construct.</source>
          <target state="translated">Das Schlüsselwort "Break" ist, lassen Sie das Switch-Konstrukt verwendet.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, the following Switch statement uses Break statements to test for the most specific condition:</source>
          <target state="translated">Beispielsweise verwendet die folgenden Switch-Anweisung Break-Anweisungen für die spezifischen Bedingung testen:</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>$var = "word2" switch -regex ($var) { "word2" { Write-Host "Exact" $_ break }</source>
          <target state="translated">$var = "word2" Switch - Regex ($var) {"word2" {Write-Host "Exact" $_ Break}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>"word.*" { Write-Host "Match on the prefix" $_ break }</source>
          <target state="translated">"word.*" {Write-Host "Übereinstimmung mit dem Präfix" $_ Break}</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"w.*" { Write-Host "Match on at least the first letter" $_ break }</source>
          <target state="translated">"w.*" {Write-Host "Auf mindestens die ersten Buchstaben Match" $_ Break}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>default { Write-Host "No match" $_ break } }</source>
          <target state="translated">Default-{Write-Host "Keine Übereinstimmung" $_ Break}}</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, the $var variable is created and initialized to a string value of "word2".</source>
          <target state="translated">In diesem Beispiel wird die Variable $var erstellt und in einen Zeichenfolgenwert von "word2" initialisiert.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The Switch statement uses the Regex class to match the variable value first with the term "word2".</source>
          <target state="translated">Die Switch-Anweisung verwendet die Regex-Klasse, um den Wert der Variablen mit dem Begriff "word2" erste Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>(The Regex class is a regular expression Microsoft .NET Framework class.) Because the variable value and the first test in the Switch statement match, the first code block in the Switch statement runs.</source>
          <target state="translated">(Die Regex-Klasse ist ein regulärer Ausdruck Microsoft .NET Framework-Klasse.) Da der Wert der Variablen und den ersten Test in der Switch-Anweisung übereinstimmen, der erste Codeblock in wird die Switch-Anweisung ausgeführt.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When Windows PowerShell reaches the first Break statement, the Switch statement exits.</source>
          <target state="translated">Wenn Windows PowerShell die erste Break-Anweisung erreicht, wird die Switch-Anweisung beendet.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the four Break statements are removed from the example, all four conditions are met.</source>
          <target state="translated">Wenn die vier Break-Anweisungen aus dem Beispiel entfernt werden, werden alle vier Bedingungen erfüllt.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example uses the break statement to display results when the most specific condition is met.</source>
          <target state="translated">Dieses Beispiel verwendet die Break-Anweisung, um Ergebnisse anzuzeigen, wenn die spezifischste Bedingung erfüllt ist.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">SIEHE AUCH</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</source>
          <target state="translated">About_Comparison_Operators "about_continue" About_For About_Foreach About_Switch About_Throw About_Trap About_Try_Catch_Finally about_While</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>