<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-db30baf" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e986e85a5d7416d8deaec06c0784263ee09fc9ff</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Creating-.NET-and-COM-Objects--New-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects  New Object</source>
          <target state="translated">Crear objetos .NET y COM (New-Object)</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects (New-Object)</source>
          <target state="translated">Crear objetos .NET y COM (New-Object)</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.</source>
          <target state="translated">Existen componentes de software con interfaces de .NET Framework y COM que permiten realizar muchas tareas de administración del sistema.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.</source>
          <target state="translated">Windows PowerShell le permite usar estos componentes, por lo que no está limitado a las tareas que pueden realizarse mediante cmdlets.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.</source>
          <target state="translated">Muchos de los cmdlets de la versión inicial de Windows PowerShell no funcionan en equipos remotos.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> class directly from Windows PowerShell.</source>
          <target state="translated">Demostraremos cómo superar esta limitación al administrar registros de eventos mediante el uso de la clase <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> de .NET Framework directamente desde Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Using New<ph id="ph1">\-</ph>Object for Event Log Access</source>
          <target state="translated">Uso de New<ph id="ph1">\-</ph>Object para el acceso del registro de eventos</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library includes a class named <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> that can be used to manage event logs.</source>
          <target state="translated">La biblioteca de clases de .NET Framework incluye una clase denominada <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> que se puede usar para administrar registros de eventos.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can create a new instance of a .NET Framework class by using the <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> parameter.</source>
          <target state="translated">Puede crear una nueva instancia de una clase .NET Framework mediante el cmdlet <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> con el parámetro <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, the following command creates an event log reference:</source>
          <target state="translated">Por ejemplo, el comando siguiente crea una referencia de registro de eventos:</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although the command has created an instance of the EventLog class, the instance does not include any data.</source>
          <target state="translated">Aunque el comando creó una instancia de la clase EventLog, la instancia no incluye ningún dato.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>That is because we did not specify a particular event log.</source>
          <target state="translated">Eso es porque no especificamos un registro de eventos concreto.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>How do you get a real event log?</source>
          <target state="translated">¿Cómo se consigue un registro de eventos real?</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Using Constructors with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Uso de constructores con New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To refer to a specific event log, you need to specify the name of the log.</source>
          <target state="translated">Para hacer referencia a un registro de eventos específico, debe especificar el nombre del registro.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> has an <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> parameter.</source>
          <target state="translated"><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> tiene un parámetro <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The arguments you pass as values to this parameter are used by a special startup method of the object.</source>
          <target state="translated">Los argumentos que se pasan como valores a este parámetro se usan en un método de inicio especial del objeto.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The method is called a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> because it is used to construct the object.</source>
          <target state="translated">El método se llama <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> porque se usa para construir el objeto.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to get a reference to the Application log, you specify the string 'Application' as an argument:</source>
          <target state="translated">Por ejemplo, para obtener una referencia al registro de aplicaciones, especifique la cadena "Application" como argumento:</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.</source>
          <target state="translated">Puesto que la mayoría de las clases principales de .NET Framework se incluyen en el espacio de nombres del sistema, Windows PowerShell intentará buscar clases que especifique en el espacio de nombres del sistema si no encuentra a una coincidencia para el nombre de tipo especificado.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.</source>
          <target state="translated">Esto significa que puede especificar Diagnostics.EventLog en lugar de System.Diagnostics.EventLog.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Storing Objects in Variables</source>
          <target state="translated">Almacenar objetos en Variables</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You might want to store a reference to an object, so you can use it in the current shell.</source>
          <target state="translated">Es posible que desee almacenar una referencia a un objeto, para poder usarla en el shell actual.</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.</source>
          <target state="translated">Aunque Windows PowerShell permite realizar muchas tareas con las canalizaciones, lo que reduce la necesidad de variables, almacenar referencias a objetos en variables puede facilitar la manipulación de esos objetos en determinadas ocasiones.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables that are essentially named objects.</source>
          <target state="translated">Windows PowerShell le permite crear variables que básicamente se denominan objetos.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The output from any valid Windows PowerShell command can be stored in a variable.</source>
          <target state="translated">La salida de cualquier comando válido de Windows PowerShell puede almacenarse en una variable.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Variable names always begin with $.</source>
          <target state="translated">Los nombres de variable siempre comienzan por $.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:</source>
          <target state="translated">Si desea almacenar la referencia del registro de aplicaciones en una variable denominada $AppLog, escriba el nombre de la variable, seguido de un signo igual y, a continuación, escriba el comando usado para crear el objeto de registro de aplicaciones:</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you then type $AppLog, you can see that it contains the Application log:</source>
          <target state="translated">Si luego escribe $AppLog, puede ver que contiene el registro de aplicaciones:</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Accessing a Remote Event Log with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Acceso al registro de eventos remoto con New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The commands used in the preceding section target the local computer; the <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>EventLog<ept id="p1">**</ept> cmdlet can do that.</source>
          <target state="translated">Los comandos usados en la sección anterior van dirigidos al equipo local; el cmdlet <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>EventLog<ept id="p1">**</ept> puede hacerlo.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.</source>
          <target state="translated">Para acceder al registro de aplicaciones en un equipo remoto, debe proporcionar el nombre del registro y un nombre de equipo (o dirección IP) como argumentos.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?</source>
          <target state="translated">Ahora que tenemos una referencia a un registro de eventos almacenado en la variable $RemoteAppLog, ¿qué tareas podemos realizar en él?</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Clearing an Event Log with Object Methods</source>
          <target state="translated">Borrar un registro de eventos con los métodos de objeto</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Objects often have methods that can be called to perform tasks.</source>
          <target state="translated">Los objetos suelen tener métodos que se puedan llamar para realizar tareas.</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> to display the methods associated with an object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> se puede usar para mostrar los métodos asociados a un objeto.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following command and selected output show some the methods of the EventLog class:</source>
          <target state="translated">El siguiente comando y la salida seleccionada muestran algunos de los métodos de la clase EventLog:</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> method can be used to clear the event log.</source>
          <target state="translated">El método <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> se puede usar para borrar el registro de eventos.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.</source>
          <target state="translated">Al llamar a un método, siempre debe seguir el nombre del método con paréntesis, aunque este no requiera argumentos.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This lets Windows PowerShell distinguish between the method and a potential property with the same name.</source>
          <target state="translated">Esto permite que Windows PowerShell distinga entre el método y una propiedad potencial con el mismo nombre.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Type the following to call the <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> method:</source>
          <target state="translated">Escriba lo siguiente para llamar al método <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Type the following to display the log.</source>
          <target state="translated">Escriba lo siguiente para mostrar el registro.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You will see that the event log was cleared, and now has 0 entries instead of 262:</source>
          <target state="translated">Verá que se ha borrado el registro de eventos y ahora tiene 0 entradas en lugar de 262:</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Creating COM Objects with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Creación de objetos COM con New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> to work with Component Object Model (COM) components.</source>
          <target state="translated">Puede usar <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> para trabajar con componentes del Modelo de objetos componentes (COM).</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.</source>
          <target state="translated">Los componentes van desde las distintas bibliotecas incluidas con Windows Script Host (WSH) hasta las aplicaciones de ActiveX, como Internet Explorer, que están instaladas en la mayoría de los sistemas.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> uses .NET Framework Runtime<ph id="ph2">\-</ph>Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> usa contenedores R<ph id="ph2">\-</ph>CW de .NET Framework para crear objetos COM, por lo que tiene las mismas limitaciones que .NET Framework al llamar a objetos COM.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To create a COM object, you need to specify the <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> parameter with the Programmatic Identifier or <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> of the COM class you want to use.</source>
          <target state="translated">Para crear un objeto COM, debe especificar el parámetro <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> con el identificador de programación o <bpt id="p2">*</bpt>ProgID<ept id="p2">*</ept> de la clase COM que quiere usar.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well<ph id="ph1">\-</ph>known objects from environments such as WSH can be used within Windows PowerShell.</source>
          <target state="translated">Una explicación completa de las limitaciones del uso de COM y la indicación de qué ProgID están disponibles en un sistema está fuera del ámbito de este manual, pero la mayoría de los objetos conocidos de entornos como WSH pueden usarse en Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can create the WSH objects by specifying these progids: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</source>
          <target state="translated">Puede crear los objetos WSH especificando estos ProgID: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept> y <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following commands create these objects:</source>
          <target state="translated">Los siguientes comandos crean estos objetos:</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.</source>
          <target state="translated">Aunque la mayor parte de la funcionalidad de estas clases está disponible de otras maneras en Windows PowerShell, algunas tareas como la creación de accesos directos son aún más fáciles con las clases de WSH.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Creating a Desktop Shortcut with WScript.Shell</source>
          <target state="translated">Crear un acceso directo de escritorio con WScript.Shell</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>One task that can be performed quickly with a COM object is creating a shortcut.</source>
          <target state="translated">Una tarea que se puede realizar rápidamente con un objeto COM es crear un acceso directo.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.</source>
          <target state="translated">Supongamos que desea crear un acceso directo en el escritorio que se vincule a la carpeta principal de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You first need to create a reference to <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, which we will store in a variable named <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</source>
          <target state="translated">Primero debe crear una referencia a <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, que se almacenará en una variable denominada <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Get<ph id="ph1">\-</ph>Member works with COM objects, so you can explore the members of the object by typing:</source>
          <target state="translated">Get<ph id="ph1">\-</ph>Member funciona con objetos COM, por lo que es posible escribir lo siguiente para explorar los miembros del objeto:</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> has an optional <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> parameter you can use instead of piping to provide input to <bpt id="p3">**</bpt>Get<ph id="ph2">\-</ph>Member<ept id="p3">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> tiene un parámetro <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> opcional que puede usar, en lugar de las canalizaciones, para proporcionar datos de entrada a <bpt id="p3">**</bpt>Get<ph id="ph2">\-</ph>Member<ept id="p3">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You would get the same output as shown above if you instead used the command <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member <ph id="ph2">\-</ph>InputObject $WshShell<ept id="p1">**</ept>.</source>
          <target state="translated">Obtendría la misma salida que se ha mostrado si usara el comando <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member <ph id="ph2">\-</ph>InputObject $WshShell<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, it treats its argument as a single item.</source>
          <target state="translated">Si usa <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, trata su argumento como un solo elemento.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that if you have several objects in a variable, <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> treats them as an array of objects.</source>
          <target state="translated">Esto significa que si hay varios objetos en una variable, <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> los trata como una matriz de objetos.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> method accepts a single argument, the path to the shortcut file to create.</source>
          <target state="translated">El método <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> acepta un solo argumento, la ruta de acceso al archivo de acceso directo que se va a crear.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>We could type in the full path to the desktop, but there is an easier way.</source>
          <target state="translated">Podríamos escribir la ruta de acceso completa al escritorio, pero hay una manera más fácil.</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The desktop is normally represented by a folder named Desktop inside the home folder of the current user.</source>
          <target state="translated">El escritorio suele representarse con una carpeta denominada Desktop dentro de la carpeta principal del usuario actual.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has a variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> that contains the path to this folder.</source>
          <target state="translated">Windows PowerShell tiene una variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> que contiene la ruta de acceso a esta carpeta.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:</source>
          <target state="translated">Podemos especificar la ruta de acceso a la carpeta principal mediante esta variable y, después, agregar el nombre de la carpeta Desktop y el nombre del acceso directo que crearemos escribiéndolo:</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When you use something that looks like a variable name inside double<ph id="ph1">\-</ph>quotes, Windows PowerShell tries to substitute a matching value.</source>
          <target state="translated">Si se usa algo parecido a un nombre de variable entre comillas dobles, Windows PowerShell intenta realizar la sustitución por un valor coincidente.</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If you use single<ph id="ph1">\-</ph>quotes, Windows PowerShell does not try to substitute the variable value.</source>
          <target state="translated">Si se usan comillas simples, Windows PowerShell no intenta sustituir el valor de la variable.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, try typing the following commands:</source>
          <target state="translated">Por ejemplo, intente escribir los siguientes comandos:</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>We now have a variable named <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> that contains a new shortcut reference.</source>
          <target state="translated">Ahora tenemos una variable denominada <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> que contiene una nueva referencia de acceso directo.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you want to see its members, you can pipe it to <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>.</source>
          <target state="translated">Si quiere ver sus miembros, puede canalizarla a <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The output below shows the members we need to use to finish creating our shortcut:</source>
          <target state="translated">La salida siguiente muestra los miembros que debemos usar para terminar de crear el acceso directo:</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</source>
          <target state="translated">PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</target>         
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>We need to specify the <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> by calling the <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> method.</source>
          <target state="translated">Es preciso especificar <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, que es la carpeta de aplicación de Windows PowerShell y, luego, guardar el acceso directo <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> llamando al método <bpt id="p3">**</bpt>Save<ept id="p3">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell application folder path is stored in the variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, so we can do this by typing:</source>
          <target state="translated">La ruta de acceso de la carpeta de la aplicación de Windows PowerShell se almacena en la variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, por lo que podemos escribir lo siguiente para hacerlo:</target>         
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>$lnk.TargetPath = $PSHome $lnk.Save()</source>
          <target state="translated">$lnk.TargetPath = $PSHome $lnk.Save()</target>         
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Using Internet Explorer from Windows PowerShell</source>
          <target state="translated">Usar Internet Explorer desde Windows PowerShell</target>         
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.</source>
          <target state="translated">Muchas aplicaciones (incluida la familia de aplicaciones de Microsoft Office e Internet Explorer) pueden automatizarse mediante COM.</target>         
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Internet Explorer illustrates some of the typical techniques and issues involved in working with COM<ph id="ph1">\-</ph>based applications.</source>
          <target state="translated">Internet Explorer muestra algunas de las técnicas y problemas típicos que implica trabajar con aplicaciones basadas en COM.</target>         
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</source>
          <target state="translated">Una instancia de Internet Explorer se crea especificando el ProgID de Internet Explorer, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This command starts Internet Explorer, but does not make it visible.</source>
          <target state="translated">Este comando inicia Internet Explorer, pero no hace que sea visible.</target>         
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If you type Get<ph id="ph1">\-</ph>Process, you can see that a process named iexplore is running.</source>
          <target state="translated">Si escribe Get<ph id="ph1">\-</ph>Process, puede ver que se está ejecutando un proceso denominado iexplore.</target>         
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In fact, if you exit Windows PowerShell, the process will continue to run.</source>
          <target state="translated">De hecho, si sale de Windows PowerShell, el proceso se seguirá ejecutando.</target>         
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You must reboot the computer or use a tool like Task Manager to end the iexplore process.</source>
          <target state="translated">Debe reiniciar el equipo o usar una herramienta como el Administrador de tareas para finalizar el proceso de iexplore.</target>         
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>COM objects that start as separate processes, commonly called <bpt id="p1">*</bpt>ActiveX executables<ept id="p1">*</ept>, may or may not display a user interface window when they start up.</source>
          <target state="translated">Los objetos COM que se inician como procesos independientes, denominados normalmente <bpt id="p1">*</bpt>ejecutables de ActiveX<ept id="p1">*</ept>, pueden mostrar o no una ventana de interfaz de usuario al iniciarse.</target>         
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.</source>
          <target state="translated">Si crean una ventana, pero no la hacen visible, como Internet Explorer, el enfoque se moverá generalmente al escritorio de Windows y debe hacer que la ventana sea visible para interactuar con ella.</target>         
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>By typing <bpt id="p1">**</bpt>$ie | Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>, you can view properties and methods for Internet Explorer.</source>
          <target state="translated">Si escribe <bpt id="p1">**</bpt>$ie | Get-Member<ph id="ph1">\-</ph>, podrá ver las propiedades y los métodos de Internet Explorer.</target>         
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>To see the Internet Explorer window, set the Visible property to $true by typing:</source>
          <target state="translated">Para ver la ventana de Internet Explorer, establezca la propiedad Visible en $true escribiendo:</target>         
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can then navigate to a specific Web address by using the Navigate method:</source>
          <target state="translated">A continuación, puede navegar a una dirección web específica mediante el método Navigate:</target>         
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.</source>
          <target state="translated">Con otros miembros del modelo de objetos de Internet Explorer, es posible recuperar el contenido de texto de la página web.</target>         
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The following command will display the HTML text in the body of the current Web page:</source>
          <target state="translated">El siguiente comando mostrará el texto HTML en el cuerpo de la página web actual:</target>         
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To close Internet Explorer from within PowerShell, call its Quit() method:</source>
          <target state="translated">Para cerrar Internet Explorer desde PowerShell, llame a su método Quit():</target>         
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This will force it to close.</source>
          <target state="translated">Se forzará el cierre.</target>         
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The $ie variable no longer contains a valid reference even though it still appears to be a COM object.</source>
          <target state="translated">La variable $ie ya no contiene una referencia válida, aunque parece ser un objeto COM.</target>         
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If you attempt to use it, you will get an automation error:</source>
          <target state="translated">Si intenta usarla, obtendrá un error de automatización:</target>         
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can either remove the remaining reference with a command like $ie <ph id="ph1">\=</ph> $null, or completely remove the variable by typing:</source>
          <target state="translated">Puede quitar la referencia restante con un comando como $ie <ph id="ph1">\=</ph> $null, o bien escribir lo siguiente para quitarla completamente:</target>         
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.</source>
          <target state="translated">No hay un estándar común para determinar si los ejecutables de ActiveX se cierran o se siguen ejecutando cuando se quita una referencia a uno de ellos.</target>         
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.</source>
          <target state="translated">Que la aplicación se cierre o no dependerá de las circunstancias, como, por ejemplo, si la aplicación es visible, si está ejecutando en ella un documento editado e incluso si Windows PowerShell todavía se está ejecutando.</target>         
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.</source>
          <target state="translated">Por este motivo, debe probar el comportamiento de finalización de cada ejecutable de ActiveX que quiere usar en Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Getting Warnings About .NET Framework<ph id="ph1">\-</ph>Wrapped COM Objects</source>
          <target state="translated">Obtener advertencias sobre los objetos COM ajustados por .NET Framework</target>         
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In some cases, a COM object might have an associated .NET Framework <bpt id="p1">*</bpt>Runtime<ph id="ph1">\-</ph>Callable Wrapper<ept id="p1">*</ept> or RCW, and this will be used by <bpt id="p2">**</bpt>New<ph id="ph2">\-</ph>Object<ept id="p2">**</ept>.</source>
          <target state="translated">En algunos casos, un objeto COM puede tener un <bpt id="p1">*</bpt>contenedor R<ph id="ph1">\-</ph>CW<ept id="p1">*</ept> de .NET Framework asociado, y lo usará <bpt id="p2">**</bpt>New<ph id="ph2">\-</ph>Object<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> has a <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> parameter to warn you about RCW access.</source>
          <target state="translated">Dado que el comportamiento del contenedor RCW puede ser diferente del comportamiento del objeto COM normal, <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> tiene un parámetro <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> para advertirle del acceso de dicho contenedor.</target>         
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:</source>
          <target state="translated">Si especifica el parámetro <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> y, a continuación, crea un objeto COM que usa un RCW, recibirá un mensaje de advertencia:</target>         
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Although the object is still created, you are warned that it is not a standard COM object.</source>
          <target state="translated">Aunque el objeto se creará de todos modos, se le advertirá que no es un objeto COM estándar.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>