<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-56a7a5e" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">233ec6fafbf1e770190601750be3bdcef2337b7f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Understanding-the-Windows-PowerShell-Pipeline.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5498e5f82297e1588a9414af179aad1497384f9</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Compréhension du pipeline Windows PowerShell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,applet de commande</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Compréhension du pipeline Windows PowerShell</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Piping works virtually everywhere in Windows PowerShell.</source>
          <target state="translated">Le piping fonctionne pratiquement partout dans Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Although you see text on the screen, Windows PowerShell does not pipe text between commands.</source>
          <target state="translated">Même si vous voyez du texte à l’écran, Windows PowerShell ne canalise pas de texte entre des commandes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Instead, it pipes objects.</source>
          <target state="translated">Au lieu de cela, il canalise des objets.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The notation used for pipelines is similar to that used in other shells, so at first glance, it may not be apparent that Windows PowerShell introduces something new.</source>
          <target state="translated">La notation utilisée pour les pipelines est similaire à celle utilisée dans d’autres interpréteurs de commandes. Ainsi, à première vue, les nouveautés de Windows PowerShell peuvent ne pas sembler évidentes.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, if you use the <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> cmdlet to force a page<ph id="ph2">\-</ph>by<ph id="ph3">\-</ph>page display of output from another command, the output looks just like the normal text displayed on the screen, broken up into pages:</source>
          <target state="translated">Par exemple, si vous utilisez l’applet de commande <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> pour forcer un affichage page par page de la sortie d’une autre commande, la sortie ressemble exactement au texte normal affiché à l’écran, mais divisé en pages :</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Out<ph id="ph1">\-</ph>Host <ph id="ph2">\-</ph>Paging command is a useful pipeline element whenever you have lengthy output that you would like to display slowly.</source>
          <target state="translated">La commande Out<ph id="ph1">\-</ph>Host <ph id="ph2">\-</ph>Paging est un élément de pipeline utile chaque fois que vous avez une sortie longue que vous souhaitez afficher lentement.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It is especially useful if the operation is very CPU<ph id="ph1">\-</ph>intensive.</source>
          <target state="translated">Elle est particulièrement utile si l’opération nécessite une utilisation importante du processeur.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Because processing is transferred to the Out<ph id="ph1">\-</ph>Host cmdlet when it has a complete page ready to display, cmdlets that precede it in the pipeline halt operation until the next page of output is available.</source>
          <target state="translated">Étant donné que le traitement est transféré à l’applet de commande Out<ph id="ph1">\-</ph>Host quand une page complète est prête pour affichage, les applets de commande précédentes dans le pipeline suspendent l’opération jusqu’à ce que la page de sortie suivante est disponible.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see this if you use the Windows Task Manager to monitor CPU and memory use by Windows PowerShell.</source>
          <target state="translated">Vous pouvez voir cela si vous utilisez le Gestionnaire des tâches de Windows pour surveiller l’utilisation du processeur et de la mémoire par Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Run the following command: <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>ChildItem C:<ph id="ph2">\\</ph>Windows <ph id="ph3">\-</ph>Recurse<ept id="p1">**</ept>.</source>
          <target state="translated">Exécutez la commande suivante : <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>ChildItem C:<ph id="ph2">\\</ph>Windows <ph id="ph3">\-</ph>Recurse<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Compare the CPU and memory usage to this command: <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>ChildItem C:<ph id="ph2">\\</ph>Windows <ph id="ph3">\-</ph>Recurse | Out<ph id="ph4">\-</ph>Host <ph id="ph5">\-</ph>Paging<ept id="p1">**</ept>.</source>
          <target state="translated">Comparez l’utilisation du processeur et de la mémoire à la sortie de la commande suivante : <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>ChildItem C:<ph id="ph2">\\</ph>Windows <ph id="ph3">\-</ph>Recurse | Out<ph id="ph4">\-</ph>Host <ph id="ph5">\-</ph>Paging<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What you see on the screen is text, but that is because it is necessary to represent objects as text in a console window.</source>
          <target state="translated">Si ce que vous voyez à l’écran est du texte, c’est parce qu’il est de nécessaire représenter les objets sous forme de texte dans une fenêtre de console.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is just a representation of what is really going on inside Windows PowerShell.</source>
          <target state="translated">Il s’agit juste d’une représentation de ce qui se passe vraiment dans Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, consider the Get<ph id="ph1">\-</ph>Location cmdlet.</source>
          <target state="translated">Par exemple, considérez l’applet de commande Get<ph id="ph1">\-</ph>Location.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you type <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> while your current location is the root of the C drive, you would see the following output:</source>
          <target state="translated">Si vous tapez <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> alors que votre emplacement actuel est la racine du lecteur C, la sortie est la suivante :</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If Windows PowerShell pipelined text, issuing a command such as <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location | Out<ph id="ph2">\-</ph>Host<ept id="p1">**</ept>, would pass from <bpt id="p2">**</bpt>Get<ph id="ph3">\-</ph>Location<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Out<ph id="ph4">\-</ph>Host<ept id="p3">**</ept> a set of characters in the order they are displayed onscreen.</source>
          <target state="translated">Si le texte figure dans un pipeline Windows PowerShell, l’émission d’une commande telle que <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location | Out<ph id="ph2">\-</ph>Host<ept id="p1">**</ept> a pour effet de transmettre de <bpt id="p2">**</bpt>Get<ph id="ph3">\-</ph>Location<ept id="p2">**</ept> à <bpt id="p3">**</bpt>Out<ph id="ph4">\-</ph>Host<ept id="p3">**</ept> un jeu de caractères dans l’ordre de leur affichage à l’écran.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In other words, if you were to ignore the heading information, <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> would first receive the character '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, then the character '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, then the character '<bpt id="p4">**</bpt><ph id="ph2">\\</ph>'<ept id="p4">**</ept>.</source>
          <target state="translated">En d’autres termes, si vous deviez ignorer les informations d’en-tête, <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> recevrait d’abord le caractère '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, puis le caractère '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, puis le caractère '<bpt id="p4">**</bpt><ph id="ph2">\\</ph>'<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> cmdlet could not determine what meaning to associate with the characters output by the <bpt id="p2">**</bpt>Get<ph id="ph2">\-</ph>Location<ept id="p2">**</ept> cmdlet.</source>
          <target state="translated">Il se pourrait que l’applet de commande <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> ne puisse pas déterminer quelle signification associer à la sortie de caractères par l’applet de commande <bpt id="p2">**</bpt>Get<ph id="ph2">\-</ph>Location<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead of using text to let commands in a pipeline communicate, Windows PowerShell uses objects.</source>
          <target state="translated">Au lieu d’utiliser du texte pour vous permettre aux commandes dans un pipeline de communiquer, Windows PowerShell utilise des objets.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>From the standpoint of a user, objects package related information into a form that makes it easier to manipulate the information as a unit, and extract specific items that you need.</source>
          <target state="translated">Du point de vue d’un utilisateur, les objets empaquètent des informations connexes sous une forme facilitant la manipulation des informations en tant qu’unité, et l’extraction des éléments spécifiques dont vous avez besoin.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> command does not return text that contains the current path.</source>
          <target state="translated">La commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> ne retourne pas de texte contenant le chemin d’accès actuel.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It returns a package of information called a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object that contains the current path along with some other information.</source>
          <target state="translated">Elle retourne un ensemble d’informations appelé objet <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept>, qui contient le chemin d’accès actuel, ainsi que d’autres informations.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> cmdlet then sends this <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> object to the screen, and Windows PowerShell decides what information to display and how to display it based on its formatting rules.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>Out<ph id="ph1">\-</ph>Host<ept id="p1">**</ept> envoie ensuite cet objet <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> à l’écran, tandis que Windows PowerShell choisit les informations à afficher et leur mode d’affichage en fonction de ses règles de mise en forme.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In fact, the heading information output by the <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> cmdlet is added only at the end of the process, as part of the process of formatting the data for onscreen display.</source>
          <target state="translated">En fait, les informations d’en-tête retournées par l’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Location<ept id="p1">**</ept> ne sont ajoutées qu’à la fin du processus, dans le cadre de la mise en forme des données à afficher à l’écran.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>What you see onscreen is a summary of information, and not a complete representation of the output object.</source>
          <target state="translated">Ce que vous voyez à l’écran est un résumé des informations, non une représentation complète de l’objet de sortie.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Given that there may be more information output from a Windows PowerShell command than what we see displayed in the console window, how can you retrieve the non<ph id="ph1">\-</ph>visible elements?</source>
          <target state="translated">Étant donné qu’il peut y avoir plus d’informations générées par une commande Windows PowerShell que ce que nous voyons dans la fenêtre de console, comment récupérer les éléments invisibles ?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How do you view the extra data?</source>
          <target state="translated">Comment afficher les données supplémentaires ?</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>And what if you want to view the data in a format different than the one Windows PowerShell normally uses?</source>
          <target state="translated">Et que se passe-t-il si vous souhaitez afficher les données dans un format différent de celui que Windows PowerShell utilise normalement ?</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The rest of this chapter discusses how you can discover the structure of specific Windows PowerShell objects, selecting specific items and formatting them for easier display, and how to send this information to alternative output locations such as files and printers.</source>
          <target state="translated">Le reste de ce chapitre explique comment découvrir la structure d’objets Windows PowerShell spécifiques, en sélectionnant des éléments et en les mettant en forme pour un affichage plus facile, ainsi que comment envoyer ces informations à d’autres emplacements de sortie tels que des fichiers et des imprimantes.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>