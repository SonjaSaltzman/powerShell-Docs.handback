<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-db30baf" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e986e85a5d7416d8deaec06c0784263ee09fc9ff</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Creating-.NET-and-COM-Objects--New-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects  New Object</source>
          <target state="translated">Création d’objets .NET et COM (New Object)</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects (New-Object)</source>
          <target state="translated">Création d’objets .NET et COM (New-Object)</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.</source>
          <target state="translated">Il existe des composants logiciels avec des interfaces COM et .NET Framework, qui vous permettent d’effectuer de nombreuses tâches d’administration système.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.</source>
          <target state="translated">Windows PowerShell permet d’utiliser ces composants. Vous n’êtes donc pas limité aux tâches exécutables à l’aide d’applets de commande.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.</source>
          <target state="translated">La plupart des applets de commande dans la version initiale de Windows PowerShell ne fonctionnent pas sur des ordinateurs distants.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> class directly from Windows PowerShell.</source>
          <target state="translated">Nous allons expliquer comment contourner cette limitation lors de la gestion des journaux des événements à l’aide de la classe .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> directement à partir de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Using New<ph id="ph1">\-</ph>Object for Event Log Access</source>
          <target state="translated">Utilisation de l’applet de commande New<ph id="ph1">\-</ph>Object pour l’accès au journal des événements</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library includes a class named <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> that can be used to manage event logs.</source>
          <target state="translated">La bibliothèque de classes .NET Framework inclut une classe nommée <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> qui permet de gérer les journaux des événements.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can create a new instance of a .NET Framework class by using the <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> parameter.</source>
          <target state="translated">Vous pouvez créer une nouvelle instance d’une classe .NET Framework en utilisant l’applet de commande <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> avec le paramètre <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, the following command creates an event log reference:</source>
          <target state="translated">Par exemple, la commande suivante crée une référence de journal des événements :</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Although the command has created an instance of the EventLog class, the instance does not include any data.</source>
          <target state="translated">Même si la commande a créé une instance de la classe EventLog, l’instance n’inclut pas de données.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>That is because we did not specify a particular event log.</source>
          <target state="translated">Cela est dû au fait que nous n’avons pas spécifié de journal des événements spécifique.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>How do you get a real event log?</source>
          <target state="translated">Comment obtenir un journal des événements réel ?</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Using Constructors with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Utilisation de constructeurs avec l’applet de commande New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To refer to a specific event log, you need to specify the name of the log.</source>
          <target state="translated">Pour faire référence à un journal des événements spécifique, vous devez spécifier son nom.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> has an <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> parameter.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> a un paramètre <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The arguments you pass as values to this parameter are used by a special startup method of the object.</source>
          <target state="translated">Les arguments que vous passez en tant que valeurs pour ce paramètre sont utilisés par une méthode spéciale de démarrage de l’objet.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The method is called a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> because it is used to construct the object.</source>
          <target state="translated">La méthode est appelée <bpt id="p1">*</bpt>constructeur<ept id="p1">*</ept>, car elles est utilisée pour construire l’objet.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to get a reference to the Application log, you specify the string 'Application' as an argument:</source>
          <target state="translated">Par exemple, pour obtenir une référence au journal des applications, vous spécifiez la chaîne « Application » en tant qu’argument :</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.</source>
          <target state="translated">Étant donné que la plupart des classes de base de .NET Framework sont contenues dans l’espace de noms système, Windows PowerShell tente automatiquement de trouver les classes que vous spécifiez dans l’espace de noms système s’il ne trouve pas de correspondance pour le nom de type que vous spécifiez.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.</source>
          <target state="translated">Cela signifie que vous pouvez spécifier Diagnostics.EventLog au lieu de System.Diagnostics.EventLog.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Storing Objects in Variables</source>
          <target state="translated">Stockage d’objets dans des variables</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You might want to store a reference to an object, so you can use it in the current shell.</source>
          <target state="translated">Si vous souhaitez stocker une référence à un objet, vous pouvez l’utiliser dans l’interpréteur de commandes en cours.</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.</source>
          <target state="translated">Bien que Windows PowerShell permette d’effectuer de nombreuses tâches avec des pipelines, en réduisant le besoin de variables, parfois, des références de stockage à des objets dans des variables facilite la manipulation de ces objets.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables that are essentially named objects.</source>
          <target state="translated">Windows PowerShell permet de créer des variables qui sont essentiellement des objets nommés.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The output from any valid Windows PowerShell command can be stored in a variable.</source>
          <target state="translated">La sortie d’une commande Windows PowerShell valide peut être stockée dans une variable.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Variable names always begin with $.</source>
          <target state="translated">Les noms de variables commencent toujours par $.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:</source>
          <target state="translated">Si vous souhaitez stocker la référence de journal des applications dans une variable nommée $AppLog, tapez le nom de la variable, suivi d’un signe égal, puis tapez la commande utilisée pour créer l’objet journal des applications :</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you then type $AppLog, you can see that it contains the Application log:</source>
          <target state="translated">Si vous tapez $AppLog, vous pouvez voir qu’il contient le journal des applications :</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Accessing a Remote Event Log with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Accès à un journal des événements à distance avec New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The commands used in the preceding section target the local computer; the <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>EventLog<ept id="p1">**</ept> cmdlet can do that.</source>
          <target state="translated">Les commandes utilisées dans la section précédente ciblent l’ordinateur local. L’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>EventLog<ept id="p1">**</ept> peut faire cela.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.</source>
          <target state="translated">Pour accéder au journal des applications sur un ordinateur distant, vous devez fournir le nom du journal et un nom d’ordinateur (ou une adresse IP) en tant qu’arguments.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?</source>
          <target state="translated">Maintenant que nous avons une référence à un journal des événements stocké dans la variable $RemoteAppLog, quelles tâches pouvons-nous effectuer sur celui-ci ?</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Clearing an Event Log with Object Methods</source>
          <target state="translated">Effacement d’un journal des événements avec des méthodes d’objet</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Objects often have methods that can be called to perform tasks.</source>
          <target state="translated">Les objets ont souvent des méthodes associées qui peuvent être appelées pour effectuer des tâches.</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> to display the methods associated with an object.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> permet d’afficher les méthodes associées à un objet.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following command and selected output show some the methods of the EventLog class:</source>
          <target state="translated">La commande suivante et la sortie sélectionnée affichent certaines des méthodes de la classe EventLog :</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> method can be used to clear the event log.</source>
          <target state="translated">La méthode <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> permet d’effacer le journal des événements.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.</source>
          <target state="translated">Lors de l’appel d’une méthode, vous devez toujours faire suivre le nom de la méthode par des parenthèses, même si la méthode ne requiert pas d’argument.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This lets Windows PowerShell distinguish between the method and a potential property with the same name.</source>
          <target state="translated">Cela permet à Windows PowerShell de faire la distinction entre la méthode et une propriété éventuelle du même nom.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Type the following to call the <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> method:</source>
          <target state="translated">Tapez ce qui suit pour appeler la méthode <bpt id="p1">**</bpt>clair<ept id="p1">**</ept> :</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Type the following to display the log.</source>
          <target state="translated">Tapez ce qui suit pour afficher le journal.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You will see that the event log was cleared, and now has 0 entries instead of 262:</source>
          <target state="translated">Vous voyez que le journal des événements a été effacé et contient désormais 0 entrée au lieu de 262 :</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Creating COM Objects with New<ph id="ph1">\-</ph>Object</source>
          <target state="translated">Création d’objets COM avec New<ph id="ph1">\-</ph>Object</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> to work with Component Object Model (COM) components.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> permet d’utiliser des composants COM (Component Object Model).</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.</source>
          <target state="translated">Les composants vont des différentes bibliothèques incluses dans l’environnement d’exécution de scripts WSH (Windows Script Host) aux applications ActiveX telles qu’Internet Explorer qui sont installées sur la plupart des systèmes.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> uses .NET Framework Runtime<ph id="ph2">\-</ph>Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> utilise des wrappers RCW (Runtime<ph id="ph2">\-</ph>Callable Wrappers) .NET Framework pour créer des objets COM. Elle est donc sujette aux mêmes limitations que le .NET Framework lors de l’appel d’objets COM.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To create a COM object, you need to specify the <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> parameter with the Programmatic Identifier or <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> of the COM class you want to use.</source>
          <target state="translated">Pour créer un objet COM, vous devez spécifier le paramètre <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> avec l’identificateur programmatique, ou <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept>, de la classe COM que vous souhaitez utiliser.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well<ph id="ph1">\-</ph>known objects from environments such as WSH can be used within Windows PowerShell.</source>
          <target state="translated">Une description complète des limitations de l’utilisation de COM et de la détermination des ProgID disponibles sur un système dépasserait la portée de ce guide, mais la plupart des objets connus d’environnements tels que WSH peuvent être utilisés dans Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can create the WSH objects by specifying these progids: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</source>
          <target state="translated">Vous pouvez créer les objets WSH en spécifiant les ProgID suivants : <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, et <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The following commands create these objects:</source>
          <target state="translated">Les commandes suivantes créent ces objets :</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.</source>
          <target state="translated">Si l’essentiel de la fonctionnalité de ces classes est rendu disponible par d’autres moyens dans Windows PowerShell, quelques tâches telles que la création de raccourci sont encore plus faciles à effectuer à l’aide des classes WSH.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Creating a Desktop Shortcut with WScript.Shell</source>
          <target state="translated">Création d’un raccourci sur le Bureau avec WScript.Shell</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>One task that can be performed quickly with a COM object is creating a shortcut.</source>
          <target state="translated">Une tâche exécutable rapidement avec un objet COM est la création d’un raccourci.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.</source>
          <target state="translated">Supposons que vous souhaitez créer un raccourci sur votre bureau, qui établit un lien vers le dossier de base de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You first need to create a reference to <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, which we will store in a variable named <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</source>
          <target state="translated">Vous devez commencer par créer une référence à <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, que nous allons stocker dans une variable nommée <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept> :</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Get<ph id="ph1">\-</ph>Member works with COM objects, so you can explore the members of the object by typing:</source>
          <target state="translated">L’applet de commande Get<ph id="ph1">\-</ph>Member fonctionnant avec des objets COM, vous pouvez explorer les membres de l’objet en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> has an optional <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> parameter you can use instead of piping to provide input to <bpt id="p3">**</bpt>Get<ph id="ph2">\-</ph>Member<ept id="p3">**</ept>.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> dispose d’un paramètre facultatif, <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept>, que vous pouvez utiliser à la place d’un piping pour fournir l’entrée à <bpt id="p3">**</bpt>Get<ph id="ph2">\-</ph>Member<ept id="p3">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You would get the same output as shown above if you instead used the command <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member <ph id="ph2">\-</ph>InputObject $WshShell<ept id="p1">**</ept>.</source>
          <target state="translated">Vous obtiendriez la même sortie que celle indiquée ci-dessus si vous utilisez à la place la commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member <ph id="ph2">\-</ph>InputObject $WshShell<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, it treats its argument as a single item.</source>
          <target state="translated">Si vous utilisez <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, l’argument est traité comme un seul élément.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This means that if you have several objects in a variable, <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> treats them as an array of objects.</source>
          <target state="translated">Cela signifie que si vous disposez de plusieurs objets dans une variable, l’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> les traite comme un tableau d’objets.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Par exemple :</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> method accepts a single argument, the path to the shortcut file to create.</source>
          <target state="translated">La méthode <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> accepte un seul argument, le chemin d’accès au fichier de raccourci à créer.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>We could type in the full path to the desktop, but there is an easier way.</source>
          <target state="translated">Nous pourrions taper le chemin d’accès complet au bureau, mais il existe un moyen plus simple.</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The desktop is normally represented by a folder named Desktop inside the home folder of the current user.</source>
          <target state="translated">Le bureau est généralement représenté par un dossier nommé Bureau à l’intérieur du dossier de base de l’utilisateur actuel.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has a variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> that contains the path to this folder.</source>
          <target state="translated">Windows PowerShell dispose d’une variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> qui contient le chemin d’accès à ce dossier.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:</source>
          <target state="translated">Nous pouvons spécifier le chemin d’accès au dossier de base à l’aide de cette variable, puis ajouter le nom du dossier Bureau et le nom du raccourci à créer en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>When you use something that looks like a variable name inside double<ph id="ph1">\-</ph>quotes, Windows PowerShell tries to substitute a matching value.</source>
          <target state="translated">Lorsque vous utilisez quelque chose ressemblant à un nom de variable entre guillemets doubles, Windows PowerShell tente de remplacer cet élément par une valeur correspondante.</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If you use single<ph id="ph1">\-</ph>quotes, Windows PowerShell does not try to substitute the variable value.</source>
          <target state="translated">Si vous utilisez des guillemets simples, Windows PowerShell n’essaie pas de remplacer la variable par une valeur.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, try typing the following commands:</source>
          <target state="translated">Par exemple, essayez de taper les commandes suivantes :</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>We now have a variable named <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> that contains a new shortcut reference.</source>
          <target state="translated">Nous avons désormais une variable nommée <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> qui contient une nouvelle référence au raccourci.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If you want to see its members, you can pipe it to <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>.</source>
          <target state="translated">Si vous souhaitez voir ses membres, vous pouvez la canaliser vers l’applet de commande <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The output below shows the members we need to use to finish creating our shortcut:</source>
          <target state="translated">La sortie ci-dessous montre les membres que nous devons utiliser pour achever la création de notre raccourci :</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</source>
          <target state="translated">PS&gt; $lnk | Get-Member TypeName: System.__ComObject#{f935dc23-1cf0-11d0-adb9-00c04fd58a0b} Name             MemberType   Definition ----             ----------   ---------- ... Save             Method       void Save () ... TargetPath       Property     string TargetPath () {get} {set} ...</target>         
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>We need to specify the <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> by calling the <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> method.</source>
          <target state="translated">Nous devons spécifier <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, qui est le dossier d’application pour Windows PowerShell, puis enregistrer le raccourci <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> en appelant la méthode <bpt id="p3">**</bpt>Save<ept id="p3">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell application folder path is stored in the variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, so we can do this by typing:</source>
          <target state="translated">Le chemin d’accès au dossier d’application de Windows PowerShell étant stocké dans la variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, nous pouvons faire cela en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>$lnk.TargetPath = $PSHome $lnk.Save()</source>
          <target state="translated">$lnk.TargetPath = $PSHome $lnk.Save()</target>         
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Using Internet Explorer from Windows PowerShell</source>
          <target state="translated">Utilisation d’Internet Explorer à partir de Windows PowerShell</target>         
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.</source>
          <target state="translated">De nombreuses applications (dont la famille d’applications Microsoft Office et Internet Explorer) peuvent être automatisées à l’aide de COM.</target>         
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Internet Explorer illustrates some of the typical techniques and issues involved in working with COM<ph id="ph1">\-</ph>based applications.</source>
          <target state="translated">Internet Explorer illustre certains problèmes et techniques classiques impliqués dans l’utilisation d’applications basées sur COM.</target>         
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</source>
          <target state="translated">Vous créez une instance Internet Explorer en spécifiant le ProgId d’Internet Explorer, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept> :</target>         
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This command starts Internet Explorer, but does not make it visible.</source>
          <target state="translated">Cette commande démarre Internet Explorer, mais ne le rend pas visible.</target>         
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If you type Get<ph id="ph1">\-</ph>Process, you can see that a process named iexplore is running.</source>
          <target state="translated">Si vous tapez Get<ph id="ph1">\-</ph>Process, vous pouvez voir qu’un processus nommé iexplore est en cours d’exécution.</target>         
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In fact, if you exit Windows PowerShell, the process will continue to run.</source>
          <target state="translated">En fait, si vous quittez Windows PowerShell, le processus continue à s’exécuter.</target>         
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>You must reboot the computer or use a tool like Task Manager to end the iexplore process.</source>
          <target state="translated">Pour arrêter le processus iexplore, vous devez redémarrer l’ordinateur ou utiliser un outil tel que le Gestionnaire des tâches.</target>         
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>COM objects that start as separate processes, commonly called <bpt id="p1">*</bpt>ActiveX executables<ept id="p1">*</ept>, may or may not display a user interface window when they start up.</source>
          <target state="translated">Les objets COM qui démarrent en tant que processus séparés, généralement appelés <bpt id="p1">*</bpt>exécutables ActiveX<ept id="p1">*</ept>, peuvent ou non afficher une fenêtre d’interface utilisateur au démarrage.</target>         
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.</source>
          <target state="translated">S’ils créent une fenêtre, comme Internet Explorer, mais ne la rendent pas visible, le focus se positionne généralement sur le Bureau Windows, et vous devez rendre la fenêtre visible pour pouvoir interagir avec elle.</target>         
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>By typing <bpt id="p1">**</bpt>$ie | Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>, you can view properties and methods for Internet Explorer.</source>
          <target state="translated">Pour afficher les propriétés et méthodes pour Internet Explorer, tapez <bpt id="p1">**</bpt>$ie | Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>To see the Internet Explorer window, set the Visible property to $true by typing:</source>
          <target state="translated">Pour afficher la fenêtre Internet Explorer, définissez la propriété Visible sur $true en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You can then navigate to a specific Web address by using the Navigate method:</source>
          <target state="translated">Vous pouvez ensuite accéder à une adresse web spécifique à l’aide de la méthode Navigate :</target>         
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.</source>
          <target state="translated">En utilisant d’autres membres du modèle d’objet Internet Explorer, vous pouvez récupérer le contenu de texte de la page web.</target>         
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The following command will display the HTML text in the body of the current Web page:</source>
          <target state="translated">La commande suivante affiche le texte HTML dans le corps de la page web active :</target>         
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>To close Internet Explorer from within PowerShell, call its Quit() method:</source>
          <target state="translated">Pour fermer Internet Explorer à partir de PowerShell, appelez sa méthode Quit() :</target>         
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This will force it to close.</source>
          <target state="translated">Cette opération force la fermeture.</target>         
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The $ie variable no longer contains a valid reference even though it still appears to be a COM object.</source>
          <target state="translated">La variable $ie ne contient plus de référence valide, même si elle apparaît toujours comme un objet COM.</target>         
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>If you attempt to use it, you will get an automation error:</source>
          <target state="translated">Si vous tentez de l’utiliser, vous obtenez une erreur Automation :</target>         
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You can either remove the remaining reference with a command like $ie <ph id="ph1">\=</ph> $null, or completely remove the variable by typing:</source>
          <target state="translated">Vous pouvez soit supprimer la référence restante avec une commande telle que $ie <ph id="ph1">\=</ph> $null, ou supprimer complètement la variable en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.</source>
          <target state="translated">Il n’existe aucune norme commune déterminant si les exécutables ActiveX s’arrêtent ou continuent à s’exécuter lorsque vous supprimez une référence à ceux-ci.</target>         
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.</source>
          <target state="translated">En fonction des circonstances, selon que l’application est visible, qu’un document modifié est en cours d’exécution dans celle-ci, et même que Windows PowerShell est toujours en cours d’exécution, l’application peut se fermer ou non.</target>         
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.</source>
          <target state="translated">C’est pourquoi, vous devez tester le comportement d’arrêt de chaque exécutable ActiveX à utiliser dans Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Getting Warnings About .NET Framework<ph id="ph1">\-</ph>Wrapped COM Objects</source>
          <target state="translated">Obtention d’alertes sur les objets COM encapsulés .NET Framework</target>         
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>In some cases, a COM object might have an associated .NET Framework <bpt id="p1">*</bpt>Runtime<ph id="ph1">\-</ph>Callable Wrapper<ept id="p1">*</ept> or RCW, and this will be used by <bpt id="p2">**</bpt>New<ph id="ph2">\-</ph>Object<ept id="p2">**</ept>.</source>
          <target state="translated">Dans certains cas, un objet COM peut avoir un wrapper RCW (<bpt id="p1">*</bpt>Runtime<ph id="ph1">\-</ph>Callable Wrapper<ept id="p1">*</ept>) .NET Framework associé, qui sera utilisé par l’applet de commande <bpt id="p2">**</bpt>New<ph id="ph2">\-</ph>Object<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> has a <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> parameter to warn you about RCW access.</source>
          <target state="translated">Étant donné que le comportement du wrapper RCW peut différer du comportement de l’objet COM normal, l’applet de commande <bpt id="p1">**</bpt>New<ph id="ph1">\-</ph>Object<ept id="p1">**</ept> dispose d’un paramètre <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> pour vous avertir de l’accès au wrapper RCW.</target>         
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:</source>
          <target state="translated">Si vous spécifiez le paramètre <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept>, puis créez un objet COM qui utilise un wrapper RCW, vous recevez un message d’avertissement :</target>         
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Although the object is still created, you are warned that it is not a standard COM object.</source>
          <target state="translated">Bien que l’objet soit toujours créé, vous êtes averti qu’il ne s’agit pas d’un objet COM standard.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>