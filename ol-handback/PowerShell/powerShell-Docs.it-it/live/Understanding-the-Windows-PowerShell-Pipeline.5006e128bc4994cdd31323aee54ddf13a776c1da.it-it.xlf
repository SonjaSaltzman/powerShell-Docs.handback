<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d90bf940a1047b629f7b59d239aab50a78748251</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Understanding-the-Windows-PowerShell-Pipeline.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3807ae2a9e602afdc13185cc04769af2ed122e7</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Informazioni sulla pipeline di Windows PowerShell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Informazioni sulla pipeline di Windows PowerShell</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Piping works virtually everywhere in Windows PowerShell.</source>
          <target state="translated">Il piping è usato praticamente ovunque in Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Although you see text on the screen, Windows PowerShell does not pipe text between commands.</source>
          <target state="translated">Anche se sullo schermo viene visualizzato del testo, Windows PowerShell non invia tramite pipe testo tra i comandi,</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Instead, it pipes objects.</source>
          <target state="translated">bensì oggetti.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The notation used for pipelines is similar to that used in other shells, so at first glance, it may not be apparent that Windows PowerShell introduces something new.</source>
          <target state="translated">La notazione usata per le pipeline è simile a quella usata in altre shell, pertanto, a prima vista, potrebbe non essere evidente che Windows PowerShell stia introducendo qualcosa di nuovo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, if you use the <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet to force a page-by-page display of output from another command, the output looks just like the normal text displayed on the screen, broken up into pages:</source>
          <target state="translated">Se ad esempio si usa il cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> per forzare una visualizzazione pagina per pagina dell'output di un altro comando, l'output avrà lo stesso aspetto del normale testo visualizzato sullo schermo, suddiviso in pagine:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Out-Host -Paging command is a useful pipeline element whenever you have lengthy output that you would like to display slowly.</source>
          <target state="translated">Il comando Out-Host -Paging è un elemento della pipeline utile in caso di output lungo da visualizzare lentamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It is especially useful if the operation is very CPU-intensive.</source>
          <target state="translated">La sua utilità si rivela in particolare se l'operazione richiede un uso elevato della CPU.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Because processing is transferred to the Out-Host cmdlet when it has a complete page ready to display, cmdlets that precede it in the pipeline halt operation until the next page of output is available.</source>
          <target state="translated">Dal momento che l'elaborazione viene trasferita al cmdlet Out-Host quando dispone di una pagina completa pronta per la visualizzazione, i cmdlet che lo precedono nella pipeline interrompono l'operazione finché non è disponibile la pagina successiva di output.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see this if you use the Windows Task Manager to monitor CPU and memory use by Windows PowerShell.</source>
          <target state="translated">È possibile vedere questo comportamento se si usa Gestione attività Windows per monitorare l'uso della CPU e della memoria da parte di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Run the following command: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse<ept id="p1">**</ept>.</source>
          <target state="translated">Eseguire il comando seguente: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Compare the CPU and memory usage to this command: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse | Out-Host -Paging<ept id="p1">**</ept>.</source>
          <target state="translated">Confrontare l'uso della CPU e della memoria con questo comando: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse | Out-Host -Paging<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What you see on the screen is text, but that is because it is necessary to represent objects as text in a console window.</source>
          <target state="translated">Quello che si vede sullo schermo è testo, poiché è necessario rappresentare gli oggetti come testo in una finestra della console.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is just a representation of what is really going on inside Windows PowerShell.</source>
          <target state="translated">Questa è solo una rappresentazione di quello che accade veramente in Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, consider the Get-Location cmdlet.</source>
          <target state="translated">Si consideri ad esempio il cmdlet Get-Location.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you type <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> while your current location is the root of the C drive, you would see the following output:</source>
          <target state="translated">Se si digita <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> mentre il percorso corrente è la radice dell'unità C, verrà visualizzato l'output seguente:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If Windows PowerShell pipelined text, issuing a command such as <bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept>, would pass from <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> a set of characters in the order they are displayed onscreen.</source>
          <target state="translated">Se Windows PowerShell ha inviato il testo attraverso una pipe, emettendo un comando come <bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept>, passerà da <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> a <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> un set di caratteri nell'ordine in cui sono visualizzati sullo schermo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In other words, if you were to ignore the heading information, <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> would first receive the character '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, then the character '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, then the character '<bpt id="p4">**</bpt><ph id="ph1">\\</ph>'<ept id="p4">**</ept>.</source>
          <target state="translated">In altre parole, se le informazioni dell'intestazione venissero ignorate, <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> riceverebbe per prima cosa il carattere "<bpt id="p2">**</bpt>C"<ept id="p2">**</ept>, quindi il carattere "<bpt id="p3">**</bpt>:"<ept id="p3">**</ept> e infine il carattere "<bpt id="p4">**</bpt><ph id="ph1">\\</ph>"<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet could not determine what meaning to associate with the characters output by the <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> cmdlet.</source>
          <target state="translated">Il cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> non è in grado di determinare quale significato associare all'output di caratteri del cmdlet <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead of using text to let commands in a pipeline communicate, Windows PowerShell uses objects.</source>
          <target state="translated">Invece di usare del testo per consentire ai comandi in una pipeline di comunicare, Windows PowerShell usa oggetti.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>From the standpoint of a user, objects package related information into a form that makes it easier to manipulate the information as a unit, and extract specific items that you need.</source>
          <target state="translated">Dal punto di vista di un utente, gli oggetti impacchettano le informazioni correlate in un modulo che rende più semplice manipolare le informazioni come unità ed estrarre gli specifici elementi richiesti.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> command does not return text that contains the current path.</source>
          <target state="translated">Il comando <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> non restituisce testo contenente il percorso corrente,</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It returns a package of information called a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object that contains the current path along with some other information.</source>
          <target state="translated">ma un pacchetto di informazioni denominato oggetto <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> che contiene il percorso corrente insieme ad altre informazioni.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet then sends this <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> object to the screen, and Windows PowerShell decides what information to display and how to display it based on its formatting rules.</source>
          <target state="translated">Il cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> invia quindi questo oggetto <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> sullo schermo e Windows PowerShell decide quali informazioni visualizzare e come visualizzarle in base alle proprie regole di formattazione.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In fact, the heading information output by the <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> cmdlet is added only at the end of the process, as part of the process of formatting the data for onscreen display.</source>
          <target state="translated">In realtà, l'output delle informazioni dell'intestazione del cmdlet <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> viene aggiunto solo alla fine del processo, durante la formattazione dei dati per la visualizzazione sullo schermo.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>What you see onscreen is a summary of information, and not a complete representation of the output object.</source>
          <target state="translated">Ciò che compare sullo schermo è un riepilogo delle informazioni e non una rappresentazione completa dell'oggetto di output.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Given that there may be more information output from a Windows PowerShell command than what we see displayed in the console window, how can you retrieve the non-visible elements?</source>
          <target state="translated">Dato che possono esistere più output di informazioni da un comando di Windows PowerShell rispetto a quelli visualizzati nella finestra della console, in che modo è possibile recuperare gli elementi non visibili?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How do you view the extra data?</source>
          <target state="translated">Come si visualizzano i dati aggiuntivi?</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>And what if you want to view the data in a format different than the one Windows PowerShell normally uses?</source>
          <target state="translated">E cosa accade se si vogliono visualizzare i dati in un formato diverso da quello che Windows PowerShell usa normalmente?</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The rest of this chapter discusses how you can discover the structure of specific Windows PowerShell objects, selecting specific items and formatting them for easier display, and how to send this information to alternative output locations such as files and printers.</source>
          <target state="translated">Nel resto di questa sezione viene spiegato come individuare la struttura di oggetti specifici di Windows PowerShell, selezionando elementi specifici e formattandoli per una visualizzazione più semplice, e come inviare queste informazioni a percorsi di output alternativi, ad esempio file e stampanti.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>