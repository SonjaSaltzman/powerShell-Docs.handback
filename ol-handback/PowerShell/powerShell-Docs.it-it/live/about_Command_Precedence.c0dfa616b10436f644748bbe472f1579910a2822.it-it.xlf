<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e64799232a97a2ccc413eedab8847a68fc45f805</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Command_Precedence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a73f57efd0a2d7eb74d3017f761cf8de22d9dbed</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff216515ee10fbdc6f1053f80852fa01f0958004</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Command Precedence</source>
          <target state="translated">Sulla precedenza dei comandi</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIZIONE BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how Windows PowerShell determines which command to run.</source>
          <target state="translated">Descrive il modo in cui Windows PowerShell determina quale comando eseguire.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIZIONE LUNGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic explains how Windows PowerShell determines which command to run, especially when a session contains more than one command with the same name.</source>
          <target state="translated">In questo argomento viene illustrato come Windows PowerShell determina quale comando da eseguire, in particolare quando una sessione contiene più di un comando con lo stesso nome.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also explains how to run commands that do not run by default, and it explains how to avoid command-name conflicts in your session.</source>
          <target state="translated">Viene inoltre spiegato come eseguire comandi che non vengono eseguiti per impostazione predefinita e viene spiegato come evitare conflitti di nomi di comando nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>COMMAND PRECEDENCE</source>
          <target state="translated">PRIORITÀ DEI COMANDI</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When a session includes commands that have the same name, Windows PowerShell uses the following rules to decide which command to run.</source>
          <target state="translated">Quando una sessione include comandi che hanno lo stesso nome, Windows PowerShell utilizza le regole seguenti per decidere quale comando eseguire.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These rules become very important when you add commands to your session from modules, snap-ins, and other sessions.</source>
          <target state="translated">Queste regole diventano molto importante quando si aggiungono i comandi alla sessione da moduli, snap-in e altre sessioni.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-- If you specify the path to a command, Windows PowerShell runs the command at the location specified by the path.</source>
          <target state="translated">-Se si specifica il percorso a un comando, Windows PowerShell esegue il comando nella posizione specificata dal percorso.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the following command runs the FindDocs.ps1 script in the C:\TechDocs directory:</source>
          <target state="translated">Ad esempio, il comando seguente esegue lo script FindDocs.ps1 nella directory C:\TechDocs:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C:\TechDocs\FindDocs.ps1</source>
          <target state="translated">C:\TechDocs\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>As a security feature, Windows PowerShell does not run executable (native) commands, including Windows PowerShell scripts, unless the command is located in a path that is listed in the Path environment variable ($env:path) or unless you specify the path to the script file.</source>
          <target state="translated">Per migliorare la protezione, Windows PowerShell non esegue comandi eseguibili (nativi), inclusi gli script di Windows PowerShell, a meno che il comando si trova in un percorso elencato nella variabile di ambiente Path ($env: percorso) o se non si specifica il percorso del file di script.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To run a script that is in the current directory, specify the full path, or type a dot (.) to represent the current directory.</source>
          <target state="translated">Per eseguire uno script che si trova nella directory corrente, specificare il percorso completo o digitare un punto (.) per rappresentare la directory corrente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to run the FindDocs.ps1 file in the current directory, type:</source>
          <target state="translated">Ad esempio, per eseguire il file FindDocs.ps1 nella directory corrente, digitare:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.\FindDocs.ps1</source>
          <target state="translated">.\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-- If you do not specify a path, Windows PowerShell uses the following precedence order when it runs commands:</source>
          <target state="translated">-Se non si specifica un percorso, Windows PowerShell utilizza l'ordine di precedenza seguente durante l'esecuzione di comandi:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Cmdlet</source>
          <target state="translated">Cmdlet</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Native Windows commands</source>
          <target state="translated">Comandi nativi di Windows</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Therefore, if you type "help", Windows PowerShell first looks for an alias named "help", then a function named "Help", and finally a cmdlet named "Help".</source>
          <target state="translated">Pertanto, se si digita "help", Windows PowerShell cerca innanzitutto un alias denominato "help", quindi, una funzione denominata "Help" e infine un cmdlet denominato "Help".</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It runs the first "help" item that it finds.</source>
          <target state="translated">Viene eseguito il primo elemento "help" che si trova.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, if you have a Get-Map function in the session and you import a cmdlet named Get-Map.</source>
          <target state="translated">Ad esempio, se si dispone di una funzione Get-mappa nella sessione e si importa un cmdlet denominato Get-Map.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By default, when you type "Get-Map", Windows PowerShell runs the Get-Map function.</source>
          <target state="translated">Per impostazione predefinita, quando si digita "Get-mappa", Windows PowerShell esegue la funzione Get-Map.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-- When the session contains items of the same type that have the same name, such as two cmdlets with the same name, Windows PowerShell runs the item that was added to the session most recently.</source>
          <target state="translated">-- Quando la sessione contiene gli elementi dello stesso tipo che hanno lo stesso nome, ad esempio due cmdlet con lo stesso nome, Windows PowerShell viene eseguito l'elemento che è stato aggiunto alla sessione più recente.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if you have a cmdlet named Get-Date and you import another cmdlet named Get-Date, by default, Windows PowerShell runs the most-recently imported cmdlet when you type "Get-Date".</source>
          <target state="translated">Ad esempio, se si dispone di un cmdlet denominato Get-Date e si importa un altro cmdlet denominato Get-Date, per impostazione predefinita, Windows PowerShell esegue il cmdlet più di recente importato quando si digita "Get-Date".</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>HIDDEN and REPLACED ITEMS As a result of these rules, items can be replaced or hidden by items with the same name.</source>
          <target state="translated">Gli ELEMENTI NASCOSTI e SOSTITUITO in seguito a queste regole, gli elementi possono essere sostituiti o nascosti in base a elementi con lo stesso nome.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>--  Items are "hidden" or "shadowed" if you can still access the original item, such as by qualifying the item name with a module or snap-in name.</source>
          <target state="translated">-Elementi sono "nascosti" o "nascosti" se è possibile accedere ancora dell'elemento originale, ad esempio, specificando il nome di elemento a un modulo o snap-in.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if you import a function that has the same name as a cmdlet in the session, the cmdlet is hidden (but not replaced) because it was imported from a snap-in or module.</source>
          <target state="translated">Ad esempio, se si importa una funzione con lo stesso nome di un cmdlet nella sessione, il cmdlet viene nascosto (ma non sostituito) perché è stata importata da un snap-in o modulo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>--  Items are "replaced" or "overwritten" if you can no longer access the original item.</source>
          <target state="translated">-Elementi sono "sostituiti" o "sovrascritti" Se non è possibile accedere all'elemento originale.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if you import a variable that has the same name as a a variable in the session, the original variable is replaced and is no longer accessible.</source>
          <target state="translated">Ad esempio, se si importa una variabile con lo stesso nome di una variabile nella sessione, la variabile originale viene sostituita e non è più accessibile.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You cannot qualify a variable with a module name.</source>
          <target state="translated">Non è possibile qualificare una variabile con un nome di modulo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, if you type a function at the command line and then import a function with the same name, the original function is replaced and is no longer accessible.</source>
          <target state="translated">Inoltre, se si digita una funzione nella riga di comando e quindi Importa una funzione con lo stesso nome, la funzione originale viene sostituita e non è più accessibile.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>FINDING HIDDEN COMMANDS</source>
          <target state="translated">COMANDI DI RICERCA NASCOSTO</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The All parameter of the Get-Command cmdlet gets all commands with the specified name, even if they are hidden or replaced.</source>
          <target state="translated">Il parametro All del cmdlet Get-Command Ottiene tutti i comandi con il nome specificato, anche se sono nascosti o sostituiti.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, by default, Get-Command gets only the commands that run when you type the command name.</source>
          <target state="translated">A partire da Windows PowerShell 3.0, per impostazione predefinita, Get-Command ottiene solo i comandi da eseguire quando si digita il nome del comando.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In the following examples, the session includes a Get-Date function and a Get-Date cmdlet.</source>
          <target state="translated">Nell'esempio seguente, la sessione include una funzione Get-Date e un cmdlet Get-Date.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following command gets the Get-Date command that runs when you type "Get-Date".</source>
          <target state="translated">Il comando seguente ottiene il comando Get-Date che viene eseguito quando si digita "Get-Date".</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date</source>
          <target state="translated">PS C: &gt; Get-Command Get-Date</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">Nome CommandType ModuleName</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Function        get-date</source>
          <target state="translated">Funzione get-date</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following command uses the All parameter to get all Get-Date commands.</source>
          <target state="translated">Il comando seguente usa il parametro All per ottenere tutti i comandi Get-Date.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date -All</source>
          <target state="translated">PS C: &gt; Get-Command Get-Date-tutti</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">Nome CommandType ModuleName</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Function        get-date Cmdlet          Get-Date                                           Microsoft.PowerShell.Utility</source>
          <target state="translated">Funzione get-date Cmdlet Get-Date Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>RUNNING HIDDEN COMMANDS</source>
          <target state="translated">ESECUZIONE DEI COMANDI NASCOSTI</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can run particular commands by specifying item properties that distinguish the command from other commands that might have the same name.</source>
          <target state="translated">È possibile eseguire comandi specifici specificando proprietà degli elementi che consentono di distinguere il comando da altri comandi che potrebbero avere lo stesso nome.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can use this method to run any command, but it is especially useful for running hidden commands.</source>
          <target state="translated">È possibile utilizzare questo metodo per eseguire qualsiasi comando, ma è particolarmente utile per l'esecuzione di comandi nascosti.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use this method as a best practice when writing scripts that you intend to distribute because you cannot predict which commands might be present in the session in which the script runs.</source>
          <target state="translated">Utilizzare questo metodo come procedura consigliata quando si scrivono script che si intende distribuire perché non è possibile prevedere quali comandi possono essere presenti nella sessione in cui viene eseguito lo script.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>QUALIFIED NAMES</source>
          <target state="translated">NOMI COMPLETI</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can run commands that have been imported from a Windows PowerShell snap-in or module or from another session by qualifying the command name with the name of the module or snap-in in which it originated.</source>
          <target state="translated">È possibile eseguire comandi che sono stati importati da un snap-in Windows PowerShell o un modulo o da un'altra sessione specificando il nome del comando con il nome del modulo o snap-in cui ha avuto origine.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can qualify commands, but you cannot qualify variables or aliases.</source>
          <target state="translated">È possibile qualificare i comandi, ma non è possibile qualificare le variabili o gli alias.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example, if the Get-Date cmdlet from the Microsoft.PowerShell.Utility snap-in is hidden by an alias, function, or cmdlet with the same name, you can run it by using the snap-in-qualified name of the cmdlet:</source>
          <target state="translated">Ad esempio, se il cmdlet Get-Date dallo snap-in Microsoft.PowerShell.Utility è nascosto da un alias, una funzione o un cmdlet con lo stesso nome, è possibile eseguirla utilizzando il nome del cmdlet snap-in-completo:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Microsoft.PowerShell.Utility\Get-Date</source>
          <target state="translated">Microsoft.PowerShell.Utility\Get-Date</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To run a New-Map command that was added by the MapFunctions module, use its module-qualified name:</source>
          <target state="translated">Per eseguire un comando New-mappa che è stato aggiunto dal modulo MapFunctions, utilizzare il nome qualificato del modulo:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>MapFunctions\New-Map</source>
          <target state="translated">MapFunctions\New-mappa</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To find the snap-in or module from which a command was imported, use the ModuleName property of commands.</source>
          <target state="translated">Per trovare gli snap-in o un modulo da cui è stato importato un comando, utilizzare la proprietà ModuleName dei comandi.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>(Get-Command &lt;command-name&gt;).ModuleName</source>
          <target state="translated">(Get-Command &lt; nome &gt;). ModuleName</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, to find the source of the Get-Date cmdlet, type:</source>
          <target state="translated">Ad esempio, per trovare l'origine del cmdlet Get-Date, digitare:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-Command Get-Date).ModuleName Microsoft.PowerShell.Utility</source>
          <target state="translated">PS C: &gt; (Get-Command Get-Date). ModuleName Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CALL OPERATOR</source>
          <target state="translated">OPERATORE DI CHIAMATA</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can also use the Call operator (&amp;) to run any command that you can get by using a Get-ChildItem (the alias is "dir"), Get-Command, or Get-Module command.</source>
          <target state="translated">È inoltre possibile utilizzare l'operatore di chiamata (&amp;) per eseguire qualsiasi comando che è possibile ottenere utilizzando un Get-ChildItem (alias è "dir"), Get-Command o Get-Module comando.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To run a command, enclose the Get-Command command in parentheses, and use the Call operator (&amp;) to run the command.</source>
          <target state="translated">Per eseguire un comando, racchiudere il comando Get-Command tra parentesi e utilizzare l'operatore di chiamata (&amp;) per eseguire il comando.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command ...)</source>
          <target state="translated">&amp; (get-Command...)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">o -</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&amp;(dir ... )</source>
          <target state="translated">&amp;(Dir...)</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, if you have a function named Map that is hidden by an alias named Map, use the following command to run the function.</source>
          <target state="translated">Ad esempio, se si dispone di una funzione denominata mappa che è nascosto da una alias denominata mappa, utilizzare il comando seguente per eseguire la funzione.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command -Name Map -Type function)</source>
          <target state="translated">&amp; (get-Command - nome mappa-funzione di tipo)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">o -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>&amp;(dir function:\map)</source>
          <target state="translated">&amp; (funzione dir: \map)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also save your hidden command in a variable to make it easier to run.</source>
          <target state="translated">È inoltre possibile salvare il comando nascosto in una variabile che rendono più semplice eseguire.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, the following command saves the Map function in the $myMap variable and then uses the Call operator to run it.</source>
          <target state="translated">Ad esempio, il comando seguente consente di salvare la funzione mappa nella variabile $myMap e quindi utilizza l'operatore di chiamata per l'esecuzione.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>$myMap = (Get-Command -Name map -Type function)</source>
          <target state="translated">$myMap = (get-Command - nome mapping - della funzione di tipo)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&amp;($myMap)</source>
          <target state="translated">&amp;($myMap)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If a command originated in a module, you can use the following format to run it.</source>
          <target state="translated">Se un comando ha avuto origine in un modulo, è possibile utilizzare il seguente formato per l'esecuzione.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>&amp; &lt;PSModuleInfo-object&gt;</source>
          <target state="translated">&amp; &lt; oggetto PSModuleInfo &gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, to run the Add-File cmdlet in the FileCommands module, use the following command sequence.</source>
          <target state="translated">Ad esempio, per eseguire il cmdlet Add-File nel modulo FileCommands, utilizzare la seguente sequenza di comandi.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>$FileCommands = get-module -name FileCommands</source>
          <target state="translated">$FileCommands = get-module-nome FileCommands</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>&amp; $FileCommands Add-File</source>
          <target state="translated">&amp; Aggiungi $FileCommands-File</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>REPLACED ITEMS</source>
          <target state="translated">ELEMENTI SOSTITUITI</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Items that have not been imported from a module or snap-in, such as functions, variables, and aliases that you create in your session or that you add by using a profile can be replaced by commands that have the same name.</source>
          <target state="translated">Gli elementi che non sono stati importati da un modulo o snap-in, ad esempio funzioni, variabili e gli alias creati nella sessione corrente o che si aggiunge un profilo con possono essere sostituiti da comandi che hanno lo stesso nome.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they are replaced, you cannot access them.</source>
          <target state="translated">Se vengono sostituiti, è possibile accedervi.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Variables and aliases are always replaced even if they have been imported from a module or snap-in because you cannot use a call operator or a qualified name to run them.</source>
          <target state="translated">Variabili e gli alias vengono sempre sostituiti anche se sono stati importati da un modulo o snap-in perché è possibile utilizzare un operatore di chiamata o un nome completo di eseguirli.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, if you type a Get-Map function in your session, and you import a function called Get-Map, the original function is replaced.</source>
          <target state="translated">Ad esempio, se si digita una funzione Get-mappa nella sessione corrente e si importa una funzione chiamata Get-mappa, la funzione originale viene sostituita.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You cannot retrieve it in the current session.</source>
          <target state="translated">Non possono essere recuperati nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>AVOIDING NAME CONFLICTS</source>
          <target state="translated">COME EVITARE CONFLITTI DI NOME</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The best way to manage command name conflicts is to prevent them.</source>
          <target state="translated">Il modo migliore per gestire i conflitti di nome di comando è impedire loro.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When you name your commands, use a name that is very specific or is likely to be unique.</source>
          <target state="translated">Quando si assegna un nome ai comandi, utilizzare un nome che è molto specifico o è probabile che sia univoco.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, add your initials or company name acronym to the nouns in your commands.</source>
          <target state="translated">Ad esempio, aggiungere le iniziali o l'acronimo di nome società ai sostantivi nei propri comandi.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Also, when you import commands into your session from a Windows PowerShell module or from another session, use the Prefix parameter of the Import-Module or Import-PSSession cmdlet to add a prefix to the nouns in the names of commands.</source>
          <target state="translated">Inoltre, quando si importano i comandi nella sessione da un modulo di Windows PowerShell o da un'altra sessione, utilizzare il parametro Prefix del cmdlet Import-Module o Import-PSSession per aggiungere un prefisso ai sostantivi nei nomi dei comandi.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, the following command avoids any conflict with the Get-Date and Set-Date cmdlets that come with Windows PowerShell when you import the DateFunctions module.</source>
          <target state="translated">Ad esempio, il comando seguente consente di evitare eventuali conflitti con il cmdlet Get-Date e Set-Date forniti con Windows PowerShell quando si importa il modulo DateFunctions.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Import-Module -Name DateFunctions -Prefix ZZ</source>
          <target state="translated">Import-Module-nome DateFunctions-prefisso ZZ</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For more information, see Import-Module and Import-PSSession.</source>
          <target state="translated">Per ulteriori informazioni, vedere Import-Module e Import-PSSession.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEDERE ANCHE</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>about_Path_Syntax about_Aliases about_Functions Alias (provider) Function (provider) Get-Command Import-Module Import-PSSession</source>
          <target state="translated">about_Path_Syntax about_Aliases about_Functions Alias (provider) funzione Get-Command Import-Module Import-PSSession (provider)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>