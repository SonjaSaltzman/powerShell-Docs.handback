<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">662d0823749c142a716b74164ad57a8612833ccd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Creating-.NET-and-COM-Objects--New-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64ed6d81b8d08d54732475e98cbc84a33f2c1f30</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e240727a80f311fbf68e10232c53b579ce86d0c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects  New Object</source>
          <target state="translated">.NET オブジェクトと COM オブジェクトの作成 (New-Object)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">PowerShell, コマンドレット</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects (New-Object)</source>
          <target state="translated">.NET オブジェクトと COM オブジェクトを作成する (New-Object)</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.</source>
          <target state="translated">ソフトウェア コンポーネントの中には、さまざまなシステム管理タスクを実行できるようにする .NET Framework や COM インターフェイスを備えているものがあります。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.</source>
          <target state="translated">これらのコンポーネントは Windows PowerShell から使用することもでき、コマンドレットだけではできないタスクも実行できます。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.</source>
          <target state="translated">Windows PowerShell の初回リリースでは、コマンドレットの多くがリモート コンピューターに対応していません。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> class directly from Windows PowerShell.</source>
          <target state="translated">ここでは、イベント ログを管理する場合に、.NET Framework の <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> クラスを Windows PowerShell から直接使用して、この制限を回避する方法を紹介します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Using New-Object for Event Log Access</source>
          <target state="translated">New-Object によるイベント ログへのアクセス</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library includes a class named <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> that can be used to manage event logs.</source>
          <target state="translated">.NET Framework のクラス ライブラリには、イベント ログの管理に使用する <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> というクラスが含まれています。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can create a new instance of a .NET Framework class by using the <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> parameter.</source>
          <target state="translated">.NET Framework クラスの新しいインスタンスを作成するには、<bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> コマンドレットと <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> パラメーターを使用します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, the following command creates an event log reference:</source>
          <target state="translated">たとえば、次のコマンドを実行すると、イベント ログの参照が作成されます。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Although the command has created an instance of the EventLog class, the instance does not include any data.</source>
          <target state="translated">このコマンドによって EventLog クラスのインスタンスは作成されましたが、このインスタンスにはデータがまったく含まれていません。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>That is because we did not specify a particular event log.</source>
          <target state="translated">これは、特定のイベント ログを指定しなかったためです。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How do you get a real event log?</source>
          <target state="translated">実際のイベント ログを取得するにはどうすればよいのでしょうか。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Using Constructors with New-Object</source>
          <target state="translated">New-Object でのコンストラクターの使用</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To refer to a specific event log, you need to specify the name of the log.</source>
          <target state="translated">特定のイベント ログを参照するには、ログの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has an <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> parameter.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> には、<bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> というパラメーターがあります。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The arguments you pass as values to this parameter are used by a special startup method of the object.</source>
          <target state="translated">このパラメーターの値として渡した引数は、オブジェクトの特殊な初期化メソッドで使用されます。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The method is called a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> because it is used to construct the object.</source>
          <target state="translated">オブジェクトを構築 (construct) する目的で使用されることから、このメソッドは<bpt id="p1">*</bpt>コンストラクター<ept id="p1">*</ept>と呼ばれています。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, to get a reference to the Application log, you specify the string 'Application' as an argument:</source>
          <target state="translated">たとえば、Application ログの参照を取得するには、"Application" という文字列を引数として指定します。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.</source>
          <target state="translated">.NET Framework の中核となるクラスの大半は System 名前空間に存在するため、指定された型名が見つからなかった場合、Windows PowerShell は、そのクラスを自動的に System 名前空間から検索しようと試みます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.</source>
          <target state="translated">したがって、「System.Diagnostics.EventLog」の部分は「Diagnostics.EventLog」と指定することもできます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Storing Objects in Variables</source>
          <target state="translated">オブジェクトの変数への保存</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You might want to store a reference to an object, so you can use it in the current shell.</source>
          <target state="translated">オブジェクトの参照を保存し、それを現在のシェルで使用できます。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.</source>
          <target state="translated">Windows PowerShell では多くの作業をパイプラインを使って実行できるため、変数を使用する機会はあまり多くありません。しかし、場合によっては、オブジェクトの参照を変数に格納した方が、オブジェクトを効率よく操作できることがあります。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables that are essentially named objects.</source>
          <target state="translated">Windows PowerShell では、変数 (つまり、オブジェクトに名前を付けたもの) を作成できます。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The output from any valid Windows PowerShell command can be stored in a variable.</source>
          <target state="translated">正しい Windows PowerShell コマンドであれば、その出力を変数に格納できます。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Variable names always begin with $.</source>
          <target state="translated">変数名の先頭には、常に $ が付きます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:</source>
          <target state="translated">Application ログの参照を変数 $AppLog に格納するには、この変数名の後に等号を入力し、続けて、Application ログ オブジェクトの作成に使用するコマンドを入力します。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you then type $AppLog, you can see that it contains the Application log:</source>
          <target state="translated">その後、「$AppLog」と入力すると、Application ログが格納されていることを確認できます。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Accessing a Remote Event Log with New-Object</source>
          <target state="translated">New-Object によるリモートのイベント ログへのアクセス</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The commands used in the preceding section target the local computer; the <bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> cmdlet can do that.</source>
          <target state="translated">前のセクションで使用したコマンドは、アクセス先としてローカル コンピューターを想定していました。ローカル コンピューターのイベント ログを取得するのであれば、<bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> コマンドレットを使って行うこともできます。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.</source>
          <target state="translated">リモート コンピューターの Application ログにアクセスするには、引数として、ログの名前とコンピューター名 (または IP アドレス) の両方を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?</source>
          <target state="translated">これで、イベント ログの参照が $RemoteAppLog 変数に格納されました。以降、この変数を使って、具体的にどのようなタスクを実行できるのかを説明します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Clearing an Event Log with Object Methods</source>
          <target state="translated">オブジェクトのメソッドを使用したイベント ログのクリア</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Objects often have methods that can be called to perform tasks.</source>
          <target state="translated">多くの場合、オブジェクトには、特定のタスクを実行するときに呼び出すことのできるメソッドが存在します。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> to display the methods associated with an object.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> を使用すると、オブジェクトに関連付けられているメソッドを表示できます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following command and selected output show some the methods of the EventLog class:</source>
          <target state="translated">次の例は、EventLog クラスのメソッドを表示するコマンドと、その出力の抜粋です。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> method can be used to clear the event log.</source>
          <target state="translated">イベント ログをクリアするには、<bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> メソッドを使用します。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.</source>
          <target state="translated">メソッドを呼び出すときは、引数が不要な場合でも、メソッド名の後に丸かっこを必ず入力する必要があります。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This lets Windows PowerShell distinguish between the method and a potential property with the same name.</source>
          <target state="translated">Windows PowerShell は、丸かっこの有無により、それがメソッド名なのか、同名のプロパティ名なのかを判断します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Type the following to call the <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> method:</source>
          <target state="translated"><bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> メソッドを呼び出すには、次のように入力します。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Type the following to display the log.</source>
          <target state="translated">ログを表示するには、次のように入力します。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You will see that the event log was cleared, and now has 0 entries instead of 262:</source>
          <target state="translated">イベント ログがクリアされ、エントリ数が 262 から 0 に変わっていることが確認できます。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Creating COM Objects with New-Object</source>
          <target state="translated">New-Object による COM オブジェクトの作成</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> to work with Component Object Model (COM) components.</source>
          <target state="translated">コンポーネント オブジェクト モデル (COM) のコンポーネントを操作するには、<bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> を使用します。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.</source>
          <target state="translated">一口にコンポーネントと言っても、その種類は Windows Script Host (WSH) に含まれている各種ライブラリから、Internet Explorer のようなほとんどのシステムにインストールされている ActiveX アプリケーションまで多岐にわたります。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> では、.NET Framework ランタイム呼び出し可能ラッパーを使って COM オブジェクトを作成します。したがって、COM オブジェクトを呼び出す際には .NET Framework の場合と同じ制限が適用されます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To create a COM object, you need to specify the <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> parameter with the Programmatic Identifier or <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> of the COM class you want to use.</source>
          <target state="translated">COM オブジェクトを作成するには、使用する COM クラスのプログラム識別子 (<bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept>) を <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> パラメーターで指定する必要があります。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well-known objects from environments such as WSH can be used within Windows PowerShell.</source>
          <target state="translated">COM の使用上の制限や、システム上で利用できる ProgId の調査方法については、このマニュアルの範囲を超えているので詳しく説明しません。しかし、WSH などの環境に存在する、一般によく知られているようなオブジェクトについては、Windows PowerShell 内で使用できます。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can create the WSH objects by specifying these progids: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</source>
          <target state="translated">WSH オブジェクトは、<bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>、<bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>、<bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>、<bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept> などを ProgId として指定すれば作成できます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following commands create these objects:</source>
          <target state="translated">これらのオブジェクトを作成するコマンドの例を次に示します。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.</source>
          <target state="translated">これらのクラスの機能は、その多くが、Windows PowerShell から他の方法を使ってアクセスすることもできます。ただし、ショートカットの作成など、一部のタスクについては、WSH のクラスを使用した方が簡単です。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Creating a Desktop Shortcut with WScript.Shell</source>
          <target state="translated">WScript.Shell によるデスクトップ ショートカットの作成</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>One task that can be performed quickly with a COM object is creating a shortcut.</source>
          <target state="translated">COM オブジェクトの使用が適しているタスクの 1 つに、ショートカットの作成があります。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.</source>
          <target state="translated">Windows PowerShell のホーム フォルダーに対するショートカットをデスクトップ上に作成するとします。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You first need to create a reference to <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, which we will store in a variable named <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</source>
          <target state="translated">まず必要なことは、<bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept> の参照を作成することです。ここでは、この参照を <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept> という変数に格納することにします。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Get-Member works with COM objects, so you can explore the members of the object by typing:</source>
          <target state="translated">Get-Member は COM オブジェクトに対応しているため、次のように入力することで、オブジェクトのメンバーを調査できます。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> has an optional <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> parameter you can use instead of piping to provide input to <bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> には、省略可能なパラメーター <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> があります。<bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept> に対する入力をパイプで渡す代わりに、このパラメーターを使用することもできます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You would get the same output as shown above if you instead used the command <bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept> コマンドを使用しても表示される出力結果は同じです。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, it treats its argument as a single item.</source>
          <target state="translated"><bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept> を使用した場合、その引数は単一の項目として扱われます。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This means that if you have several objects in a variable, <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> treats them as an array of objects.</source>
          <target state="translated">つまり、1 つの変数に複数のオブジェクトが格納されている場合、<bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> では、それらはオブジェクトの配列として扱われます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">たとえば、次のように入力します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> method accepts a single argument, the path to the shortcut file to create.</source>
          <target state="translated"><bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> メソッドは、作成するショートカット ファイルのパスのみを引数として受け取ります。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>We could type in the full path to the desktop, but there is an easier way.</source>
          <target state="translated">デスクトップへのフル パスを入力することもできますが、より簡単な方法があります。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The desktop is normally represented by a folder named Desktop inside the home folder of the current user.</source>
          <target state="translated">通常、デスクトップは、現在のユーザーのホーム フォルダーにある "デスクトップ" というフォルダー名で表されます。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has a variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> that contains the path to this folder.</source>
          <target state="translated">Windows PowerShell には、このフォルダーへのパスを保持する <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> という変数が用意されています。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:</source>
          <target state="translated">この変数を使ってホーム フォルダーのパスを指定し、続けて、デスクトップ フォルダーの名前と、作成するショートカットの名前を追加します。次にその例を示します。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When you use something that looks like a variable name inside double-quotes, Windows PowerShell tries to substitute a matching value.</source>
          <target state="translated">変数名と思われる情報が二重引用符内に存在した場合、Windows PowerShell は、それを対応する値に置き換えようと試みます。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you use single-quotes, Windows PowerShell does not try to substitute the variable value.</source>
          <target state="translated">一重引用符を使用した場合、変数値の置き換えは行われません。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, try typing the following commands:</source>
          <target state="translated">たとえば、次のコマンドを入力してみてください。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>We now have a variable named <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> that contains a new shortcut reference.</source>
          <target state="translated"><bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> という変数には、現在、新しいショートカットの参照が格納されています。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you want to see its members, you can pipe it to <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept>.</source>
          <target state="translated">メンバーを表示するには、この変数をパイプを使って <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> に渡します。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The output below shows the members we need to use to finish creating our shortcut:</source>
          <target state="translated">次のように、ショートカットを完成するために必要なメンバーが出力結果として表示されます。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>We need to specify the <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> by calling the <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> method.</source>
          <target state="translated"><bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept> (Windows PowerShell のアプリケーション フォルダー) を指定した後、<bpt id="p3">**</bpt>Save<ept id="p3">**</ept> メソッドを呼び出してショートカット <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> を保存する必要があります。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell application folder path is stored in the variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, so we can do this by typing:</source>
          <target state="translated">Windows PowerShell のアプリケーション フォルダーのパスは変数 <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept> に保存されているため、次のように入力します。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Using Internet Explorer from Windows PowerShell</source>
          <target state="translated">Windows PowerShell からの Internet Explorer の使用</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.</source>
          <target state="translated">Microsoft Office ファミリのアプリケーションや Internet Explorer など、多くのアプリケーションは COM を使用して自動化できます。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Internet Explorer illustrates some of the typical techniques and issues involved in working with COM-based applications.</source>
          <target state="translated">COM ベースのアプリケーション操作に関係する一般的なテクニックと問題点を、Internet Explorer を例に取り上げます。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</source>
          <target state="translated">Internet Explorer のインスタンスを作成するには、次のように、Internet Explorer の ProgId として <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept> を指定します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This command starts Internet Explorer, but does not make it visible.</source>
          <target state="translated">このコマンドでは、Internet Explorer は起動しますが、表示はされません。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you type Get-Process, you can see that a process named iexplore is running.</source>
          <target state="translated">「Get-Process」と入力すると、iexplore という名前のプロセスが実行されていることがわかります。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In fact, if you exit Windows PowerShell, the process will continue to run.</source>
          <target state="translated">実際、Windows PowerShell を終了しても、このプロセスは実行されたままです。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You must reboot the computer or use a tool like Task Manager to end the iexplore process.</source>
          <target state="translated">iexplore プロセスを終了するには、コンピューターを再起動するか、またはタスク マネージャーなどのツールを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>COM objects that start as separate processes, commonly called <bpt id="p1">*</bpt>ActiveX executables<ept id="p1">*</ept>, may or may not display a user interface window when they start up.</source>
          <target state="translated">独立したプロセスとして起動する COM オブジェクトは、一般に <bpt id="p1">*</bpt>ActiveX 実行可能ファイル<ept id="p1">*</ept>と呼ばれ、起動時にユーザー インターフェイス ウィンドウを表示するものと、表示しないものが存在します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.</source>
          <target state="translated">Internet Explorer のように、ウィンドウは作成されても、表示状態にはしない COM オブジェクトの場合、フォーカスが Windows デスクトップに移されることが多く、ユーザーが操作できるようにするためには、ウィンドウを表示状態にする必要があります。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>By typing <bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept>, you can view properties and methods for Internet Explorer.</source>
          <target state="translated"><bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept> と入力すると、Internet Explorer のプロパティおよびメソッドを表示できます。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>To see the Internet Explorer window, set the Visible property to $true by typing:</source>
          <target state="translated">Internet Explorer ウィンドウを表示するには、次のように、Visible プロパティを $true に設定します。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You can then navigate to a specific Web address by using the Navigate method:</source>
          <target state="translated">次に、Navigate メソッドを使用すると、特定の Web アドレスに移動できます。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.</source>
          <target state="translated">Internet Explorer オブジェクト モデルの他のメンバーを使用すると、この Web ページからテキストの内容を取得できます。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The following command will display the HTML text in the body of the current Web page:</source>
          <target state="translated">次のコマンドを実行すると、現在の Web ページの本文に含まれる HTML テキストが表示されます。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To close Internet Explorer from within PowerShell, call its Quit() method:</source>
          <target state="translated">Internet Explorer を PowerShell 内から終了するには、Quit() メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This will force it to close.</source>
          <target state="translated">この場合、アプリケーションは強制的に終了されます。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The $ie variable no longer contains a valid reference even though it still appears to be a COM object.</source>
          <target state="translated">一見すると、まだ COM オブジェクトが有効であるかのように見えますが、この時点で、$ie 変数には正しい参照が存在しません。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If you attempt to use it, you will get an automation error:</source>
          <target state="translated">使用を試みると、オートメーション エラーが発生します。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can either remove the remaining reference with a command like $ie = $null, or completely remove the variable by typing:</source>
          <target state="translated">コマンド "$ie = $null" などのような形で残っている参照を削除することも、次のように入力して変数を完全に削除することもできます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.</source>
          <target state="translated">参照を削除したときに、ActiveX 実行可能ファイルを終了するか、実行を継続するかに関して、共通の標準は存在しません。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.</source>
          <target state="translated">アプリケーションが終了するかどうかは、アプリケーションが可視状態であるか、編集中のドキュメントが存在するか、Windows PowerShell がまだ実行されているかなど、さまざまな条件に依存します。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.</source>
          <target state="translated">そのため、Windows PowerShell で使用する ActiveX 実行可能ファイルごとに、終了時の動作をテストしておく必要があります。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Getting Warnings About .NET Framework-Wrapped COM Objects</source>
          <target state="translated">.NET Framework によってラップされた COM オブジェクトの警告の取得</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In some cases, a COM object might have an associated .NET Framework <bpt id="p1">*</bpt>Runtime-Callable Wrapper<ept id="p1">*</ept> or RCW, and this will be used by <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept>.</source>
          <target state="translated">COM オブジェクトに、.NET Framework <bpt id="p1">*</bpt>ランタイム呼び出し可能ラッパー<ept id="p1">*</ept> (RCW) が関連付けられていて、これが <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept> で使用されることがあります。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has a <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> parameter to warn you about RCW access.</source>
          <target state="translated">RCW の動作は通常の COM オブジェクトの動作とは異なる場合があるため、<bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> には、RCW アクセスに関する警告を取得する <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> パラメーターが用意されています。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:</source>
          <target state="translated"><bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> パラメーターを指定し、RCW を使用する COM オブジェクトを作成した場合、次のような警告メッセージが表示されます。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although the object is still created, you are warned that it is not a standard COM object.</source>
          <target state="translated">オブジェクトは作成されますが、標準の COM オブジェクトではないことを示す警告が表示されます。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>