<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-eac019f" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">662d0823749c142a716b74164ad57a8612833ccd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Creating-.NET-and-COM-Objects--New-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">64ed6d81b8d08d54732475e98cbc84a33f2c1f30</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7e240727a80f311fbf68e10232c53b579ce86d0c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects  New Object</source>
          <target state="translated">Criando objetos .NET e COM New Object</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">PowerShell, cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Creating .NET and COM Objects (New-Object)</source>
          <target state="translated">Criando objetos .NET e COM (New-Object)</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>There are software components with .NET Framework and COM interfaces that enable you to perform many system administration tasks.</source>
          <target state="translated">Existem componentes de software com as interfaces .NET Framework e COM que permitem executar muitas tarefas de administração do sistema.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you use these components, so you are not limited to the tasks that can be performed by using cmdlets.</source>
          <target state="translated">O Windows PowerShell permite usar esses componentes para que você não fique limitado a tarefas que podem ser executadas usando cmdlets.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Many of the cmdlets in the initial release of Windows PowerShell do not work against remote computers.</source>
          <target state="translated">Muitos dos cmdlets na versão inicial do Windows PowerShell não funcionam em computadores remotos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>We will demonstrate how to get around this limitation when managing event logs by using the .NET Framework <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> class directly from Windows PowerShell.</source>
          <target state="translated">Demonstraremos como contornar essa limitação gerenciando logs de eventos usando a classe <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> do .NET Framework diretamente do Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Using New-Object for Event Log Access</source>
          <target state="translated">Usando New-Object para acesso ao Log de Eventos</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The .NET Framework Class Library includes a class named <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> that can be used to manage event logs.</source>
          <target state="translated">A Biblioteca de Classes do .NET Framework inclui uma classe chamada <bpt id="p1">**</bpt>System.Diagnostics.EventLog<ept id="p1">**</ept> que pode ser usada para gerenciar logs de eventos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can create a new instance of a .NET Framework class by using the <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept> parameter.</source>
          <target state="translated">Você pode criar uma nova instância de uma classe do .NET Framework usando o cmdlet <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> com o parâmetro <bpt id="p2">**</bpt>TypeName<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, the following command creates an event log reference:</source>
          <target state="translated">Por exemplo, o comando a seguir cria uma referência de log de eventos:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Although the command has created an instance of the EventLog class, the instance does not include any data.</source>
          <target state="translated">Embora o comando tenha criado uma instância da classe EventLog, ela não inclui nenhum dado.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>That is because we did not specify a particular event log.</source>
          <target state="translated">Isso ocorre porque não especificamos um log de eventos específico.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>How do you get a real event log?</source>
          <target state="translated">Como obter um log de eventos real?</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Using Constructors with New-Object</source>
          <target state="translated">Usando construtores com New-Object</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To refer to a specific event log, you need to specify the name of the log.</source>
          <target state="translated">Para consultar um log de eventos específico, é necessário especificar o nome do log.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has an <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept> parameter.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> tem um parâmetro <bpt id="p2">**</bpt>ArgumentList<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The arguments you pass as values to this parameter are used by a special startup method of the object.</source>
          <target state="translated">Os argumentos que você passa como valores para esse parâmetro são usados por um método especial de inicialização do objeto.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The method is called a <bpt id="p1">*</bpt>constructor<ept id="p1">*</ept> because it is used to construct the object.</source>
          <target state="translated">O método é chamado de <bpt id="p1">*</bpt>construtor<ept id="p1">*</ept> porque ele é usado para construir o objeto.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, to get a reference to the Application log, you specify the string 'Application' as an argument:</source>
          <target state="translated">Por exemplo, para obter uma referência para o Log do aplicativo, especifique a cadeia de caracteres “Application” (Aplicativo) como um argumento:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Since most of the .NET Framework core classes are contained in the System namespace, Windows PowerShell will automatically attempt to find classes you specify in the System namespace if it cannot find a match for the typename you specify.</source>
          <target state="translated">Uma vez que a maioria das classes principais do .NET Framework está contida no namespace System, o Windows PowerShell tentará localizar automaticamente as classes que você especificar no namespace System se ele não encontrar uma correspondência para o typename especificado.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means that you can specify Diagnostics.EventLog instead of System.Diagnostics.EventLog.</source>
          <target state="translated">Isso significa que você pode especificar Diagnostics.EventLog em vez de System.Diagnostics.EventLog.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Storing Objects in Variables</source>
          <target state="translated">Armazenar objetos em variáveis</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You might want to store a reference to an object, so you can use it in the current shell.</source>
          <target state="translated">Pode ser útil armazenar uma referência a um objeto para que você pode usá-lo no shell atual.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell lets you do a lot of work with pipelines, lessening the need for variables, sometimes storing references to objects in variables makes it more convenient to manipulate those objects.</source>
          <target state="translated">Embora o Windows PowerShell permita fazer grande parte do trabalho com pipelines, reduzindo a necessidade de variáveis, às vezes armazenar as referências a objetos em variáveis torna mais conveniente a tarefa de manipular esses objetos.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables that are essentially named objects.</source>
          <target state="translated">O Windows PowerShell permite criar variáveis que são basicamente objetos nomeados.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The output from any valid Windows PowerShell command can be stored in a variable.</source>
          <target state="translated">A saída de qualquer comando válido do Windows PowerShell pode ser armazenada em uma variável.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Variable names always begin with $.</source>
          <target state="translated">Nomes de variáveis sempre começam com $.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you want to store the Application log reference in a variable named $AppLog, type the name of the variable, followed by an equal sign and then type the command used to create the Application log object:</source>
          <target state="translated">Se você deseja armazenar a referência de log do aplicativo em uma variável chamada $AppLog, digite o nome da variável, seguido por um sinal de igual e, em seguida, digite o comando usado para criar o objeto do log do aplicativo:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you then type $AppLog, you can see that it contains the Application log:</source>
          <target state="translated">Se você digitar $AppLog, poderá ver que ele contém o log do aplicativo:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Accessing a Remote Event Log with New-Object</source>
          <target state="translated">Acessando um Log de Eventos Remoto com New-Object</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The commands used in the preceding section target the local computer; the <bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> cmdlet can do that.</source>
          <target state="translated">Os comandos usados na seção anterior destinam-se ao computador local. O cmdlet <bpt id="p1">**</bpt>Get-EventLog<ept id="p1">**</ept> pode fazer isso.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To access the Application log on a remote computer, you must supply both the log name and a computer name (or IP address) as arguments.</source>
          <target state="translated">Para acessar o log do aplicativo em um computador remoto, você deve fornecer tanto o nome do log quanto um nome do computador (ou endereço IP) como argumentos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Now that we have a reference to an event log stored in the $RemoteAppLog variable, what tasks can we perform on it?</source>
          <target state="translated">Agora que temos uma referência a um log de eventos armazenado na variável $RemoteAppLog, quais tarefas que podemos realizar nela?</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Clearing an Event Log with Object Methods</source>
          <target state="translated">Limpar um Log de Eventos com métodos de objeto</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Objects often have methods that can be called to perform tasks.</source>
          <target state="translated">Objetos geralmente têm métodos que podem ser chamados para executar tarefas.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> to display the methods associated with an object.</source>
          <target state="translated">Você pode usar <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> para exibir os métodos associados a um objeto.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following command and selected output show some the methods of the EventLog class:</source>
          <target state="translated">O seguinte comando e a saída selecionada mostram alguns métodos da classe EventLog:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> method can be used to clear the event log.</source>
          <target state="translated">O método <bpt id="p1">**</bpt>Clear()<ept id="p1">**</ept> pode ser usado para limpar o log de eventos.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When calling a method, you must always follow the method name by parentheses, even if the method does not require arguments.</source>
          <target state="translated">Ao chamar um método, você sempre deverá acrescentar parênteses ao fim do nome do método, mesmo se ele não exigir argumentos.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This lets Windows PowerShell distinguish between the method and a potential property with the same name.</source>
          <target state="translated">Isso permite que o Windows PowerShell faça distinção entre o método e uma propriedade em potencial com o mesmo nome.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Type the following to call the <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept> method:</source>
          <target state="translated">Digite o seguinte para chamar o método <bpt id="p1">**</bpt>Clear<ept id="p1">**</ept>:</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Type the following to display the log.</source>
          <target state="translated">Digite o seguinte para exibir o log.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You will see that the event log was cleared, and now has 0 entries instead of 262:</source>
          <target state="translated">Você verá que o log de eventos foi limpo e agora tem 0 entradas em vez de 262:</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Creating COM Objects with New-Object</source>
          <target state="translated">Criação de objetos COM usando New-Object</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> to work with Component Object Model (COM) components.</source>
          <target state="translated">Você pode usar <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> para trabalhar com componentes COM (Component Object Model).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Components range from the various libraries included with Windows Script Host (WSH) to ActiveX applications such as Internet Explorer that are installed on most systems.</source>
          <target state="translated">Os componentes variam desde as várias bibliotecas incluídas no WSH (Windows Script Host) até aplicativos de ActiveX como o Internet Explorer que estão instalados na maioria dos sistemas.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> uses .NET Framework Runtime-Callable Wrappers to create COM objects, so it has the same limitations that .NET Framework does when calling COM objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> usa Runtime Callable Wrappers do .NET Framework para criar objetos COM, portanto, ele tem as mesmas limitações que o .NET Framework ao chamar objetos COM.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To create a COM object, you need to specify the <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> parameter with the Programmatic Identifier or <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> of the COM class you want to use.</source>
          <target state="translated">Para criar um objeto COM, você precisa especificar o parâmetro <bpt id="p1">**</bpt>ComObject<ept id="p1">**</ept> com o identificador programático ou <bpt id="p2">*</bpt>ProgId<ept id="p2">*</ept> da classe COM que você deseja usar.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>A complete discussion of the limitations of COM use and determining what ProgIds are available on a system is beyond the scope of this user's guide, but most well-known objects from environments such as WSH can be used within Windows PowerShell.</source>
          <target state="translated">Uma discussão completa sobre as limitações de uso de COM e como determinar quais ProgIds estão disponíveis em um sistema está além do escopo deste guia do usuário, mas a maioria dos objetos bem conhecidos de ambientes como WSH podem ser usados no Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can create the WSH objects by specifying these progids: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</source>
          <target state="translated">Você pode criar objetos WSH especificando essas ProgIDs: <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, <bpt id="p2">**</bpt>WScript.Network<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Scripting.Dictionary<ept id="p3">**</ept> e <bpt id="p4">**</bpt>Scripting.FileSystemObject<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following commands create these objects:</source>
          <target state="translated">Os comandos a seguir criam esses objetos:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Although most of the functionality of these classes is made available in other ways in Windows PowerShell, a few tasks such as shortcut creation are still easier to do using the WSH classes.</source>
          <target state="translated">Embora a maioria das funcionalidades dessas classes seja disponibilizada de outras maneiras no Windows PowerShell, algumas tarefas, como a criação de atalhos, são ainda mais fáceis de executar usando as classes WSH.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Creating a Desktop Shortcut with WScript.Shell</source>
          <target state="translated">Criar um atalho da área de trabalho com WScript.Shell</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>One task that can be performed quickly with a COM object is creating a shortcut.</source>
          <target state="translated">Uma tarefa que pode ser executada rapidamente um objeto COM é a criação de um atalho.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Suppose you want to create a shortcut on your desktop that links to the home folder for Windows PowerShell.</source>
          <target state="translated">Suponha que você deseja criar um atalho na área de trabalho que a vincula a pasta base ao Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You first need to create a reference to <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, which we will store in a variable named <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</source>
          <target state="translated">Você precisa primeiro criar uma referência a <bpt id="p1">**</bpt>WScript.Shell<ept id="p1">**</ept>, que armazenaremos em uma variável chamada <bpt id="p2">**</bpt>$WshShell<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Get-Member works with COM objects, so you can explore the members of the object by typing:</source>
          <target state="translated">Get-Member trabalha com objetos COM, por isso você pode explorar os membros do objeto digitando:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> has an optional <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> parameter you can use instead of piping to provide input to <bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> tem um parâmetro <bpt id="p2">**</bpt>InputObject<ept id="p2">**</ept> opcional que você pode usar em vez de redirecionar para fornecer entrada para <bpt id="p3">**</bpt>Get-Member<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>You would get the same output as shown above if you instead used the command <bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept>.</source>
          <target state="translated">Você deverá obter a mesma saída mostrada acima se usar o comando <bpt id="p1">**</bpt>Get-Member -InputObject $WshShell<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you use <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, it treats its argument as a single item.</source>
          <target state="translated">Se você usar <bpt id="p1">**</bpt>InputObject<ept id="p1">**</ept>, ele tratará seu argumento como um único item.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This means that if you have several objects in a variable, <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> treats them as an array of objects.</source>
          <target state="translated">Isso significa que, se você tiver vários objetos em uma variável, <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> os tratará como uma matriz de objetos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> method accepts a single argument, the path to the shortcut file to create.</source>
          <target state="translated">O método <bpt id="p1">**</bpt>WScript.Shell CreateShortcut<ept id="p1">**</ept> aceita um único argumento, o caminho para o arquivo de atalho a ser criado.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>We could type in the full path to the desktop, but there is an easier way.</source>
          <target state="translated">Podemos pode digitar o caminho completo para a área de trabalho, mas há uma maneira mais fácil.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The desktop is normally represented by a folder named Desktop inside the home folder of the current user.</source>
          <target state="translated">A área de trabalho normalmente é representada por uma pasta chamada Área de Trabalho dentro da pasta base do usuário atual.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has a variable <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> that contains the path to this folder.</source>
          <target state="translated">O Windows PowerShell tem uma variável <bpt id="p1">**</bpt>$Home<ept id="p1">**</ept> que contém o caminho para esta pasta.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>We can specify the path to the home folder by using this variable, and then add the name of the Desktop folder and the name for the shortcut to create by typing:</source>
          <target state="translated">Podemos especificar o caminho para a pasta base usando essa variável e, em seguida, adicione o nome da pasta da Área de Trabalho e o nome do atalho a ser criado digitando:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When you use something that looks like a variable name inside double-quotes, Windows PowerShell tries to substitute a matching value.</source>
          <target state="translated">Quando você usa algo parecido com um nome de variável entre aspas duplas, o Windows PowerShell tenta substituir por um valor correspondente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you use single-quotes, Windows PowerShell does not try to substitute the variable value.</source>
          <target state="translated">Se você usar aspas simples, o Windows PowerShell não tentará substituir o valor da variável.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, try typing the following commands:</source>
          <target state="translated">Por exemplo, tente digitar os seguintes comandos:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>We now have a variable named <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> that contains a new shortcut reference.</source>
          <target state="translated">Agora temos uma variável chamada <bpt id="p1">**</bpt>$lnk<ept id="p1">**</ept> que contém uma nova referência de atalho.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you want to see its members, you can pipe it to <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept>.</source>
          <target state="translated">Se quiser ver seus membros, você poderá direcioná-lo para <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The output below shows the members we need to use to finish creating our shortcut:</source>
          <target state="translated">A saída abaixo mostra os membros que precisamos usar para terminar de criar o atalho:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>We need to specify the <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, which is the application folder for Windows PowerShell, and then save the shortcut <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> by calling the <bpt id="p3">**</bpt>Save<ept id="p3">**</ept> method.</source>
          <target state="translated">É necessário especificar o <bpt id="p1">**</bpt>TargetPath<ept id="p1">**</ept>, que é a pasta do aplicativo para o Windows PowerShell e salvar o atalho <bpt id="p2">**</bpt>$lnk<ept id="p2">**</ept> chamando o método <bpt id="p3">**</bpt>Save<ept id="p3">**</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell application folder path is stored in the variable <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, so we can do this by typing:</source>
          <target state="translated">O caminho da pasta de aplicativo do Windows PowerShell é armazenado na variável <bpt id="p1">**</bpt>$PSHome<ept id="p1">**</ept>, por isso podemos fazer isso digitando:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Using Internet Explorer from Windows PowerShell</source>
          <target state="translated">Usando o Internet Explorer do Windows PowerShell</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Many applications (including the Microsoft Office family of applications and Internet Explorer) can be automated by using COM.</source>
          <target state="translated">Muitos aplicativos (incluindo a família de aplicativos Microsoft Office e o Internet Explorer) podem ser automatizados usando COM.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Internet Explorer illustrates some of the typical techniques and issues involved in working with COM-based applications.</source>
          <target state="translated">O Internet Explorer ilustra algumas das técnicas e problemas típicos envolvidos ao trabalhar com aplicativos baseados em COM.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You create an Internet Explorer instance by specifying the Internet Explorer ProgId, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</source>
          <target state="translated">Você pode criar uma instância do Internet Explorer especificando a ProgId do Internet Explorer, <bpt id="p1">**</bpt>InternetExplorer.Application<ept id="p1">**</ept>:</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This command starts Internet Explorer, but does not make it visible.</source>
          <target state="translated">Esse comando inicia o Internet Explorer, mas não o torna visível.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you type Get-Process, you can see that a process named iexplore is running.</source>
          <target state="translated">Se digitar Get-Process, você poderá ver que um processo chamado iexplore está em execução.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In fact, if you exit Windows PowerShell, the process will continue to run.</source>
          <target state="translated">Na verdade, se você sair do Windows PowerShell, este processo continuará em execução.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>You must reboot the computer or use a tool like Task Manager to end the iexplore process.</source>
          <target state="translated">Você deve reinicializar o computador ou usar uma ferramenta como o Gerenciador de Tarefas para encerrar o processo iexplore.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>COM objects that start as separate processes, commonly called <bpt id="p1">*</bpt>ActiveX executables<ept id="p1">*</ept>, may or may not display a user interface window when they start up.</source>
          <target state="translated">Objetos COM que iniciam como processos separados, normalmente chamados de <bpt id="p1">*</bpt>executáveis do ActiveX<ept id="p1">*</ept>, podem ou não exibir uma janela de interface do usuário quando são iniciados.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If they create a window but do not make it visible, like Internet Explorer, the focus will generally move to the Windows desktop and you must make the window visible to interact with it.</source>
          <target state="translated">Se eles criarem uma janela, mas não a tornarem visível, como no caso do Internet Explorer, o foco geralmente moverá para a área de trabalho do Windows e você deverá deixar a janela visível para interagir com ela.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>By typing <bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept>, you can view properties and methods for Internet Explorer.</source>
          <target state="translated">Digitando <bpt id="p1">**</bpt>$ie | Get-Member<ept id="p1">**</ept>, você pode exibir as propriedades e os métodos do Internet Explorer.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>To see the Internet Explorer window, set the Visible property to $true by typing:</source>
          <target state="translated">Para ver a janela do Internet Explorer, defina a propriedade Visible para $true digitando:</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>You can then navigate to a specific Web address by using the Navigate method:</source>
          <target state="translated">Em seguida, você pode navegar para um endereço Web específico usando o método Navigate:</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Using other members of the Internet Explorer object model, it is possible to retrieve text content from the Web page.</source>
          <target state="translated">Usando outros membros do modelo de objeto do Internet Explorer, é possível recuperar o conteúdo de texto da página da Web.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The following command will display the HTML text in the body of the current Web page:</source>
          <target state="translated">O comando a seguir exibirá o texto HTML no corpo da página da Web atual:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To close Internet Explorer from within PowerShell, call its Quit() method:</source>
          <target state="translated">Para fechar o Internet Explorer de dentro do PowerShell, chame o método Quit():</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This will force it to close.</source>
          <target state="translated">Isso o forçará a fechar.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The $ie variable no longer contains a valid reference even though it still appears to be a COM object.</source>
          <target state="translated">A variável $ie não contém uma referência válida, mesmo parecendo ser um objeto COM.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If you attempt to use it, you will get an automation error:</source>
          <target state="translated">Se você tentar usá-la, obterá um erro de automação:</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can either remove the remaining reference with a command like $ie = $null, or completely remove the variable by typing:</source>
          <target state="translated">É possível remover a referência restante com um comando como $ie = $null ou remover por completo a variável digitando:</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>There is no common standard for whether ActiveX executables exit or continue to run when you remove a reference to one.</source>
          <target state="translated">não há um padrão comum para se executáveis do ActiveX fecham ou continuam em execução quando você remove uma referência deles.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Depending on circumstances such as whether the application is visible, whether an edited document is running in it, and even whether Windows PowerShell is still running, the application may or may not exit.</source>
          <target state="translated">Dependendo das circunstâncias, tal como se o aplicativo estiver visível, se um documento editado está em execução e até mesmo se o Windows PowerShell ainda está em execução, o aplicativo pode ser encerrado ou não.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>For this reason, you should test termination behavior for each ActiveX executable you want to use in Windows PowerShell.</source>
          <target state="translated">Por esse motivo, você deve testar o comportamento de encerramento para cada executável do ActiveX que você deseja usar no Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Getting Warnings About .NET Framework-Wrapped COM Objects</source>
          <target state="translated">Obtendo avisos sobre objetos COM Wrapped do .NET Framework</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In some cases, a COM object might have an associated .NET Framework <bpt id="p1">*</bpt>Runtime-Callable Wrapper<ept id="p1">*</ept> or RCW, and this will be used by <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept>.</source>
          <target state="translated">Em alguns casos, um objeto COM pode ter um <bpt id="p1">*</bpt>Runtime Callable Wrapper<ept id="p1">*</ept> ou RCW do .NET Framework associado, e este será usado pelo <bpt id="p2">**</bpt>New-Object<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Since the behavior of the RCW may be different from the behavior of the normal COM object, <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> has a <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> parameter to warn you about RCW access.</source>
          <target state="translated">Como o comportamento do RCW pode ser diferente do comportamento do objeto COM normal, <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> tem um parâmetro <bpt id="p2">**</bpt>Strict<ept id="p2">**</ept> para avisar sobre o acesso ao RCW.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>If you specify the <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> parameter and then create a COM object that uses an RCW, you get a warning message:</source>
          <target state="translated">Se você especificar o parâmetro <bpt id="p1">**</bpt>Strict<ept id="p1">**</ept> e criar um objeto COM que usa um RCW, receberá uma mensagem de aviso:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Although the object is still created, you are warned that it is not a standard COM object.</source>
          <target state="translated">Embora o objeto ainda seja criado, você será avisado de que este não é um objeto COM padrão.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>