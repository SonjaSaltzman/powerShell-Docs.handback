<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3477e1c213de5436e48d4a0ac4790675f11a2d5a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Utility\Add-Type.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ffcff4b17d50fd06b8fc92524b33b41f681634a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">19a9847c5552b076d1bbec6a9620b9f687c78dc1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Add-Type</source>
          <target state="translated">添加类型</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Add-Type</source>
          <target state="translated">添加类型</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SYNOPSIS</source>
          <target state="translated">简述</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Adds a Microsoft .NET Framework type (a class) to a Windows PowerShell session.</source>
          <target state="translated">将 Microsoft .NET Framework 类型（一个类）添加到 Windows PowerShell 会话中。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>FromSource (Default)</source>
          <target state="translated">FromSource （默认值）</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>FromMember</source>
          <target state="translated">FromMember</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>FromPath</source>
          <target state="translated">FromPath</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>FromLiteralPath</source>
          <target state="translated">FromLiteralPath</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>FromAssemblyName</source>
          <target state="translated">FromAssemblyName</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">说明</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet lets you define a .NET Framework class in your Windows PowerShell session.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet，您可以在 Windows PowerShell 会话中定义的.NET Framework 类。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can then instantiate objects (by using the New-Object cmdlet) and use the objects, just as you would use any .NET Framework object.</source>
          <target state="translated">然后，可以 （通过使用 New-object cmdlet） 实例化对象，并使用这些对象，就像使用任何.NET Framework 对象。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you add an <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> command to your Windows PowerShell profile, the class is available in all Windows PowerShell sessions.</source>
          <target state="translated">如果您添加 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 命令对 Windows PowerShell 配置文件，类是在所有 Windows PowerShell 会话中可用。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can specify the type by specifying an existing assembly or source code files, or you can specify the source code inline or saved in a variable.</source>
          <target state="translated">你可以通过指定现有程序集或源代码文件来指定类型，也可以指定内联源代码或保存在变量中的源代码。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can even specify only a method and <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> will define and generate the class.</source>
          <target state="translated">您甚至可以指定只有一种方法和 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 将定义并生成类。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use this feature to make Platform Invoke (P/Invoke) calls to unmanaged functions in Windows PowerShell.</source>
          <target state="translated">你可以使用此功能对 Windows PowerShell 中的未托管函数进行“平台调用”(P/Invoke) 调用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you specify source code, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> compiles the specified source code and generates an in-memory assembly that contains the new .NET Framework types.</source>
          <target state="translated">如果指定源代码， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 编译指定的源代码并生成一个包含新的.NET Framework 类型的内存中程序集。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can use the parameters of <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> to specify an alternate language and compiler (CSharp is the default), compiler options, assembly dependencies, the class namespace, the names of the type, and the resulting assembly.</source>
          <target state="translated">您可以使用的参数 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 来指定替代语言和编译器 （默认值是 CSharp）、 编译器选项、 程序集依赖项、 类命名空间、 类型和生成的程序集的名称。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 1 --------------------------</source>
          <target state="translated">-------------------------- 示例 1 --------------------------</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>These commands add the BasicTest class to the session by specifying source code that is stored in a variable.</source>
          <target state="translated">这些命令通过指定存储在变量中的源代码，将 BasicTest 类添加到会话中。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The type has a static method called Add and a non-static method called Multiply.</source>
          <target state="translated">该类型具有一个名为 Add 的静态方法和一个名为 Multiply 的非静态方法。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The first command stores the source code for the class in the $source variable.</source>
          <target state="translated">第一个命令将该类的源代码存储在 $source 变量中。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add the class to the session.</source>
          <target state="translated">第二个命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 可将类添加到会话。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Because it is using inline source code, the command uses the <bpt id="p1">**</bpt>TypeDefinition<ept id="p1">**</ept> parameter to specify the code in the $source variable.</source>
          <target state="translated">由于它使用内联源代码，该命令使用 <bpt id="p1">**</bpt>TypeDefinition<ept id="p1">**</ept> 参数来指定 $source 变量中的代码。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The remaining commands use the new class.</source>
          <target state="translated">其余的命令使用新类。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The third command calls the Add static method of the BasicTest class.</source>
          <target state="translated">第三个命令调用 BasicTest 类的 Add 静态方法。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>It uses the double-colon characters (::) to specify a static member of the class.</source>
          <target state="translated">它使用双冒号字符 (::) 来指定该类的静态成员。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The fourth command uses the <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> cmdlet to instantiate an instance of the BasicTest class.</source>
          <target state="translated">第四个命令使用 <bpt id="p1">**</bpt>New-object<ept id="p1">**</ept> cmdlet 来实例化 BasicTest 类的实例。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>It saves the new object in the $basicTestObject variable.</source>
          <target state="translated">它将新对象保存在 $basicTestObject 变量中。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The fifth command uses the Multiply method of $basicTestObject.</source>
          <target state="translated">第五个命令使用 $basicTestObject 的 Multiply 方法。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 2 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 2 --------------------------</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>These commands use the Get-Member cmdlet to examine the objects that the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> and New-Object cmdlets created in the previous example.</source>
          <target state="translated">这些命令使用 Get-member cmdlet 来检查的对象， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 和 New-object cmdlet 创建在前面的示例。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The first command uses the <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> cmdlet to get the type and members of the BasicTest class that <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> added to the session.</source>
          <target state="translated">第一个命令使用 <bpt id="p1">**</bpt>Get-member<ept id="p1">**</ept> cmdlet 来获取的类型和成员的 basictest 类 <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 添加到会话。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> command reveals that it is a <bpt id="p2">**</bpt>System.RuntimeType<ept id="p2">**</ept> object, which is derived from the System.Object class.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Get-member<ept id="p1">**</ept> 命令表明它是 <bpt id="p2">**</bpt>System.RuntimeType<ept id="p2">**</ept> 对象，它从 System.Object 类派生。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">**</bpt>Static<ept id="p1">**</ept> parameter of the <bpt id="p2">**</bpt>Get-Member<ept id="p2">**</ept> cmdlet to get the static properties and methods of the BasicTest class.</source>
          <target state="translated">第二个命令使用 <bpt id="p1">**</bpt>静态<ept id="p1">**</ept> 参数 <bpt id="p2">**</bpt>Get-member<ept id="p2">**</ept> cmdlet 来获取静态属性和 BasicTest 类的方法。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The output shows that the Add method is included.</source>
          <target state="translated">该输出显示包含了 Add 方法。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The third command uses the <bpt id="p1">**</bpt>Get-Member<ept id="p1">**</ept> cmdlet to get the members of the object stored in the $BasicTestObject variable.</source>
          <target state="translated">第三个命令使用 <bpt id="p1">**</bpt>Get-member<ept id="p1">**</ept> cmdlet 来获取 $BasicTestObject 变量中存储的对象的成员。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This was the object instance that was created by using the <bpt id="p1">**</bpt>New-Object<ept id="p1">**</ept> cmdlet with the $BasicType class.</source>
          <target state="translated">这是使用创建的对象实例 <bpt id="p1">**</bpt>New-object<ept id="p1">**</ept> cmdlet 与 $BasicType 类。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The output reveals that the value of the $BasicTestObject variable is an instance of the BasicTest class and that it includes a member called Multiply.</source>
          <target state="translated">该输出表明 $BasicTestObject 变量的值是 BasicTest 类的实例，并且它包括一个名为 Multiply 的成员。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 3 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 3 --------------------------</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This command adds the classes from the Accessibility assembly to the current session.</source>
          <target state="translated">此命令会将 Accessibility 程序集中的类添加到当前会话中。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>AssemblyName<ept id="p1">**</ept> parameter to specify the name of the assembly.</source>
          <target state="translated">该命令使用 <bpt id="p1">**</bpt>AssemblyName<ept id="p1">**</ept> 参数来指定程序集的名称。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The wildcard character allows you to get the correct assembly even when you are not sure of the name or its spelling.</source>
          <target state="translated">甚至在你不确定程序集名称或其拼写时，可以使用通配符获取正确的程序集。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter to generate objects that represent the classes that are added to the session, and it saves the objects in the $accType variable.</source>
          <target state="translated">该命令使用 <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> 参数来生成对象添加到该会话中的类，并将对象保存在 $accType 变量中。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 4 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 4 --------------------------</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This example uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add the VBFromFile class that is defined in the Hello.vb file to the current session.</source>
          <target state="translated">此示例使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将添加到当前会话 Hello.vb 文件中定义的 VBFromFile 类。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The text of the Hello.vb file is shown in the command output.</source>
          <target state="translated">在命令输出中显示 Hello.vb 文件的文本。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The first command uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add the type defined in the Hello.vb file to the current session.</source>
          <target state="translated">第一个命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将添加到当前会话 Hello.vb 文件中定义的类型。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> parameter to specify the source file.</source>
          <target state="translated">该命令使用 <bpt id="p1">**</bpt>路径<ept id="p1">**</ept> 参数来指定源代码文件。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The second command calls the SayHello function as a static method of the VBFromFile class.</source>
          <target state="translated">第二个命令将 SayHello 函数作为 VBFromFile 类的静态方法进行调用。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 5 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 5 --------------------------</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The commands in this example demonstrate how to call native Windows APIs in Windows PowerShell.</source>
          <target state="translated">此示例中的命令演示如何在 Windows PowerShell 中调用本机 Windows API。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> uses the Platform Invoke (P/Invoke) mechanism to call a function in User32.dll from Windows PowerShell.</source>
          <target state="translated"><bpt id="p1">**</bpt>添加类型<ept id="p1">**</ept> 使用平台调用 (P/Invoke) 机制来从 Windows PowerShell 调用 User32.dll 中的函数。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command stores the C# signature of the <bpt id="p1">**</bpt>ShowWindowAsync<ept id="p1">**</ept> function in the $signature variable.</source>
          <target state="translated">第一个命令将存储的 C# 签名 <bpt id="p1">**</bpt>ShowWindowAsync<ept id="p1">**</ept> $signature 变量中的函数。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>(For more information, see "ShowWindowAsync Function" in the MSDN library at http://go.microsoft.com/fwlink/?LinkId=143643.) To ensure that the resulting method will be visible in a Windows PowerShell session, the "public" keyword has been added to the standard signature.</source>
          <target state="translated">（有关详细信息，请参阅 MSDN 库中的“ShowWindowAsync 函数”，网址是：http://go.microsoft.com/fwlink/?LinkId=143643。）为了确保生成的方法将在 Windows PowerShell 会话中可见，已将“public”关键字添加到标准签名中。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add the ShowWindowAsync function to the Windows PowerShell session as a static method of a class that <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> creates.</source>
          <target state="translated">第二个命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将 ShowWindowAsync 函数添加到 Windows PowerShell 会话中作为类的静态方法， <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 创建。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> parameter to specify the method definition saved in the $signature variable.</source>
          <target state="translated">该命令使用 <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> 参数来指定保存在 $signature 变量的方法定义。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Namespace<ept id="p2">**</ept> parameters to specify a name and namespace for the class.</source>
          <target state="translated">该命令使用 <bpt id="p1">**</bpt>名称<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>Namespace<ept id="p2">**</ept> 参数来指定名称和类命名空间。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter to generate an object that represents the types, and it saves the object in the $showWindowAsync variable.</source>
          <target state="translated">它使用 <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> 参数来生成一个对象，表示该类型，并将该对象保存在 $showWindowAsync 变量。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The third and fourth commands use the new ShowWindowAsync static method.</source>
          <target state="translated">第三个和第四个命令使用新的 ShowWindowAsync 静态方法。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The method takes two parameters, the window handle, and an integer specifies how the window is to be shown.</source>
          <target state="translated">该方法采用两个参数：窗口句柄和指定如何显示窗口的整数。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The third command calls ShowWindowAsync.</source>
          <target state="translated">第三个命令调用 ShowWindowAsync。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses the Get-Process cmdlet with the $pid automatic variable to get the process that is hosting the current Windows PowerShell session.</source>
          <target state="translated">它使用 Get-process cmdlet $pid 自动变量以获取托管当前 Windows PowerShell 会话的进程。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Then it uses the <bpt id="p1">**</bpt>MainWindowHandle<ept id="p1">**</ept> property of the current process and a value of "2", which represents the SW_MINIMIZE value.</source>
          <target state="translated">然后，它使用 <bpt id="p1">**</bpt>MainWindowHandle<ept id="p1">**</ept> 当前进程和表示 SW_MINIMIZE 值"2"，值的属性。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To restore the window, the fourth command use a value of "4" for the window position, which represents the SW_RESTORE value.</source>
          <target state="translated">为了还原窗口，第四个命令将值“4”用于窗口位置，它表示 SW_RESTORE 值。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>(SW_MAXIMIZE is 3.)</source>
          <target state="translated">（SW_MAXIMIZE 为 3。）</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 6 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 6 --------------------------</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This command uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add a method from inline JScript code to the Windows PowerShell session.</source>
          <target state="translated">此命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将内联 JScript 代码中的一种方法添加到 Windows PowerShell 会话。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> parameter to submit source code stored in the $jsMethod variable.</source>
          <target state="translated">它使用 <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> 参数来提交 $jsMethod 变量中存储的源代码。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> parameter to specify a name for the class that <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> creates for the method and the <bpt id="p3">**</bpt>Language<ept id="p3">**</ept> parameter to specify the JScript language.</source>
          <target state="translated">它使用 <bpt id="p1">**</bpt>名称<ept id="p1">**</ept> 参数来指定类的名称， <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 为该方法创建和 <bpt id="p3">**</bpt>语言<ept id="p3">**</ept> 参数来指定 JScript 语言。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 7 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 7 --------------------------</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This example shows how to use the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to add an FSharp code compiler to your Windows PowerShell session.</source>
          <target state="translated">此示例演示如何使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将 FSharp 代码编译器添加到你的 Windows PowerShell 会话。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>To run this example in Windows PowerShell, you must have the FSharp.Compiler.CodeDom.dll that is installed with the FSharp language.</source>
          <target state="translated">若要在 Windows PowerShell 中运行此示例，你必须具有使用 FSharp 语言安装的 FSharp.Compiler.CodeDom.dll。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The first command in the example uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet with the <bpt id="p2">**</bpt>Path<ept id="p2">**</ept> parameter to specify an assembly.</source>
          <target state="translated">该示例中的第一个命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 与 <bpt id="p2">**</bpt>路径<ept id="p2">**</ept> 参数来指定程序集。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> gets the types in the assembly.</source>
          <target state="translated"><bpt id="p1">**</bpt>添加类型<ept id="p1">**</ept> 获取该程序集中的类型。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The second command uses the New-Object cmdlet to create an instance of the FSharp code provider and saves the result in the $Provider variable.</source>
          <target state="translated">第二个命令使用 New-object cmdlet 创建 FSharp 代码提供程序的实例，并将结果保存在 $Provider 变量。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The third command saves the FSharp code that defines the Loop method in the $FSharpCode variable.</source>
          <target state="translated">第三个命令将定义 Loop 方法的 FSharp 代码保存在 $FSharpCode 变量中。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The fourth command uses the <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet to save the public types defined in $fSharpCode in the $fSharpType variable.</source>
          <target state="translated">第四个命令使用 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 将保存在 $fSharpType 变量 $fSharpCode 中定义的公共类型。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>TypeDefinition<ept id="p1">**</ept> parameter specifies the source code that defines the types.</source>
          <target state="translated"> <bpt id="p1">**</bpt>TypeDefinition<ept id="p1">**</ept> 参数指定定义类型的源代码。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>CodeDomProvider<ept id="p1">**</ept> parameter specifies the source code compiler.</source>
          <target state="translated"> <bpt id="p1">**</bpt>CodeDomProvider<ept id="p1">**</ept> 参数指定源代码编译器。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter directs <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> to return a <bpt id="p3">**</bpt>Runtime<ept id="p3">**</ept> object that represents the types and a pipeline operator (|) sends the <bpt id="p4">**</bpt>Runtime<ept id="p4">**</ept> object to the Where-Object cmdlet, which returns only the public types.</source>
          <target state="translated"> <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> 参数指示 <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 返回 <bpt id="p3">**</bpt>运行时<ept id="p3">**</ept> 对象表示的类型和一个管道运算符 (|) 将发送 <bpt id="p4">**</bpt>运行时<ept id="p4">**</ept> 对象传递给 Where-object cmdlet，后者仅返回公共类型返回。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> cmdlet is used because the FSharp provider generates non-public types to support the resulting public type.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Where-object<ept id="p1">**</ept> 使用 cmdlet，因为 FSharp 提供程序生成非公共类型，以支持生成的公共类型。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The fifth command calls the Loop method as a static method of the type stored in the $fSharpType variable.</source>
          <target state="translated">第五个命令将 Loop 方法作为 $fSharpType 变量中存储的类型的静态方法进行调用。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>PARAMETERS</source>
          <target state="translated">参数</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>-AssemblyName</source>
          <target state="translated">程序集的名称</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Specifies the name of an assembly that includes the types.</source>
          <target state="translated">指定包含类型的程序集的名称。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> takes the types from the specified assembly.</source>
          <target state="translated"><bpt id="p1">**</bpt>添加类型<ept id="p1">**</ept> 采用从指定的程序集的类型。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This parameter is required when you are creating types based on an assembly name.</source>
          <target state="translated">在基于程序集名称创建类型时，此参数是必需的。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Enter the full or simple name (also known as the "partial name") of an assembly.</source>
          <target state="translated">输入程序集的完整名称或简单名称（也称为“部分名称”）。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Wildcard characters are permitted in the assembly name.</source>
          <target state="translated">在程序集名称中允许使用通配符。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>If you enter a simple or partial name, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> resolves it to the full name, and then uses the full name to load the assembly.</source>
          <target state="translated">如果输入简单或部分名称， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 将其解析为的完整名称，然后使用的完整名称加载程序集。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>This parameter does not accept a path or file name.</source>
          <target state="translated">此参数不接受路径或文件名。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>To enter the path to the assembly dynamic-link library (DLL) file, use the Path parameter.</source>
          <target state="translated">若要输入程序集动态链接库 (DLL) 文件的路径，请使用 Path 参数。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-CodeDomProvider</source>
          <target state="translated">-CodeDomProvider</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Specifies a code generator or compiler.</source>
          <target state="translated">指定代码生成器或编译器。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> uses the specified compiler to compile the source code.</source>
          <target state="translated"><bpt id="p1">**</bpt>添加类型<ept id="p1">**</ept> 使用指定的编译器来编译的源代码。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The default is the CSharp compiler.</source>
          <target state="translated">默认值为 CSharp 编译器。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Use this parameter if you are using a language that cannot be specified by using the Language parameter.</source>
          <target state="translated">当你要使用一种无法通过 Language 参数指定的语言时，请使用此参数。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The CodeDomProvider that you specify must be able to generate assemblies from source code.</source>
          <target state="translated">你指定的 CodeDomProvider 必须能够从源代码生成程序集。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>-CompilerParameters</source>
          <target state="translated">-CompilerParameters</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Specifies the options for the source code compiler.</source>
          <target state="translated">指定用于源代码编译器的选项。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>These options are sent to the compiler without revision.</source>
          <target state="translated">这些选项无需修改即可发送到编译器。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>This parameter allows you to direct the compiler to generate an executable file, embed resources, or set command-line options, such as the "/unsafe" option.</source>
          <target state="translated">此参数使你可以指示编译器生成可执行文件、嵌入资源，或设置命令行选项，如“/unsafe”选项。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This parameter implements the <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> class (System.CodeDom.Compiler.CompilerParameters).</source>
          <target state="translated">此参数可实现 <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> 类 (System.CodeDom.Compiler.CompilerParameters)。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot use the <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ReferencedAssemblies<ept id="p2">**</ept> parameters in the same command.</source>
          <target state="translated">不能使用 <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>ReferencedAssemblies<ept id="p2">**</ept> 同一命令中的参数。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-IgnoreWarnings</source>
          <target state="translated">-IgnoreWarnings</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Ignores compiler warnings.</source>
          <target state="translated">忽略编译器警告。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Use this parameter to prevent <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> from handling compiler warnings as errors.</source>
          <target state="translated">使用此参数以防止 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 从处理编译器警告视为错误。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>-Language</source>
          <target state="translated">语言</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Specifies the language that is used in the source code.</source>
          <target state="translated">指定在源代码中使用的语言。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> cmdlet uses the value of this parameter to select the appropriate CodeDomProvider.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> cmdlet 使用此参数的值来选择适当的 CodeDomProvider。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Valid values are "CSharp", "CSharpVersion3", "VisualBasic", and "JScript".</source>
          <target state="translated">有效值为“CSharp”、“CSharpVersion3”、“VisualBasic”和“JScript”。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>"CSharp" is the default value.</source>
          <target state="translated">默认值为“CSharp”。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>-LiteralPath</source>
          <target state="translated">-LiteralPath</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Specifies the path to source code files or assembly DLL files that contain the types.</source>
          <target state="translated">指定包含类型的源代码文件或程序集 DLL 文件的路径。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">**</bpt>Path<ept id="p1">**</ept>, the value of the <bpt id="p2">**</bpt>LiteralPath<ept id="p2">**</ept> parameter is used exactly as it is typed.</source>
          <target state="translated">与不同 <bpt id="p1">**</bpt>路径<ept id="p1">**</ept>, ，值 <bpt id="p2">**</bpt>LiteralPath<ept id="p2">**</ept> 完全按照其键入使用参数。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>No characters are interpreted as wildcards.</source>
          <target state="translated">不会将任何字符解释为通配符。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>If the path includes escape characters, enclose it in single quotation marks.</source>
          <target state="translated">如果路径包括转义符，请将其括在单引号中。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Single quotation marks tell Windows PowerShell not to interpret any characters as escape sequences.</source>
          <target state="translated">单引号会告知 Windows PowerShell 不要将所有字符都解释为转义序列。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>-MemberDefinition</source>
          <target state="translated">-MemberDefinition</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Specifies new properties or methods for the class.</source>
          <target state="translated">指定类的新属性或方法。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> generates the template code that is required to support the properties or methods.</source>
          <target state="translated"><bpt id="p1">**</bpt>添加类型<ept id="p1">**</ept> 生成支持属性或方法所需的模板代码。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>You can use this feature to make Platform Invoke (P/Invoke) calls to unmanaged functions in Windows PowerShell.</source>
          <target state="translated">你可以使用此功能对 Windows PowerShell 中的未托管函数进行“平台调用”(P/Invoke) 调用。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>For more information, see the examples.</source>
          <target state="translated">有关详细信息，请参阅示例。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>-Name</source>
          <target state="translated">-Name</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Specifies the name of the class to create.</source>
          <target state="translated">指定要创建的类的名称。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>This parameter is required when generating a type from a member definition.</source>
          <target state="translated">当从成员定义生成类型时，此参数是必需的。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The type name and namespace must be unique within a session.</source>
          <target state="translated">类型名称和命名空间在一个会话中必须是唯一的。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You cannot unload a type or change it.</source>
          <target state="translated">不可以卸载或更改类型。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If you need to change the code for a type, you must change the name or start a new Windows PowerShell session.</source>
          <target state="translated">如果你需要更改类型的代码，则必须更改其名称或启动新的 Windows PowerShell 会话。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Otherwise, the command fails.</source>
          <target state="translated">否则，该命令将失败。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>-Namespace</source>
          <target state="translated">-Namespace</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Specifies a namespace for the type.</source>
          <target state="translated">指定类型的命名空间。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If this parameter is not included in the command, the type is created in the <bpt id="p1">**</bpt>Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes<ept id="p1">**</ept> namespace.</source>
          <target state="translated">如果在命令中不包括此参数，则在创建类型 <bpt id="p1">**</bpt>Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes<ept id="p1">**</ept> 命名空间。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>If the parameter is included in the command with an empty string value or a value of $null, the type is generated in the global namespace.</source>
          <target state="translated">如果在含有空字符串值或 $null 值的命令中包括此参数，则将在全局命名空间中生成类型。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>-OutputAssembly</source>
          <target state="translated">-OutputAssembly</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Generates a DLL file for the assembly with the specified name in the location.</source>
          <target state="translated">在该位置中为具有指定名称的程序集生成 DLL 文件。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Enter a path (optional) and file name.</source>
          <target state="translated">输入路径（可选）和文件名。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Wildcard characters are permitted.</source>
          <target state="translated">允许使用通配符。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> generates the assembly only in memory.</source>
          <target state="translated">默认情况下， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 仅在内存中生成程序集。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>-OutputType</source>
          <target state="translated">-OutputType</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Specifies the output type of the output assembly.</source>
          <target state="translated">指定输出程序集的输出类型。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Valid values are <bpt id="p1">**</bpt>Library<ept id="p1">**</ept>, <bpt id="p2">**</bpt>ConsoleApplication<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>WindowsApplication<ept id="p3">**</ept>.</source>
          <target state="translated">有效值为 <bpt id="p1">**</bpt>库<ept id="p1">**</ept>, ，<bpt id="p2">**</bpt>控制台应用程序<ept id="p2">**</ept>, ，和 <bpt id="p3">**</bpt>WindowsApplication<ept id="p3">**</ept>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For more information about the values, see "OutputAssemblyType Enumeration" in MSDN.</source>
          <target state="translated">有关这些值的详细信息，请参阅 MSDN 中的“OutputAssemblyType 枚举”。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>By default, no output type is specified.</source>
          <target state="translated">默认情况下，不指定输出类型。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>This parameter is valid only when an output assembly is specified in the command.</source>
          <target state="translated">仅当命令中指定了输出程序集时，此参数才有效。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>-PassThru</source>
          <target state="translated">-PassThru</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Returns a <bpt id="p1">**</bpt>System.Runtime<ept id="p1">**</ept> object that represents the types that were added.</source>
          <target state="translated">返回 <bpt id="p1">**</bpt>System.Runtime<ept id="p1">**</ept> 对象，表示已添加的类型。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>By default, this cmdlet does not generate any output.</source>
          <target state="translated">默认情况下，此 cmdlet 将不产生任何输出。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>-Path</source>
          <target state="translated">-Path</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Specifies the path to source code files or assembly DLL files that contain the types.</source>
          <target state="translated">指定包含类型的源代码文件或程序集 DLL 文件的路径。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>If you submit source code files, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> compiles the code in the files and creates an in-memory assembly of the types.</source>
          <target state="translated">如果提交源代码文件中， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 编译文件中的代码并创建一个内存中程序集的类型。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The file name extension specified in the value of Path determines the compiler that <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> uses.</source>
          <target state="translated">在路径的值中指定的文件扩展名确定编译器的 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 使用。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>If you submit an assembly file, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> takes the types from the assembly.</source>
          <target state="translated">如果提交程序集文件， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 采用从程序集中的类型。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>To specify an in-memory assembly or the global assembly cache, use the <bpt id="p1">**</bpt>AssemblyName<ept id="p1">**</ept> parameter.</source>
          <target state="translated">若要指定内存中程序集或全局程序集缓存，请使用 <bpt id="p1">**</bpt>AssemblyName<ept id="p1">**</ept> 参数。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>-ReferencedAssemblies</source>
          <target state="translated">-ReferencedAssemblies</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Specifies the assemblies upon which the type depends.</source>
          <target state="translated">指定类型所依赖的程序集。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> references System.dll and System.Management.Automation.dll.</source>
          <target state="translated">默认情况下， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 引用 System.dll 和 System.Management.Automation.dll。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The assemblies that you specify by using this parameter are referenced in addition to the default assemblies.</source>
          <target state="translated">除了引用默认程序集之外，还将引用你通过使用此参数指定的程序集。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>You cannot use the <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ReferencedAssemblies<ept id="p2">**</ept> parameters in the same command.</source>
          <target state="translated">不能使用 <bpt id="p1">**</bpt>CompilerParameters<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>ReferencedAssemblies<ept id="p2">**</ept> 同一命令中的参数。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>-TypeDefinition</source>
          <target state="translated">的类型定义</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Specifies the source code that contains the type definitions.</source>
          <target state="translated">指定包含类型定义的源代码。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Enter the source code in a string or here-string, or enter a variable that contains the source code.</source>
          <target state="translated">以字符串或 here-string 的形式输入源代码或输入一个包含源代码的变量。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>For more information about here-strings, see about_Quoting_Rules (http://go.microsoft.com/fwlink/?LinkID=113253).</source>
          <target state="translated">有关 here-string 的详细信息，请参阅 about_Quoting_Rules (http://go.microsoft.com/fwlink/?LinkID=113253)。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Include a namespace declaration in your type definition.</source>
          <target state="translated">在类型定义中包括命名空间声明。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If you omit the namespace declaration, your type might have the same name as another type or the shortcut for another type, causing an unintentional overwrite.</source>
          <target state="translated">如果省略命名空间声明，则你的类型可能会与其他类型或其他类型的快捷方式同名，从而导致意外覆盖。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For example, if you define a type called "Exception", scripts that use "Exception" as the shortcut for <bpt id="p1">**</bpt>System.Exception<ept id="p1">**</ept> will fail.</source>
          <target state="translated">例如，如果您定义一个名为"异常"类型，脚本，使用"异常"作为其快捷方式为 <bpt id="p1">**</bpt>System.Exception<ept id="p1">**</ept> 将失败。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>-UsingNamespace</source>
          <target state="translated">-UsingNamespace</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Specifies other namespaces that are required for the class.</source>
          <target state="translated">指定类所需的其他命名空间。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This is much like the Using keyword in C#.</source>
          <target state="translated">这非常类似于 C# 中的 Using 关键字。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept> references the <bpt id="p2">**</bpt>System<ept id="p2">**</ept> namespace.</source>
          <target state="translated">默认情况下， <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept> 引用 <bpt id="p2">**</bpt>系统<ept id="p2">**</ept> 命名空间。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> parameter is used, <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> also references the <bpt id="p3">**</bpt>System.Runtime.InteropServices<ept id="p3">**</ept> namespace by default.</source>
          <target state="translated">当 <bpt id="p1">**</bpt>MemberDefinition<ept id="p1">**</ept> 使用参数，则 <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 也引用 <bpt id="p3">**</bpt>System.Runtime.InteropServices<ept id="p3">**</ept> 默认命名空间。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The namespaces that you add by using the <bpt id="p1">**</bpt>UsingNamespace<ept id="p1">**</ept> parameter are referenced in addition to the default namespaces.</source>
          <target state="translated">通过使用添加的命名空间 <bpt id="p1">**</bpt>UsingNamespace<ept id="p1">**</ept> 参数引用除了默认命名空间。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>CommonParameters</source>
          <target state="translated">CommonParameters</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable.</source>
          <target state="translated">此 cmdlet 支持以下常见参数:-调试-ErrorAction、-ErrorVariable、-InformationAction、-InformationVariable、-OutVariable、-OutBuffer、-PipelineVariable、-Verbose、-WarningAction 和-WarningVariable。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>For more information, see about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</source>
          <target state="translated">有关详细信息，请参阅 about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216)。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>INPUTS</source>
          <target state="translated">输入</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">无</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>You cannot pipe objects to Add-Type.</source>
          <target state="translated">不能通过管道将对象传递给 Add-Type。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>OUTPUTS</source>
          <target state="translated">输出</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>None or System.Type</source>
          <target state="translated">无或 System.Type</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter, <bpt id="p2">**</bpt>Add-Type<ept id="p2">**</ept> returns a <bpt id="p3">**</bpt>System.Type<ept id="p3">**</ept> object that represents the new type.</source>
          <target state="translated">当您使用 <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> 参数， <bpt id="p2">**</bpt>Add-type<ept id="p2">**</ept> 返回 <bpt id="p3">**</bpt>System.Type<ept id="p3">**</ept> 对象，表示新类型。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Otherwise, this cmdlet does not generate any output.</source>
          <target state="translated">否则，此 cmdlet 将不生成任何输出。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">说明</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The types that you add exist only in the current session.</source>
          <target state="translated">你添加的类型仅存在当前会话中。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>To use the types in all sessions, add them to your Windows PowerShell profile.</source>
          <target state="translated">若要在所有会话中使用这些类型，请将它们添加到你的 Windows PowerShell 配置文件中。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For more information about the profile, see about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729).</source>
          <target state="translated">有关配置文件的详细信息，请参阅 about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729)。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Type names (and namespaces) must be unique within a session.</source>
          <target state="translated">类型名称（和命名空间）在一个会话中必须是唯一的。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>You cannot unload a type or change it.</source>
          <target state="translated">不可以卸载或更改类型。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If you need to change the code for a type, you must change the name or start a new Windows PowerShell session.</source>
          <target state="translated">如果你需要更改类型的代码，则必须更改其名称或启动新的 Windows PowerShell 会话。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Otherwise, the command fails.</source>
          <target state="translated">否则，该命令将失败。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The CodeDomProvider class for some languages, such as IronPython and JSharp, does not generate output.</source>
          <target state="translated">某些语言的 CodeDomProvider 类（如 IronPython 和 JSharp）不生成输出。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>As a result, types written in these languages cannot be used with <bpt id="p1">**</bpt>Add-Type<ept id="p1">**</ept>.</source>
          <target state="translated">因此，不能与使用这些语言中编写的类型 <bpt id="p1">**</bpt>Add-type<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>This cmdlet is based on the <bpt id="p1">**</bpt>CodeDomProvider<ept id="p1">**</ept> class.</source>
          <target state="translated">此 cmdlet 根据 <bpt id="p1">**</bpt>CodeDomProvider<ept id="p1">**</ept> 类。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>For more information about this class, see the Microsoft .NET Framework SDK.</source>
          <target state="translated">有关此类的详细信息，请参阅 Microsoft .NET Framework SDK。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>RELATED LINKS</source>
          <target state="translated">相关的链接</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Add-Member</source>
          <target state="translated">Add-Member</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>New-Object</source>
          <target state="translated">新对象</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>