<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e3678c50582d25cf0c15d13ad31c9a5f012b40e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Splatting.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e36ef81e5150035ee958828a7d6d78c0c3d9bdec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae441651a33a38fb6adb54d944f2fdf31e5766d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Splatting</source>
          <target state="translated">有关展开</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use splatting to pass parameters to commands in Windows PowerShell.</source>
          <target state="translated">描述如何使用展开将参数传递给 Windows PowerShell 中的命令。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[This topic was contributed by Rohn Edwards of Gulfport, Mississippi, a system administrator and the winner of the Advanced Division of the 2012 Scripting Games.</source>
          <target state="translated">[本主题已撰写的 Rohn Edwards 的 Gulfport 密西西比州，系统管理员和高级小组的 2012年脚本编写比赛的优胜者。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Revised for Windows PowerShell 3.0.]</source>
          <target state="translated">修订了用于 Windows PowerShell 3.0。]</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Splatting is a method of passing a collection of parameter values to a command as unit.</source>
          <target state="translated">展开是一种将参数值的集合传递给命令作为单元的方法。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell associates each value in the collection with a command parameter.</source>
          <target state="translated">Windows PowerShell 将使用命令参数相关联的集合中的每个值。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Splatted parameter values are stored in named splatting variables, which look like standard variables, but begin with an At symbol (@) instead of a dollar sign ($).</source>
          <target state="translated">Splatted 参数值将存储在命名的展开变量中，如下所示的标准变量，但开头 At 符号 (@) 而不是一个美元符号 （$）。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The At symbol tells Windows PowerShell that you are passing a collection of values, instead of a single value.</source>
          <target state="translated">At 符号告诉 Windows PowerShell 要传递的值，而不是单个值的集合。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Splatting makes your commands shorter and easier to read.</source>
          <target state="translated">展开让您更短且更易于阅读的命令。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can re-use the splatting values in different command calls and use splatting to pass parameter values from the $PSBoundParameters automatic variable to other scripts and functions.</source>
          <target state="translated">您可以在不同的命令调用中重复使用的展开值并使用展开将参数值从 $PSBoundParameters 自动变量传递到其他脚本和函数。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can also use splatting to represent all parameters of a command.</source>
          <target state="translated">从 Windows PowerShell 3.0 开始，还可展开用于表示命令的所有参数。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To provide parameter values for positional parameters, in which parameter names are not required, use the array syntax.</source>
          <target state="translated">若要为位置参数，在哪个参数名称，则不需要提供参数值使用数组语法。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To provide parameter name and value pairs, use the hash table syntax.</source>
          <target state="translated">若要提供参数名称和值对，请使用哈希表语法。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The splatted value can appear anywhere in the parameter list.</source>
          <target state="translated">Splatted 值可以出现在参数列表中的任意位置。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When splatting, you do not need to use a hash table or an array to pass all parameters.</source>
          <target state="translated">当展开方法中，您不必使用哈希表或一个数组来传递所有参数。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You may pass some parameters by using splatting and pass others by position or by parameter name.</source>
          <target state="translated">您可能会使用展开传递一些参数，并通过其他人按位置或参数名称。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Also, you can splat multiple objects in a single command just so you pass no more than one value for each parameter.</source>
          <target state="translated">此外，您可以展开单个命令中的多个对象只是以便将存在多个值的每个参数传递。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH HASH TABLES</source>
          <target state="translated">展开带有哈希表</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a hash table to splat parameter name and value pairs.</source>
          <target state="translated">使用哈希表来展开参数名称和值对。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can use this format for all parameter types, including positional and named parameters and switch parameters.</source>
          <target state="translated">可以使用此格式，对于所有的参数类型，包括位置和命名参数和开关参数。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">下面的示例比较两个将 Test.txt 文件复制到同一目录中的 Test2.txt 文件的 Copy-item 命令。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are included.</source>
          <target state="translated">第一个示例使用传统的格式在哪个参数名称是包括在内。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf</source>
          <target state="translated">副本-项-"test.txt"路径-目标"test2.txt"-WhatIf</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The second example uses hash table splatting.</source>
          <target state="translated">第二个示例使用哈希表展开。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter-name and parameter-value pairs and stores it in the $HashArguments variable.</source>
          <target state="translated">第一个命令创建的参数名称哈希表和参数值对，并将其存储在 $HashArguments 变量中。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The second command uses the $HashArguments variable in a command with splatting.</source>
          <target state="translated">第二个命令使用 $HashArguments 变量中的命令的展开。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The At symbol (@HashArguments) replaces the dollar sign ($HashArguments) in the command.</source>
          <target state="translated">At 符号 (@HashArguments) 将替换美元符号 ($HashArguments) 命令中。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To provide a value for the WhatIf switch parameter, use $True or $False.</source>
          <target state="translated">若要为 WhatIf 开关参数提供一个值，使用 $True $False。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$HashArguments = @{ Path = "test.txt"; Destination = "test2.txt"; WhatIf = $true } PS C:&gt;Copy-Item @HashArguments</source>
          <target state="translated">PS c: &gt; $HashArguments = @{路径 ="test.txt";目标 ="test2.txt";WhatIf = $true} PS c: &gt; Copy-item @HashArguments</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note: In the first command, the At symbol (@) indicates a hash table, not a splatted value.</source>
          <target state="translated">注意︰ 在第一个命令，At 符号 (@) 指示哈希表，而非 splatted 值。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The syntax for hash tables in Windows PowerShell is: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>; …}</source>
          <target state="translated">用于 Windows PowerShell 中的哈希表的语法是: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>;...}</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH ARRAYS</source>
          <target state="translated">与数组一起使用的展开</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use an array to splat values for positional parameters, which do not require parameter names.</source>
          <target state="translated">对于位置参数，不需要参数名称中使用为展开值数组。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The values must be in position-number order in the array.</source>
          <target state="translated">值必须在数组中的位置号订单中。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">下面的示例比较两个将 Test.txt 文件复制到同一目录中的 Test2.txt 文件的 Copy-item 命令。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are omitted.</source>
          <target state="translated">第一个示例使用传统的格式省略参数名。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The parameter values appear in position order in the command.</source>
          <target state="translated">在命令中的位置顺序显示的参数值。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Copy-Item "test.txt" "test2.txt" -WhatIf</source>
          <target state="translated">复制项"test.txt""test2.txt"-WhatIf</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second example uses array splatting.</source>
          <target state="translated">第二个示例使用的数组展开。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first command creates an array of the parameter values and stores it in the $ArrayArguments variable.</source>
          <target state="translated">第一个命令创建的参数值数组，并将其存储在 $ArrayArguments 变量中。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The values are in position order in the array.</source>
          <target state="translated">值的数组中的位置顺序。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The second command uses the $ArrayArguments variable in a command in splatting.</source>
          <target state="translated">第二个命令在展开方法中的命令中使用 $ArrayArguments 变量。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The At symbol (@ArrayArguments) replaces the dollar sign ($ArrayArguments) in the command.</source>
          <target state="translated">At 符号 (@ArrayArguments) 将替换美元符号 ($ArrayArguments) 命令中。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$ArrayArguments = "test.txt", "test2.txt" PS C:&gt;Copy-Item @ArrayArguments -WhatIf</source>
          <target state="translated">PS c: &gt; $ArrayArguments ="test.txt"，"test2.txt"PS c: &gt; Copy-item @ArrayArguments-WhatIf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This example shows how to re-use splatted values in different commands.</source>
          <target state="translated">此示例演示如何在不同的命令中重新使用 splatted 值。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The commands in this example use the Write-Host cmdlet to write messages to the host program console.</source>
          <target state="translated">此示例中的命令使用 Write-host cmdlet 将消息写入到主机程序控制台。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It uses splatting to specify the foreground and background colors.</source>
          <target state="translated">它使用展开指定的前景色和背景色。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To change the colors of all commands, just change the value of the $Colors variable.</source>
          <target state="translated">若要更改的所有命令的颜色，只需更改 $Colors 变量的值。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter names and values and stores the hash table in the $Colors variable.</source>
          <target state="translated">第一个命令创建参数名称和值的哈希表和 $Colors 变量中存储的哈希表。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</source>
          <target state="translated">$Colors = @{ForegroundColor ="黑色"BackgroundColor ="white"}</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second and third commands use the $Colors variable for splatting in a Write-Host command.</source>
          <target state="translated">第二个和第三个命令使用 Write-host 命令中的展开 $Colors 变量。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To use the $Colors variable, replace the dollar sign ($Colors) with an At symbol (@Colors).</source>
          <target state="translated">若要使用 $Colors 变量，请将美元符号 ($Colors) 替换为一个 At 符号 (@Colors)。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Write a message with the colors in $Colors Write-Host "This is a test."</source>
          <target state="translated">写入一条消息使用的颜色在 $Colors Write-host"这是一个测试"。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>@Colors</source>
          <target state="translated">@Colors</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Write second message with same colors.</source>
          <target state="translated">编写使用相同的颜色的第二条消息。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The position of splatted hash table does not matter.</source>
          <target state="translated">Splatted 哈希表的位置并不重要。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Write-Host @Colors "This is another test."</source>
          <target state="translated">Write-host @Colors"这是另一个测试"。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example shows how to forward their parameters to other commands by using splatting and the $PSBoundParameters automatic variable.</source>
          <target state="translated">此示例演示如何通过使用展开和 $PSBoundParameters 自动变量转发到其他命令及其参数。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The $PSBoundParameters automatic variable is a dictionary (System.Collections.Generic.Dictionary) that contains all of the parameter names and values that are used when a script or function is run.</source>
          <target state="translated">$PSBoundParameters 自动变量是一个包含的所有参数名称和运行脚本或函数时所使用的值的字典 (System.Collections.Generic.Dictionary)。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, we use the $PSBoundParameters variable to forward the parameters values passed to a script or function from Test2 function to the Test1 function.</source>
          <target state="translated">在以下示例中，我们使用 $PSBoundParameters 变量转发的参数值传递给脚本或函数从 Test2 Test1 函数的函数。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both calls to the Test1 function from Test2 use splatting.</source>
          <target state="translated">对 Test1 函数从 Test2 两次调用使用展开。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>function Test1 { param($a, $b, $c)</source>
          <target state="translated">函数 Test1 {param ($a $b $c)</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>$a $b $c }</source>
          <target state="translated">$a $b $c}</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>function Test2 { param($a, $b, $c)</source>
          <target state="translated">函数 Test2 {param ($a $b $c)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $a, $b, and $c.</source>
          <target state="translated">调用 $a $b Test1 函数和 $c。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test1 @PsBoundParameters</source>
          <target state="translated">Test1 @PsBoundParameters</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $b and $c, but not with $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters }</source>
          <target state="translated">用来调用 Test1 函数 $b 和 $c，但不是能使用 $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") |Out-null Test1 @LimitedParameters}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Test2 -a 1 -b 2 -c 3</source>
          <target state="translated">PS c: &gt; Test2-a 1-b 2 c 3</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>SPLATTING COMMAND PARAMETERS</source>
          <target state="translated">展开命令参数</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use splatting to represent the parameters of a command.</source>
          <target state="translated">展开可用于表示命令的参数。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This technique is useful when you are creating a proxy function, that is, a function that calls another command.</source>
          <target state="translated">在创建代理函数时，此方法很有用，即，一个函数调用的另一个命令。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">此功能是 Windows PowerShell 3.0 中引入的。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To splat the parameters of a command, use @Args to represent the command parameters.</source>
          <target state="translated">展开为命令的参数使用 @Args 来表示的命令参数。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This technique is easier than enumerating command parameters and it works without revision even if the parameters of the called command change.</source>
          <target state="translated">这种技术是比枚举命令参数，而且即使被调用的命令的参数更改无需修改即可工作。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The feature uses the $Args automatic variable, which contains all unassigned parameter values.</source>
          <target state="translated">此功能使用 $Args 自动变量，其中包含所有未赋值的参数值。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following function calls the Get-Process cmdlet.</source>
          <target state="translated">例如，以下函数调用 Get-process cmdlet。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this function, @Args represents all of the parameters of the Get-Process cmdlet.</source>
          <target state="translated">在此函数中，@Args 表示所有 Get-process cmdlet 的参数。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>function Get-MyProcess { Get-Process @Args }</source>
          <target state="translated">函数获取 MyProcess {Get-process @Args}</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use the Get-MyProcess function, all unassigned parameters and parameter values are passed to @Args, as shown in the following commands.</source>
          <target state="translated">当使用 Get MyProcess 函数时，所有未分配的参数和参数值被传递给 @Args，如下面的命令中所示。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell</source>
          <target state="translated">PS c: &gt; Get MyProcess-命名 PowerShell</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">处理 npm （k) pm （k) ws （k) vm （m) CPU(s) Id ProcessName</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>463      46   225484     237196   719    15.86   3228 powershell</source>
          <target state="translated">463 46 225484 237196 719 15.86 3228 powershell</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell_Ise -FileVersionInfo</source>
          <target state="translated">PS c: &gt; Get MyProcess-命名 PowerShell_Ise FileVersionInfo</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>ProductVersion   FileVersion      FileName</source>
          <target state="translated">ProductVersion FileVersion FileName</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</source>
          <target state="translated">6.2.9200.16384   6.2.9200.1638...C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can use @Args in a function that has explicitly declared parameters.</source>
          <target state="translated">您可以使用 @Args 中已显式声明为参数的函数。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use it more than once in a function, but all parameters that you enter are passed to all instances of @Args, as shown in the following example.</source>
          <target state="translated">在函数中，可以多次使用它，但您输入的所有参数都传递给 @Args 的所有实例，如下面的示例中所示。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Param ([switch]$P, [switch]$C) if ($P) { Get-Process @Args } if ($C) { Get-Command @Args } }</source>
          <target state="translated">函数获取 MyCommand {Param （[交换机] $P，交换机 $C） 如果 ($P) {Get-process @Args} 如果 ($C) {Get 命令 @Args}}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyCommand -P -C -Name PowerShell</source>
          <target state="translated">PS c: &gt; Get MyCommand-P-C-将命名为 PowerShell</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">处理 npm （k) pm （k) ws （k) vm （m) CPU(s) Id ProcessName</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>408      28    75568      83176   620     1.33   1692 powershell</source>
          <target state="translated">408 28 75568 83176 620 1.33 1692 powershell</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Path               : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension          : .exe Definition         : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Visibility         : Public OutputType         : {System.String} Name               : powershell.exe CommandType        : Application ModuleName         : Module             : RemotingCapability : PowerShell Parameters         : ParameterSets      : HelpUri            : FileVersionInfo    : File:             C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</source>
          <target state="translated">路径︰ C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 扩展︰.exe 定义︰ C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe 可见性︰ 公共 OutputType: {System.String} 名称︰ powershell.exe CommandType︰ 应用程序 ModuleName︰ 模块︰ RemotingCapability: PowerShell 参数︰ ParameterSets: HelpUri: FileVersionInfo︰ 文件︰ C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</source>
          <target state="translated">about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>