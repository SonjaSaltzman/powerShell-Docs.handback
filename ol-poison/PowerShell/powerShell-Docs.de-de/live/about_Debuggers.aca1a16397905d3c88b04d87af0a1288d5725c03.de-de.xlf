<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3563c29053a4ad85d65587c5e77a30a2dbc7628</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Debuggers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d62753711baa35ff9b203ea8ccf445b98a619116</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d08eb5c290e8115c8fcfa118dc56a6beea7adf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell-Cmdlets</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Debuggers</source>
          <target state="translated">Informationen zu Debuggern</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">KURZE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes the Windows PowerShell debugger.</source>
          <target state="translated">Beschreibt die Windows PowerShell-Debugger.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">LANGE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Debugging is the process of examining a script while it is running to identify and correct errors in the script instructions.</source>
          <target state="translated">Debuggen ist der Prozess von einem Skript untersuchen, während er ausgeführt wird, um zu identifizieren und beheben Sie Fehler in den skriptanweisungen.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can help you examine and identify errors and inefficiencies in your scripts, functions, commands, Windows PowerShell workflows, Windows PowerShell Desired State Configuration (DSC) configurations, or expressions.</source>
          <target state="translated">Windows PowerShell-Debugger können Sie untersuchen und Fehler und Ineffizienzen in Ihre Skripts, Funktionen, Befehle, Windows PowerShell-Workflows, Windows PowerShell Desired State Configuration (DSC) Konfigurationen oder Ausdrücke identifizieren.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, the Windows PowerShell debugger has been updated to debug scripts, functions, workflows, commands, configurations, or expressions that are running in either the console or Windows PowerShell ISE on remote computers.</source>
          <target state="translated">Ab Windows PowerShell 5.0, Windows PowerShell-Debugger wurden zum Debuggen von Skripts, Funktionen, Workflows, Befehle, Konfigurationen oder Ausdrücke, die in der Verwaltungskonsole oder mit Windows PowerShell ISE auf Remotecomputern ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can run Enter-PSSession to start an interactive remote PowerShell session in which you can set breakpoints and debug script files and commands on the remote computer.</source>
          <target state="translated">Sie können die Enter-PSSession, um eine interaktive remote PowerShell-Sitzung starten, in der Sie Haltepunkte festlegen und Debuggen von Skriptdateien und Befehle auf dem Remotecomputer, ausführen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running a script or command on a remote computer.</source>
          <target state="translated">Enter-PSSession-Funktionalität wurde aktualisiert, mit denen Sie erneut eine Verbindung herstellen und geben Sie eine getrennte Sitzung, die ein Skript oder Befehl auf einem Remotecomputer ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">Wenn die Ausführung des Skripts einen Haltepunkt erreicht, wird der Debugger automatisch von der Clientsitzung gestartet.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the disconnected session that is running a script has already hit a breakpoint, and is stopped at the breakpoint, Enter-PSSession automatically starts the command-line debugger, after you reconnect to the session.</source>
          <target state="translated">Wenn die getrennte Sitzung, die ein Skript ausgeführt wird bereits einen Haltepunkt erreicht wurde und am Haltepunkt beendet wird, startet Enter-PSSession automatisch Befehlszeilendebugger, nachdem Sie der Sitzung herzustellen.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can also be used to debug Windows PowerShell workflows, in either the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Windows PowerShell-Debugger kann auch verwendet werden, zum Debuggen von Windows PowerShell-Workflows, die in der Windows PowerShell-Konsole oder in Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can debug within running jobs or processes, either locally or remotely.</source>
          <target state="translated">Ab Windows PowerShell 5.0 können Sie Debuggen innerhalb der Aufträge oder Prozesse ausgeführt, entweder lokal oder Remote.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use the features of the Windows PowerShell debugger to examine a Windows PowerShell script, function, command, workflow, or expression while it is running.</source>
          <target state="translated">Die Funktionen von Windows PowerShell-Debugger können Sie ein Windows PowerShell-Skript, Funktion, Befehl, Workflows oder Ausdruck untersuchen, während er ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger includes a set of cmdlets that let you set breakpoints, manage breakpoints, and view the call stack.</source>
          <target state="translated">Windows PowerShell-Debugger enthält eine Reihe von Cmdlets, mit denen Sie Haltepunkte festlegen, Verwalten von Haltepunkten und die Aufrufliste anzeigen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Debugger Cmdlets The Windows PowerShell debugger includes the following set of cmdlets:</source>
          <target state="translated">Debugger-Cmdlets der Windows PowerShell-Debugger enthält die folgenden Cmdlets:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Set-PsBreakpoint:     Sets breakpoints on lines, variables, and commands.</source>
          <target state="translated">Set-PsBreakpoint: Legt Haltepunkte für Zeilen, Variablen und Befehle fest.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Get-PsBreakpoint:     Gets breakpoints in the current session.</source>
          <target state="translated">Get-PsBreakpoint: Ruft die Haltepunkte in der aktuellen Sitzung ab.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint: Turns off breakpoints in the current session.</source>
          <target state="translated">Disable-PsBreakpoint: Deaktiviert die Haltepunkte in der aktuellen Sitzung.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enable-PsBreakpoint:  Re-enables breakpoints in the current session.</source>
          <target state="translated">Enable-PsBreakpoint: Haltepunkte in der aktuellen Sitzung erneut aktiviert.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Remove-PsBreakpoint:  Deletes breakpoints from the current session.</source>
          <target state="translated">Remove-PsBreakpoint: Löscht Haltepunkte aus der aktuellen Sitzung.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Get-PsCallStack:      Displays the current call stack.</source>
          <target state="translated">Get-PsCallStack: Zeigt die aktuelle Aufrufliste an.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Starting and Stopping the Debugger To start the debugger, set one or more breakpoints.</source>
          <target state="translated">Starten und beenden den Debugger an den Debugger starten, einen oder mehrere Haltepunkte festlegen.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Then, run the script, command, or function that you want to debug.</source>
          <target state="translated">Führen Sie dann das Skript, Befehl oder Funktion, die Sie debuggen möchten.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When you reach a breakpoint, execution stops, and control is turned over to the debugger.</source>
          <target state="translated">Wenn Sie einen Haltepunkt angehalten und Steuerelement erreichen werden an den Debugger Supportgruppen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To stop the debugger, run the script, command, or function until it is complete.</source>
          <target state="translated">Um den Debugger zu beenden, führen Sie das Skript, Befehl oder Funktion bis zum Abschluss.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Or, type "stop" or "t".</source>
          <target state="translated">Oder geben Sie "Beenden" oder "t".</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Debugger Commands When you use the debugger in the Windows PowerShell console, use the following commands to control the execution.</source>
          <target state="translated">Debugger-Befehle, wenn Sie den Debugger in Windows PowerShell-Konsole verwenden, verwenden Sie die folgenden Befehle, um die Ausführung steuern.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell ISE, use commands on the Debug menu.</source>
          <target state="translated">Verwenden Sie in Windows PowerShell ISE Befehle im Menü Debuggen.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note: For information about how to use the debugger in other host applications, see the host application documentation.</source>
          <target state="translated">Hinweis: Informationen zum Verwenden des Debuggers in andere hostanwendungen finden Sie unter der Dokumentation der Host-Anwendung.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>s, Step-into        Executes the next statement and then stops.</source>
          <target state="translated">s, führt Einzelschritt, die nächste Anweisung und dann beendet.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>v, Step-over        Executes the next statement, but skips functions and invocations.</source>
          <target state="translated">V Prozedurschritten führt die nächste Anweisung, überspringt jedoch Funktionen und aufrufen.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Die übersprungenen Anweisungen werden ausgeführt, aber nicht in Einzelschritten durchlaufen.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Ctrl+Break (Break All in ISE)  Breaks into a running script within either the Windows PowerShell console, or Windows PowerShell ISE.</source>
          <target state="translated">STRG + UNTBR (Alle unterbrechen in ISE) Seitenumbrüche in einem ausgeführten Skript innerhalb der Windows PowerShell-Konsole oder einem Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that Ctrl+Break in Windows PowerShell 2.0, 3.0, and 4.0 closes the program.</source>
          <target state="translated">Beachten Sie, dass STRG + UNTBR in WindowsPowerShell 2.0, 3.0 und 4.0 die Anwendung geschlossen wird.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Break All works on both local and remote interactively-running scripts.</source>
          <target state="translated">Unterbrechen Sie alles funktioniert sowohl lokale als auch interaktiv ausgeführte Skripts.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>o, Step-out         Steps out of the current function; up one level if nested.</source>
          <target state="translated">o, Schritt ausgehend von Schritten aus der aktuellen Funktion; eine Ebene höher geschachtelte.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If in the main body, it continues to the end or the next breakpoint.</source>
          <target state="translated">Wenn im Hauptteil, wird weiterhin das Ende oder zum nächsten Haltepunkt.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Die übersprungenen Anweisungen werden ausgeführt, aber nicht in Einzelschritten durchlaufen.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>c, Continue         Continues to run until the script is complete or until the next breakpoint is reached.</source>
          <target state="translated">c weiterhin weiterhin ausgeführt, bis das Skript abgeschlossen ist oder bis zum nächste Haltepunkt erreicht wird.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Die übersprungenen Anweisungen werden ausgeführt, aber nicht in Einzelschritten durchlaufen.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>l, List             Displays the part of the script that is executing.</source>
          <target state="translated">l, zeigt die Liste den Teil des Skripts, das ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, it displays the current line, five previous lines, and 10 subsequent lines.</source>
          <target state="translated">Standardmäßig wird die aktuelle Zeile und fünf vorherigen Zeilen 10 nachfolgenden Zeilen.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To continue listing the script, press ENTER.</source>
          <target state="translated">Drücken Sie die EINGABETASTE, um den Vorgang fortzusetzen, das Skript auflisten.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph>, List         Displays 16 lines of the script beginning with the line number specified by <ph id="ph2">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph>, Liste zeigt 16 Zeilen des Skripts Anfangs mit der angegebenen Zeilennummer <ph id="ph2">&lt;m&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, List     Displays <ph id="ph3">&lt;n&gt;</ph> lines of the script, beginning with the line number specified by <ph id="ph4">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, zeigt die <ph id="ph3">&lt;n&gt;</ph> Skriptzeilen, beginnend mit der angegebenen Zeilennummer <ph id="ph4">&lt;m&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>q, Stop, Exit       Stops executing the script, and exits the debugger.</source>
          <target state="translated">Q, beenden, beenden-beendet das Skript, und beendet den Debugger.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you are debugging a job by running the Debug-Job cmdlet, the Exit command detaches the debugger, and allows the job to continue running.</source>
          <target state="translated">Wenn Sie einen Auftrag von der Debug-Job-Cmdlet ausführen, Debuggen, der Befehl Exit trennt den Debugger und ermöglicht dem Auftrag, um die Ausführung fortzusetzen.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>k, Get-PsCallStack  Displays the current call stack.</source>
          <target state="translated">k "," Get-PsCallStack zeigt die aktuelle Aufrufliste.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Repeats the last command if it was Step (s), Step-over (v), or List (l).</source>
          <target state="translated">Wiederholt den letzten Befehl, wenn sie Schritt (s), Prozedurschritten (V) oder eine Liste (l) war.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, represents a submit action.</source>
          <target state="translated">Andernfalls stellt absenden.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>?, h                Displays the debugger command Help.</source>
          <target state="translated">?, h zeigt der Debuggerbefehl Hilfe.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To exit the debugger, you can use Stop (q).</source>
          <target state="translated">Um den Debugger zu beenden, können Sie beenden (Q).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can run the Exit command to exit a nested debugging session that you started by running either Debug-Job or Debug-Runspace.</source>
          <target state="translated">Ab Windows PowerShell 5.0, können Sie den Befehl Exit, um eine geschachtelte Debugsitzung zu beenden, die Sie gestartet mit Debug-Job oder Debug-Runspace ausführen.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By using these debugger commands, you can run a script, stop on a point of concern, examine the values of variables and the state of the system, and continue running the script until you have identified a problem.</source>
          <target state="translated">Mithilfe dieser Debuggerbefehle können Sie ein Skript ausführen, beenden auf einen Punkt von Bedeutung, überprüfen Sie die Werte von Variablen und den Zustand des Systems und weiterhin das Skript ausgeführt, bis Sie ein Problem ermittelt haben.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>NOTE:  If you step into a statement with a redirection operator, such as "&gt;", the Windows PowerShell debugger steps over all remaining statements in the script.</source>
          <target state="translated">HINWEIS: Wenn Sie sich in einer Anweisung mit einem Umleitungsoperator wie z. B. "&gt;", die Windows PowerShell-Debugger überspringt alle verbleibenden Anweisungen im Skript.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Displaying the Values of script Variables</source>
          <target state="translated">Anzeigen der Werte von Variablen-Skript</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>While you are in the debugger, you can also enter commands, display the value of variables, use cmdlets, and run scripts at the command line.</source>
          <target state="translated">Während Sie im Debugger befinden, können Sie auch Befehle eingeben, zeigt den Wert der Variablen, verwenden Sie Cmdlets und Skripts in der Befehlszeile ausführen.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can display the current value of all variables in the script that is being debugged, except for the following automatic variables:</source>
          <target state="translated">Sie können den aktuellen Wert aller Variablen im Skript anzeigen, die, mit Ausnahme der folgenden automatischen Variablen im Debugmodus befindet:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>$Args $Input $MyInvocation $PSBoundParameters</source>
          <target state="translated">$Args $Input $MyInvocation $PSBoundParameters</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you try to display the value of any of these variables, you get the value of that variable for in an internal pipeline the debugger uses, not the value of the variable in the script.</source>
          <target state="translated">Wenn Sie den Wert von einer dieser Variablen anzeigen, erhalten Sie den Wert, den diese Variablen für eine interne, vom Debugger verwendete Pipeline hat, nicht den Wert der Variablen im Skript.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To display the value these variables for the script that is being debugged, in the script, assign the value of the automatic variable to a new variable.</source>
          <target state="translated">Weisen Sie den Wert der automatischen Variablen einer neuen Variable, um den Wert dieser Variablen für das Skript, das gedebuggt wird, in das Skript anzuzeigen.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Then you can display the value of the new variable.</source>
          <target state="translated">Anschließend können Sie den Wert der neuen Variablen anzeigen.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Beispiel:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>$scriptArgs = $Args $scriptArgs</source>
          <target state="translated">$scriptArgs = $Args $scriptArgs</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the example in this topic, the value of the $MyInvocation variable is reassigned as follows:</source>
          <target state="translated">Im Beispiel in diesem Thema wird der Wert der Variablen $MyInvocation wie folgt zugewiesen:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Debugger Environment When you reach a breakpoint, you enter the debugger environment.</source>
          <target state="translated">Die Debugger-Umgebung bei der Sie einen Haltepunkt erreicht, geben Sie die Debugger-Umgebung.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The command prompt changes so that it begins with "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</source>
          <target state="translated">Die Befehlszeile wird geändert, sodass er mit beginnt "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you are debugging a workflow, the prompt is "[WFDBG]".</source>
          <target state="translated">Wenn Sie einen Workflow Debuggen, wird die Meldung "[WFDBG]".</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can customize the prompt.</source>
          <target state="translated">Sie können die Meldung anpassen.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, in some host applications, such as the Windows PowerShell console, (but not in Windows PowerShell Integrated Scripting Environment [ISE]), a nested prompt opens for debugging.</source>
          <target state="translated">Darüber hinaus einige Host-Objekte, z. B. der Windows PowerShell-Konsole (jedoch nicht in Windows PowerShell Integrated Scripting Environment [ISE]) wird eine geschachtelte Aufforderung für das Debuggen geöffnet.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can detect the nested prompt by the repeating greater-than characters (ASCII 62) that appear at the command prompt.</source>
          <target state="translated">Sie können geschachtelte Aufforderung erkennen, indem Sie die wiederholte größer-als Zeichen (ASCII-62), die in der Befehlszeile angezeigt werden.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, the following is the default debugging prompt in the Windows PowerShell console:</source>
          <target state="translated">Folgendes ist z. B. Debuggen Aufforderung in Windows PowerShell-Konsole standardmäßig:</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can find the nesting level by using the $NestedPromptLevel automatic variable.</source>
          <target state="translated">Sie finden die Schachtelungsebene mithilfe der automatischen $NestedPromptLevel-Variablen.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Additionally, an automatic variable, $PSDebugContext, is defined in the local scope.</source>
          <target state="translated">Darüber hinaus wird eine automatische Variable, $PSDebugContext, im lokalen Gültigkeitsbereich definiert.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use the presence of the $PsDebugContext variable to determine whether you are in the debugger.</source>
          <target state="translated">Das Vorhandensein der $PsDebugContext-Variablen können Sie bestimmen, ob Sie sich im Debugger befinden.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Beispiel:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>if ($psdebugcontext) {"Debugging"} else {"Not Debugging"}</source>
          <target state="translated">Wenn ($psdebugcontext) {"Debuggen"} else {"nicht Debugging"}</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the value of the $PSDebugContext variable in your debugging.</source>
          <target state="translated">Sie können den Wert der Variablen $PSDebugContext in Debuggen.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Name   CommandLineParameters  UnboundArguments  Location</source>
          <target state="translated">Name CommandLineParameters UnboundArguments Verzeichnis</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>=      {}                     {}                C:\ps-test\vote.ps1 (1)</source>
          <target state="translated">= {{}} C:\ps-test\vote.ps1 (1)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Debugging and Scope Breaking into the debugger does not change the scope in which you are operating, but when you reach a breakpoint in a script, you move into the script scope.</source>
          <target state="translated">Debuggen und Bereich Debuggerunterbrechung ändert nicht den Bereich, in dem Sie arbeiten, aber wenn Sie einen Haltepunkt in einem Skript erreichen, verschieben Sie in den Skriptbereich.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The script scope is a child of the scope in which you ran the debugger.</source>
          <target state="translated">Der Skriptbereich ist ein untergeordnetes Element des Bereichs, in dem den Debugger ausgeführt wurde.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To find the variables and aliases that are defined in the script scope, use the Scope parameter of the Get-Alias or Get-Variable cmdlets.</source>
          <target state="translated">Um finden die Variablen und Aliase, die in den Skriptbereich definiert sind, verwenden Sie den Scope-Parameter, der die Cmdlets Get-Alias oder Get-Variable.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the variables in the local (script) scope:</source>
          <target state="translated">Beispielsweise ruft der folgende Befehl die Variablen im Bereich lokale (Skript):</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>get-variable -scope 0</source>
          <target state="translated">Get-Variable - Bereich von 0</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">Sie können den Befehl wie folgt abkürzen:</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>gv -s 0</source>
          <target state="translated">GV -s-0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is a useful way to see only the variables that you defined in the script and that you defined while debugging.</source>
          <target state="translated">Dies ist eine hilfreiche Möglichkeit, nur die Variablen, die Sie in das Skript definiert und, die Sie während des Debuggens definiert.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Debugging at the Command Line When you set a variable breakpoint or a command breakpoint, you can set the breakpoint only in a script file.</source>
          <target state="translated">Debuggen an der Befehlszeile aus, wenn Sie eine Variable Haltepunkt oder einen befehlshaltepunkt festlegen, können Sie den Haltepunkt festlegen, nur in einer Skriptdatei.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, by default, the breakpoint is set on anything that runs in the current session.</source>
          <target state="translated">Allerdings wird standardmäßig der Haltepunkt auf nichts festgelegt, die in der aktuellen Sitzung ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if you set a breakpoint on the $name variable, the debugger breaks on any $name variable in any script, command, function, script cmdlet or expression that you run until you disable or remove the breakpoint.</source>
          <target state="translated">Wenn Sie einem Haltepunkt in der Variablen $name, unterbricht der Debugger, auf alle Variablen $name in Skripts, Befehl, Funktion, Skript-Cmdlet oder Ausdruck gesetzt haben, führen Sie z. B. bis deaktivieren oder entfernen Sie den Haltepunkt.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This allows you to debug your scripts in a more realistic context in which they might be affected by functions, variables, and other scripts in the session and in the user's profile.</source>
          <target state="translated">Dadurch können Sie zum Debuggen von Skripts in einem realistischeren Kontext, in dem sie von Funktionen, Variablen und anderen Skripts in der Sitzung und in das Benutzerprofil betroffen sein könnten.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Line breakpoints are specific to script files, so they are set only in script files.</source>
          <target state="translated">Zeile Haltepunkte sind spezifisch für Skriptdateien, damit diese nur in Skriptdateien festgelegt werden.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Debugging Workflows The Windows PowerShell 4.0 debugger can be used to debug Windows PowerShell workflows, either in the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Debuggen von Workflows der Windows PowerShell 4.0 kann Debugger zum Debuggen von Windows PowerShell-Workflows, entweder in der Windows PowerShell-Konsole oder in Windows PowerShell ISE verwendet werden.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There are some limitations with using the Windows PowerShell debugger to debug workflows.</source>
          <target state="translated">Es gibt einige Einschränkungen bei Verwendung von Windows PowerShell-Debugger zum Debuggen von Workflows.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>-- You can view workflow variables while you are in the debugger, but setting workflow variables from within the debugger is not supported.</source>
          <target state="translated">--Sie können die Workflow-Variablen anzeigen, während Sie im Debugger sind, Festlegen von Workflow-Variablen innerhalb des Debuggers wird jedoch nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>-- Tab completion when stopped in the workflow debugger is not available.</source>
          <target state="translated">--Die Vervollständigung mittels Tabulatortaste im Workflowdebugger beendet ist nicht verfügbar.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>-- Workflow debugging works only with synchronous running of workflows from a Windows PowerShell script.</source>
          <target state="translated">– Debuggen von Workflows funktioniert nur mit synchronen Ausführung von Workflows von Windows PowerShell-Skript.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot debug workflows if they are running as a job (with the –AsJob parameter).</source>
          <target state="translated">Sie können Workflows nicht debuggen, wenn sie (mit dem – AsJob-Parameter) als Auftrag ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-- Other nested debugging scenarios--such as a workflow calling another workflow, or a workflow calling a script--are not implemented.</source>
          <target state="translated">--Andere geschachtelte Debugszenarios – z. B. eine Workflow-Aufruf eines anderen Workflows oder eines Workflows zum Aufrufen eines Skripts – sind nicht implementiert.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example demonstrates debugging a workflow.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht das Debuggen eines Workflows.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that when the debugger steps into the workflow function, the debugger prompt changes to [WFDBG].</source>
          <target state="translated">Beachten Sie, dass, wenn der Debugger führt die Workflow-Funktion, die Debugger-Aufforderung in [WFDBG] geändert wird.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Set-PSBreakpoint -Script C:\TestWFDemo1.ps1 -Line 8</source>
          <target state="translated">PS C: &gt; Set-PSBreakpoint-Skript C:\TestWFDemo1.ps1-Zeile 8</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ID Script           Line Command    Variable     Action</source>
          <target state="translated">ID Befehlszeile Variable Skriptaktion</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>0 TestWFDemo1.ps1   8</source>
          <target state="translated">0 TestWFDemo1.ps1 8</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>PS C:&gt; C:\TestWFDemo1.ps1 Entering debug mode.</source>
          <target state="translated">PS C: &gt; Debugmodus C:\TestWFDemo1.ps1 eingeben.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Verwenden Sie h oder?</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Hilfe zu erhalten.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\TestWFDemo1.ps1:8'</source>
          <target state="translated">Haltepunkt Zeile auf 'C:\TestWFDemo1.ps1:8'</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>At C:\TestWFDemo1.ps1:8 char:5</source>
          <target state="translated">Bei C:\TestWFDemo1.ps1:8 Char: 5</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Now writing output:"</source>
          <target state="translated">Write-Output - InputObject "jetzt Schreiben der Ausgabe:"</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~</source>
          <target state="translated">+! [] ENTHALTEN ~ ~ ~</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>3:</source>
          <target state="translated">3:</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: Workflow SampleWorkflowTest 5: {6: Param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>8:*     Write-Output -InputObject "Now writing output:" 9:      Write-Output -Input $MyOutput</source>
          <target state="translated">8: * Write-Output - InputObject "jetzt Schreiben der Ausgabe:" 9: Write-Output - Eingabe $MyOutput</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-Output - InputObject "Abrufen von PowerShell-Prozess:" 12: Get-Process - Namen Powershell</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-Output - InputObject "Workflow-Funktion abgeschlossen."</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # Workflowfunktion 18: SampleWorkflowTest - MyOutput "Hello"</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">Hallo</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Now writing output: At C:\TestWFDemo1.ps1:9 char:5</source>
          <target state="translated">Jetzt Schreiben der Ausgabe: am C:\TestWFDemo1.ps1:9 Char: 5</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Write-Output -Input $MyOutput</source>
          <target state="translated">Write-Output - Eingabe $MyOutput</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~</source>
          <target state="translated">+! [] ENTHALTEN ~</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: Workflow SampleWorkflowTest 5: {6: Param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>8:      Write-Output -InputObject "Now writing output:" 9:*     Write-Output -Input $MyOutput</source>
          <target state="translated">8: Write-Output - InputObject "jetzt Schreiben der Ausgabe:" 9: * Write-Output - Eingabe $MyOutput</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-Output - InputObject "Abrufen von PowerShell-Prozess:" 12: Get-Process - Namen Powershell</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-Output - InputObject "Workflow-Funktion abgeschlossen."</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # Workflowfunktion 18: SampleWorkflowTest - MyOutput "Hello"</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Hello At C:\TestWFDemo1.ps1:11 char:5</source>
          <target state="translated">Hello am C:\TestWFDemo1.ps1:11 Char: 5</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Get PowerShell process:"</source>
          <target state="translated">Write-Output - InputObject "Abrufen von PowerShell-Prozess:"</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~</source>
          <target state="translated">+! [] ENTHALTEN ~ ~ ~</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Get PowerShell process:</source>
          <target state="translated">Rufen Sie die PowerShell-Prozess:</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)   WS(K) VM(M)   CPU(s)     Id ProcessName    PSComputerName</source>
          <target state="translated">Npm(k): PM(k): ws(k): VM(m): CPU(s) Id Prozessname PSComputerName behandelt</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>433      35   106688   128392   726     2.67   7124 powershell    localhost 499      44   134244   172096   787     2.79   7452 powershell    localhost Workflow function complete.</source>
          <target state="translated">433 35 106688 128392 726 2,67 7124 Powershell Localhost 499 44 134244 172096 787 2.79 7452 Powershell Localhost Workflowfunktion abgeschlossen.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Debugging Functions When you set a breakpoint on a function that has Begin, Process, and End sections, the debugger breaks at the first line of each section.</source>
          <target state="translated">Debuggen von Funktionen, wenn Sie einen Haltepunkt in einer Funktion festlegen, die Begin, Process und End-Abschnitte verfügt, unterbricht der Debugger bei der ersten Zeile des Abschnitts.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Beispiel:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>function test-cmdlet { begin { write-output "Begin" } process { write-output "Process" } end { write-output "End" } }</source>
          <target state="translated">Test-Cmdlet, Funktion {beginnen {Write-Output "Begin"} {Write-Output "Prozess"} Prozessende {Write-Output "End"}}</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; set-psbreakpoint -command test-cmdlet</source>
          <target state="translated">C:\PS &gt; Set-Psbreakpoint-Test-Cmdlet-Befehl</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; test-cmdlet</source>
          <target state="translated">C:\PS &gt; Test-Cmdlet</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Begin Entering debug mode.</source>
          <target state="translated">Debugmodus Eingabe beginnen.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Verwenden Sie h oder?</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Hilfe zu erhalten.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Befehl Haltepunkt auf "Aufforderung: Test-Cmdlet"</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">Test-cmdlet</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Process Entering debug mode.</source>
          <target state="translated">Prozess Entering Debug-Modus.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Verwenden Sie h oder?</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Hilfe zu erhalten.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Befehl Haltepunkt auf "Aufforderung: Test-Cmdlet"</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">Test-cmdlet</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Entering debug mode.</source>
          <target state="translated">End Entering Debug-Modus.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Verwenden Sie h oder?</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Hilfe zu erhalten.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Befehl Haltepunkt auf "Aufforderung: Test-Cmdlet"</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">Test-cmdlet</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;</source>
          <target state="translated"><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS &gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Debugging Remote Scripts Starting in Windows PowerShell 5.0, you can run the Windows PowerShell debugger in a remote session, in either the console, or Windows PowerShell ISE.</source>
          <target state="translated">Debuggen von Skripts in Windows PowerShell 5.0 starten, können Sie Windows PowerShell-Debugger in einer Remotesitzung in der Konsole oder einem Windows PowerShell ISE ausführen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running on a remote computer, and currently running a script.</source>
          <target state="translated">Enter-PSSession-Funktionalität wurde aktualisiert, mit denen Sie erneut eine Verbindung herstellen und geben Sie eine getrennte Sitzung, die auf einem Remotecomputer ausgeführt wird, und zurzeit ein Skript ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">Wenn die Ausführung des Skripts einen Haltepunkt erreicht, wird der Debugger automatisch von der Clientsitzung gestartet.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following is an example that shows how this works, with breakpoints set in a script at lines 6, 11, 22, and 25.</source>
          <target state="translated">Im folgenden finden ein Beispiel, Haltepunkte in einem Skript auf 6, 11, 22 und 25 Zeilen Funktionsweise mit.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Note that in the example, when the debugger starts, there are two identifying prompts: the name of the computer on which the session is running, and the DBG prompt that lets you know you are in debugging mode.</source>
          <target state="translated">Beachten Sie, dass im Beispiel beim Starten des Debuggers identifizierende geschehen: der Name des Computers, auf dem die Sitzung ausgeführt wird, und die DBG-Aufforderung, mit dem Sie wissen Sie sich im Debugmodus befinden.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Enter-Pssession -Cn localhost</source>
          <target state="translated">Enter-Pssession - Cn "localhost"</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>ID Script          Line     Command          Variable          Action</source>
          <target state="translated">ID Befehlszeile Variable Skriptaktion</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0 ttest19.ps1          6 1 ttest19.ps1          11 2 ttest19.ps1          22 3 ttest19.ps1          25</source>
          <target state="translated">0 ttest19.ps1 6 1 ttest19.ps1 11 2 ttest19.ps1 22 3 ttest19.ps1 25</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\psscripts\ttest19.ps1:11'</source>
          <target state="translated">Haltepunkt Zeile auf 'C:\psscripts\ttest19.ps1:11'</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:11 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:11 Char: 1</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>$winRMName = "WinRM"</source>
          <target state="translated">$winRMName = "WinRM"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>6:      1..5 | foreach { sleep 1; Write-Output "hello2day $_" } 7:  }</source>
          <target state="translated">6: 1..5 | Foreach {Energiesparmodus 1; Write-Output "hello2day $_"} 7:}</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>8:</source>
          <target state="translated">8:</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>9:  $count = 10 10:  $psName = "PowerShell" 11:* $winRMName = "WinRM" 12:  $myVar = 102</source>
          <target state="translated">9: $count = 10 10: $psName = "PowerShell" 11: * $winRMName = "WinRM" 12: $myVar = 102</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>14:  for ($i=0; $i -lt $count; $i++) 15:  { 16:      sleep 1 17:      Write-Output "Loop iteration is: $i" 18:      Write-Output "MyVar is $myVar"</source>
          <target state="translated">14: für ($i = 0; $count $i - Lt; $i++) 15: {16: sleep 17 1: Write-Output "Durchlauf der Schleife wird: $i" 18: Write-Output "MyVar ist $myVar"</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>20:      hello2day</source>
          <target state="translated">20: hello2day</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>21:</source>
          <target state="translated">21:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:12 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:12 Char: 1</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>$myVar = 102</source>
          <target state="translated">$myVar = 102</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">"localhost"</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>PS C:\psscripts&gt;</source>
          <target state="translated">PS C:\psscripts &gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Examples This test script detects the version of the operating system and displays a system-appropriate message.</source>
          <target state="translated">Beispiele für dieses Testskript ermittelt die Version des Betriebssystems und eine System entsprechende Meldung angezeigt.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It includes a function, a function call, and a variable.</source>
          <target state="translated">Sie enthält eine Funktion, einen Funktionsaufruf und eine Variable.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following command displays the contents of the test script file:</source>
          <target state="translated">Der folgende Befehl zeigt den Inhalt der testskriptdatei:</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>c:&gt;\PS-test&gt;  get-content test.ps1</source>
          <target state="translated">c: &gt; \PS-test &gt; Get-Content-test.ps1</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>function psversion { "Windows PowerShell " + $psversiontable.psversion if ($psversiontable.psversion.major -lt 2) { "Upgrade to Windows PowerShell 2.0!"</source>
          <target state="translated">Funktion Psversion {"WindowsPowerShell" + $psversiontable.psversion Wenn (2 $psversiontable.psversion.major - Lt) {"Upgrade auf WindowsPowerShell 2.0!"</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>} else { "Have you run a background job today (start-job)?"</source>
          <target state="translated">} else {"haben Sie führen einen Hintergrundauftrag heute (Start-Job)?"</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>} }</source>
          <target state="translated">} }</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path psversion "Done $scriptname."</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path Psversion "$scriptname Fertig".</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To start, set a breakpoint at a point of interest in the script, such as a line, command, variable, or function.</source>
          <target state="translated">Um zu starten, legen Sie einen Haltepunkt an einem Punkt in der Skripts, z. B. eine Zeile, einen Befehl, eine Variable oder eine Funktion von Interesse.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Start by creating a line breakpoint on the first line of the Test.ps1 script in the current directory.</source>
          <target state="translated">Zunächst erstellen einen Zeilenhaltepunkt in der ersten Zeile der ps1 im aktuellen Verzeichnis.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -line 1 -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-Psbreakpoint-Zeile 1 - Skript test.ps1</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">Sie können diesen Befehl wie folgt abkürzen:</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; spb 1 -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Spb 1 -s test.ps1</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The command returns a line-breakpoint object (System.Management.Automation.LineBreakpoint).</source>
          <target state="translated">Der Befehl gibt einen Zeilenhaltepunkt Objekt (System.Management.Automation.LineBreakpoint).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Column     : 0 Line       : 1 Action     : Enabled    : True HitCount   : 0 Id         : 0 Script     : C:\ps-test\test.ps1 ScriptName : C:\ps-test\test.ps1</source>
          <target state="translated">Spalte: 0-Zeile: 1 Aktion: aktiviert: True Trefferanzahl: Id 0: 0-Skript: C:\ps-test\test.ps1 Skriptname: C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">Starten Sie nun das Skript ein.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When the script reaches the first breakpoint, the breakpoint message indicates that the debugger is active.</source>
          <target state="translated">Wenn das Skript den ersten Haltepunkt erreicht wird, gibt die Haltepunkt-Meldung, dass der Debugger aktiviert ist.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It describes the breakpoint and previews the first line of the script, which is a function declaration.</source>
          <target state="translated">Es beschreibt den Haltepunkt und zeigt eine Vorschau die erste Zeile des Skripts, die eine Funktionsdeklaration ist.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The command prompt also changes to indicate that the debugger has control.</source>
          <target state="translated">Um anzugeben, dass der Debugger Steuerelement ändert sich auch die Befehlszeile.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The preview line includes the script name and the line number of the previewed command.</source>
          <target state="translated">Die Vorschau-Zeile enthält den Namen des Skripts und die Zeilennummer des Befehls in der Vorschau angezeigt.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Entering debug mode.</source>
          <target state="translated">Geben den Debugmodus.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Verwenden Sie h oder?</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Hilfe zu erhalten.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\ps-test\test.ps1:1'</source>
          <target state="translated">Haltepunkt Zeile auf 'C:\ps-test\test.ps1:1'</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>test.ps1:1   function psversion {</source>
          <target state="translated">Test.ps1:1-Funktion Psversion {}</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Use the Step command (s) to execute the first statement in the script and to preview the next statement.</source>
          <target state="translated">Verwenden Sie die erste Anweisung im Skript ausgeführt und die nächste Anweisung Vorschau der Schrittbefehl (s).</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The next statement uses the $MyInvocation automatic variable to set the value of the $ScriptName variable to the path and file name of the script file.</source>
          <target state="translated">Die nächste Anweisung verwendet die automatische $MyInvocation-Variable den Wert der Variablen $ScriptName in den Pfad und Namen der Skriptdatei festlegen.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:11  $scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">DBG &gt; s test.ps1:11 $scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is not populated, but you can verify the value of the variable by displaying its value.</source>
          <target state="translated">An diesem Punkt die $ScriptName-Variable wird nicht aufgefüllt, aber Sie können den Wert der Variablen überprüfen, des Werts angezeigt.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In this case, the value is $null.</source>
          <target state="translated">In diesem Fall ist der Wert $null.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Use another Step command (s) to execute the current statement and to preview the next statement in the script.</source>
          <target state="translated">Verwenden Sie einen anderen Befehl (s) zur Ausführung der aktuellen Anweisung und eine Vorschau die nächste Anweisung im Skript.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The next statement calls the PsVersion function.</source>
          <target state="translated">Die nächste Anweisung ruft die PsVersion-Funktion.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 Psversion</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is populated, but you verify the value of the variable by displaying its value.</source>
          <target state="translated">An diesem Punkt wird die Variable $ScriptName aufgefüllt, aber Sie überprüfen den Wert der Variablen des Werts angezeigt.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>In this case, the value is set to the script path.</source>
          <target state="translated">In diesem Fall wird der Wert auf den Pfad festgelegt.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Use another Step command to execute the function call.</source>
          <target state="translated">Verwenden Sie einen anderen Befehl, um den Funktionsaufruf auszuführen.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Press ENTER, or type "s" for Step.</source>
          <target state="translated">Drücken Sie die EINGABETASTE, oder geben Sie "s" für Schritt.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:2       "Windows PowerShell " + $psversiontable.psversion</source>
          <target state="translated">DBG &gt; s test.ps1:2 "WindowsPowerShell" + $psversiontable.psversion</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The debug message includes a preview of the statement in the function.</source>
          <target state="translated">Die Debug-Nachricht enthält eine Vorschau der Anweisung in der Funktion.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To execute this statement and to preview the next statement in the function, you can use a Step command.</source>
          <target state="translated">Um diese Anweisung ausführen und die nächste Anweisung in der Funktion der Vorschau anzeigen, können Sie einen Befehl.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But, in this case, use a Step-Out command (o).</source>
          <target state="translated">In diesem Fall verwenden Sie jedoch einen Schritt Out-Befehl (o).</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It completes the execution of the function (unless it reaches a breakpoint) and steps to the next statement in the script.</source>
          <target state="translated">(Es sei denn, ein Haltepunkt erreicht) führt die Ausführung der Funktion und Schritte für die nächste Anweisung im Skript.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>DBG&gt; o Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; o Windows PowerShell 2.0 ist heute einen Hintergrundauftrag (Start-Job) ausführen?</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">Test.ps1:13 "$scriptname Fertig"</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Because we are on the last statement in the script, the Step, Step-Out, and Continue commands have the same effect.</source>
          <target state="translated">Da wir auf die letzte Anweisung im Skript wird der Schritt sind Schritt horizontaler und Continue-Befehle, die die gleiche Wirkung hat.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In this case, use Step-Out (o).</source>
          <target state="translated">In diesem Fall verwenden Sie Schritt-Out (o).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1 PS C:\ps-test&gt;</source>
          <target state="translated">Fertig C:\ps-test\test.ps1 PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The Step-Out command executes the last command.</source>
          <target state="translated">Der Schritt-Out-Befehl führt mit dem letzten Befehl.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The standard command prompt indicates that the debugger has exited and returned control to the command processor.</source>
          <target state="translated">Der standard-Eingabeaufforderung gibt an, dass der Debugger beendet und Rückgabe der Steuerung an den Befehlsprozessor.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Now, run the debugger again.</source>
          <target state="translated">Führen Sie nun den Debugger erneut.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>First, to delete the current breakpoint, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">Um dem aktuellen Haltepunkt zu löschen, verwenden Sie zunächst die Cmdlets Get-PsBreakpoint "und" Remove-PsBreakpoint.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>(If you think you might reuse the breakpoint, use the Disable-PsBreakpoint cmdlet instead of Remove-PsBreakpoint.)</source>
          <target state="translated">(Wenn Sie, dass Sie den Haltepunkt wieder verwenden können glauben, verwenden Sie das Cmdlet "Disable-PsBreakpoint" Remove-PsBreakpoint.)</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-PsBreakpoint | Remove-PSBreakpoint</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">Sie können diesen Befehl wie folgt abkürzen:</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; gbp | rbp</source>
          <target state="translated">PS C:\ps-test &gt; Gbp | RBP</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Or, run the command by writing a function, such as the following function:</source>
          <target state="translated">Oder führen Sie den Befehl durch Schreiben einer Funktion, z. B. die folgende Funktion:</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>function delbr { gbp | rbp }</source>
          <target state="translated">Funktion Delbr {Gbp | Rbp}</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Now, create a breakpoint on the $scriptname variable.</source>
          <target state="translated">Erstellen Sie jetzt einen Haltepunkt für die $scriptname-Variable.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -variable scriptname -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-Psbreakpoint-Variable Skriptname-Skript test.ps1</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">Sie können den Befehl wie folgt abkürzen:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -v scriptname -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Sbp - V Skriptname -s test.ps1</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">Starten Sie nun das Skript ein.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The script reaches the variable breakpoint.</source>
          <target state="translated">Das Skript erreicht die Variable Haltepunkt.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The default mode is Write, so execution stops just before the statement that changes the value of the variable.</source>
          <target state="translated">Der Standardmodus ist schreiben, damit die Ausführung unmittelbar vor der Anweisung beendet, die den Wert der Variablen ändert.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Variable breakpoint on 'C:\ps-test\test.ps1:$scriptname' (Write access)</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 erreicht variablenhaltepunkt auf 'C:\ps-test\test.ps1:$scriptname' (Schreibzugriff)</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>test.ps1:11  $scriptname = $MyInvocation.mycommand.path</source>
          <target state="translated">Test.ps1:11 $scriptname = $MyInvocation.mycommand.path</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Display the current value of the $scriptname variable, which is $null.</source>
          <target state="translated">Der aktuelle Wert der Variable $scriptname, die $null wird angezeigt.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to execute the statement that populates the variable.</source>
          <target state="translated">Verwenden Sie einen Befehl (s) zum Ausführen der Anweisung, die die Variable aufgefüllt wird.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Then, display the new value of the $scriptname variable.</source>
          <target state="translated">Den neuen Wert der Variablen $scriptname anschließend anzeigen.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to preview the next statement in the script.</source>
          <target state="translated">Verwenden Sie einen Schrittbefehl (s), um eine Vorschau die nächste Anweisung im Skript.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 Psversion</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The next statement is a call to the PsVersion function.</source>
          <target state="translated">Die folgende Anweisung ist ein Aufruf der Funktion PsVersion.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To skip the function but still execute it, use a Step-Over command (v).</source>
          <target state="translated">Die Funktion zu überspringen, sondern weiterhin ausführen, verwenden Sie einen Befehl Zustellung (V).</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>If you are already in the function when you use Step-Over, it is not effective.</source>
          <target state="translated">Wenn Sie bereits in der Funktion sind bei Verwendung von Zustellung, ist es nicht wirksam.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The function call is displayed, but it is not executed.</source>
          <target state="translated">Der Funktionsaufruf wird angezeigt, aber es wird nicht ausgeführt.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>DBG&gt; v Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; V Windows PowerShell 2.0 ist heute einen Hintergrundauftrag (Start-Job) ausführen?</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">Test.ps1:13 "$scriptname Fertig"</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The Step-Over command executes the function, and it previews the next statement in the script, which prints the final line.</source>
          <target state="translated">Die Zustellung-Befehl führt die Funktion, und anschließend wird eine Vorschau der nächsten Anweisung in das Skript, das die letzte Zeile gibt.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use a Stop command (t) to exit the debugger.</source>
          <target state="translated">Verwenden Sie einen Befehl zum Beenden (t), um den Debugger zu beenden.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The command prompt reverts to the standard command prompt.</source>
          <target state="translated">Die Befehlszeile werden in der standard-Befehlszeile.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>C:\ps-test&gt;</source>
          <target state="translated">C:\ps-Test &gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>To delete the breakpoints, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">Verwenden Sie die Cmdlets Get-PsBreakpoint "und" Remove-PsBreakpoint, um die Haltepunkte zu löschen.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-PsBreakpoint | Remove-PSBreakpoint</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Create a new command breakpoint on the PsVersion function.</source>
          <target state="translated">Erstellen Sie einen neuen befehlshaltepunkt für die Funktion PsVersion.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Set-PsBreakpoint -command psversion -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-PsBreakpoint-Befehl Psversion-Skript test.ps1</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command to:</source>
          <target state="translated">Sie können diesen Befehl zu verkürzen:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -c psversion -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Sbp - C Psversion -s test.ps1</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">Führen Sie nun das Skript ein.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 erreicht befehlshaltepunkt auf 'C:\ps-test\test.ps1:psversion'</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">Test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The script reaches the breakpoint at the function call.</source>
          <target state="translated">Das Skript erreicht den Haltepunkt an der Funktionsaufruf.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>At this point, the function has not yet been called.</source>
          <target state="translated">An diesem Punkt hat die Funktion noch nicht aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This gives you the opportunity to use the Action parameter of Set-PsBreakpoint to set conditions for the execution of the breakpoint or to perform preparatory or diagnostic tasks, such as starting a log or invoking a diagnostic or security script.</source>
          <target state="translated">Dies bietet Ihnen die Möglichkeit, den Action-Parameter von Set-PsBreakpoint Vorschriften für die Ausführung des Haltepunkts fest oder vorbereitenden oder Diagnose, z. B. Starten eines Protokolls oder Aufrufen eines Skripts Diagnose- oder Sicherheit Aufgaben verwenden.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>To set an action, use a Continue command (c) to exit the script, and a Remove-PsBreakpoint command to delete the current breakpoint.</source>
          <target state="translated">Um eine Aktion auszuwählen, verwenden Sie einen Befehl weiter (c), um das Skript zu beenden und eine Remove-PsBreakpoint-Befehl aus, um dem aktuellen Haltepunkt zu löschen.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>(Breakpoints are read-only, so you cannot add an action to the current breakpoint.)</source>
          <target state="translated">(Haltepunkte sind schreibgeschützt, damit Sie dem aktuellen Haltepunkt eine Aktion hinzufügen können.)</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>DBG&gt; c Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; C Windows PowerShell 2.0 ist heute einen Hintergrundauftrag (Start-Job) ausführen?</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1</source>
          <target state="translated">Fertig C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; get-psbreakpoint | remove-psbreakpoint PS C:\ps-test&gt;</source>
          <target state="translated">PS C:\ps-test &gt; Get-Psbreakpoint | Remove-Psbreakpoint PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Now, create a new command breakpoint with an action.</source>
          <target state="translated">Erstellen Sie jetzt einen neuen befehlshaltepunkt mit der Aktion.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The following command sets a command breakpoint with an action that logs the value of the $scriptname variable when the function is called.</source>
          <target state="translated">Der folgende Befehl legt einen befehlshaltepunkt mit der Aktion, die den Wert der Variablen $scriptname protokolliert, wenn die Funktion aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Because the Break keyword is not used in the action, execution does not stop.</source>
          <target state="translated">Da das Schlüsselwort "Break" nicht in der Aktion verwendet wird, wird die Ausführung nicht angehalten.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the line-continuation character.)</source>
          <target state="translated">(Das Hochkomma (') ist das Zeilenfortsetzungszeichen.)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -command psversion -script test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname is $scriptname."</source>
          <target state="translated">PS C:\ps-test &gt; Set-Psbreakpoint-Befehl Psversion-Skript test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname $scriptname ist. "</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>` -path action.log}</source>
          <target state="translated">-Pfad action.log}</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can also add actions that set conditions for the breakpoint.</source>
          <target state="translated">Sie können auch Aktionen hinzufügen, die Bedingung für den Haltepunkt festgelegt.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>In the following command, the command breakpoint is executed only if the execution policy is set to RemoteSigned, the most restrictive policy that still permits you to run scripts.</source>
          <target state="translated">In den folgenden Befehl wird der befehlshaltepunkt nur ausgeführt, wenn die Ausführungsrichtlinie auf "RemoteSigned", die am stärksten einschränkende Richtlinie festgelegt ist, die noch die Ausführung von Skripts zulässt.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the continuation character.)</source>
          <target state="translated">(Das Hochkomma (') ist das Fortsetzungszeichen.)</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -script test.ps1 -command psversion ` -action { if ((get-executionpolicy) -eq "RemoteSigned") { break }}</source>
          <target state="translated">PS C:\ps-test &gt; Set-Psbreakpoint-Skript test.ps1-Befehl Psversion '-Aktion {Wenn ((get-executionpolicy) - Eq "RemoteSigned") {Break}}</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The Break keyword in the action directs the debugger to execute the breakpoint.</source>
          <target state="translated">Das Schlüsselwort "Break" in der Aktion wird den Debugger den Haltepunkt ausführen.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>You can also use the Continue keyword to direct the debugger to execute without breaking.</source>
          <target state="translated">Continue-Schlüsselwort können auch direkt von der Debugger ohne Unterbrechung ausführen.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Because the default keyword is Continue, you must specify Break to stop execution.</source>
          <target state="translated">Da das Default-Schlüsselwort Continue ist, müssen Sie unterbrechen, um die Ausführung beenden angeben.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">Führen Sie nun das Skript ein.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 erreicht befehlshaltepunkt auf 'C:\ps-test\test.ps1:psversion'</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">Test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Because the execution policy is set to RemoteSigned, execution stops at the function call.</source>
          <target state="translated">Da die Ausführungsrichtlinie auf "RemoteSigned" festgelegt ist, beendet die Ausführung mit dem Funktionsaufruf.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>At this point, you might want to check the call stack.</source>
          <target state="translated">An diesem Punkt empfiehlt es sich um die Aufrufliste überprüfen.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Use the Get-PsCallStack cmdlet or the Get-PsCallStack debugger command (k).</source>
          <target state="translated">Verwenden Sie das Cmdlet "Get-PsCallStack" oder das Get-PsCallStack-Debugger-Befehl (KB).</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The following command gets the current call stack.</source>
          <target state="translated">Der folgende Befehl ruft die aktuelle Aufrufliste an.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>DBG&gt; k 2: prompt 1: .\test.ps1: $args=[] 0: prompt: $args=[]</source>
          <target state="translated">DBG &gt; k 2: 1 auffordern:.\test.ps1: $args [0] =: Aufforderung: $args =]</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example demonstrates just a few of the many ways to use the Windows PowerShell debugger.</source>
          <target state="translated">Dieses Beispiel zeigt nur einige der vielen Methoden den Windows PowerShell-Debugger verwenden.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For more information about the debugger cmdlets, type the following command:</source>
          <target state="translated">Weitere Informationen zu den Debugger-Cmdlets Geben Sie den folgenden Befehl ein:</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>help &lt;cmdlet-name&gt; -full</source>
          <target state="translated">Hilfe &lt; Cmdlet-Name &gt; - full</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>For example, type:</source>
          <target state="translated">Beispiel:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>help set-psbreakpoint -full</source>
          <target state="translated">Set-Psbreakpoint-Hilfe-full</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Other Debugging Features in Windows PowerShell</source>
          <target state="translated">Andere Debugging-Funktionen in WindowsPowerShell</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>In addition to the Windows PowerShell debugger, Windows PowerShell includes several other features that you can use to debug scripts and functions.</source>
          <target state="translated">Zusätzlich zu den Windows PowerShell-Debugger enthält Windows PowerShell Weitere Features, die Sie zum Debuggen von Skripts und Funktionen verwenden können.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-- Windows PowerShell Integrated Scripting Environment (ISE) includes an interactive graphical debugger.</source>
          <target state="translated">Windows PowerShell Integrated Scripting Environment (ISE) enthält einen interaktiven grafischen Debugger.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, start Windows PowerShell ISE and press F1.</source>
          <target state="translated">Weitere Informationen starten Sie Windows PowerShell ISE, und drücken Sie F1.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-- The Set-PSDebug cmdlet offers very basic script debugging features, including stepping and tracing.</source>
          <target state="translated">– Das Set-PSDebug-Cmdlet bietet einfachen Skriptdebugging-Funktionen, einschließlich stepping und Protokollierung.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-- Use the Set-StrictMode cmdlet to detect references to uninitialized variables, to references to non-existent properties of an object, and to function syntax that is not valid.</source>
          <target state="translated">--Verwenden Sie das Cmdlet "Set-StrictMode" erkennen Sie Verweise auf nicht initialisierte Variablen, um Verweise auf nicht vorhandene Eigenschaften eines Objekts und Funktion-Syntax, die nicht gültig ist.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>-- Add diagnostic statements to a script, such as statements that display the value of variables, statements that read input from the command line, or statements that report the current instruction.</source>
          <target state="translated">– Fügen Sie diagnostische Anweisungen in ein Skript, z. B. Anweisungen, die den Wert der Variablen anzuzeigen, Anweisungen, die Eingabe über die Befehlszeile zu lesen oder -Anweisungen, die die aktuelle Anweisung zu melden.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Use the cmdlets that contain the Write verb for this task, such as Write-Host, Write-Debug, Write-Warning, and Write-Verbose.</source>
          <target state="translated">Verwenden Sie die Cmdlets, die Write-Verb für diese Aufgabe, z. B. Write-Host, Write-Debug, Write-Warning, und Write-Verbose enthalten.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">SIEHE AUCH</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</source>
          <target state="translated">Disable-PsBreakpoint-Enable-PsBreakpoint Get-PsBreakpoint-Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint-Set-PsDebug festgelegt-Strictmode Write-Debug-Write-Verbose</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>