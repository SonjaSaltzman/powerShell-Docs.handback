<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f31f43a46b7310525bae25f8c51c138d3ae0a7cf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a4052ae04996c162cc37e7970e28e6f60409e9e9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell-Cmdlets</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">Informationen zu ForEach</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">KURZE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">Beschreibt einen Sprachbefehl, den Sie verwenden können, um alle Elemente in einer Auflistung von Elementen zu durchlaufen.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">LANGE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">Die Foreach-Anweisung (auch bekannt als eine Foreach-Schleife) ist ein Sprachkonstrukt zum schrittweisen Durchlaufen (Iteration) eine Reihe von Werten in eine Auflistung von Elementen.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">Der einfachste und am häufigsten verwendete Typ der Auflistung durchlaufen ist ein Array.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">In einer Foreach-Schleife ist es üblich, einen oder mehrere Befehle für jedes Element in einem Array auszuführen.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">Die folgende Syntax zeigt die ForEach-Syntax:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">Foreach ($<ph id="ph1">&lt;item&gt;</ph> $<ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">Eine vereinfachte Syntax ab Windows PowerShell 3.0 Syntax mit Sprachschlüsselwörter wie Where und ForEach wurde vereinfacht.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">Vergleichsoperatoren, die auf die Member einer Auflistung arbeiten, werden als Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">Auf die Member einer Auflistung können Sie eine Methode verwenden, ohne in einem Skriptblock enthalten ist oder die automatische Variable "$_." hinzufügen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">Beachten Sie die folgenden beiden Beispiele:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">Dir Cert: \-Recurse | Foreach GetKeyAlgorithm Dir Cert: \-Recurse | Foreach {$_. GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">Obwohl beide Befehle funktionieren, gibt die ersten Ergebnisse ohne einen Skriptblock oder die $_ zurück.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">automatischen Variablen.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">Die Methode GetKeyAlgorithm wird als Parameter der ForEach behandelt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">Der erste Befehl gibt die gleichen Ergebnisse, jedoch ohne Fehler, da die vereinfachte Syntax nicht versucht, die Ergebnisse für Elemente zurück, für die das angegebene Argument wurde nicht angewendet.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">In diesem Beispiel wird die Get-Process-Eigenschaft Beschreibung als Argument-Parameter der ForEach-Anweisung übergeben.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">Die Ergebnisse sind die Beschreibungen der aktiven Prozesse.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-Process | ForEach-Beschreibung</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">Die Foreach-Anweisung außerhalb einer Befehlspipeline den Teil der Foreach-Anweisung in Klammern eingeschlossen stellt eine Variable und eine Auflistung zu durchlaufen.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell erstellt die Variable ($<ph id="ph1">&lt;item&gt;</ph>) automatisch, wenn die Foreach-Schleife ausgeführt.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">Vor jeder Iteration der Schleife wird die Variable auf einen Wert in der Auflistung gesetzt.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">Der Block eine Foreach-Anweisung nach {<ph id="ph1">&lt;statement list&gt;</ph>} enthält eine Reihe von Befehlen, die für jedes Element in einer Auflistung ausgeführt.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">Beispiele für Beispiel zeigt die Foreach-Schleife im folgenden Beispiel die Werte im Array $letterArray.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray = "a", "b", "C", "d" Foreach ($letter in $letterArray) {Write-Host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">In diesem Beispiel $letterArray Array erstellt und initialisiert mit den Zeichenfolgenwerten "a", "b", "c" und "d".</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">Beim ersten Foreach-Anweisung ausgeführt wird, wird die Variable $letter gleich das erste Element im $letterArray ("a").</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">Anschließend wird das Write-Host-Cmdlet zum Anzeigen der Buchstabe ein.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">Das nächste Mal durchlaufen der Schleife wird $letter auf "b" usw. festgelegt werden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">Nachdem die Foreach-Schleife den Buchstaben d angezeigt wird, wird Windows PowerShell die Schleife beendet.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">Die gesamte Foreach-Anweisung muss in einer einzigen Zeile als einen Befehl an der Befehlszeile von Windows PowerShell ausgeführt werden angezeigt.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">Die gesamte Foreach-Anweisung muss nicht in einer einzelnen Zeile angezeigt werden, wenn Sie den Befehl stattdessen in einer ps1-Skriptdatei speichern.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">Foreach-Anweisung können auch zusammen mit Cmdlets verwendet werden, die eine Auflistung von Elementen zurückgeben.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">Im folgenden Beispiel der Foreach-Anweisung durchläuft die Liste der Elemente, die durch das Get-ChildItem-Cmdlet zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">Foreach ($file in Get-ChildItem) {Write-Host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">Sie können das Beispiel verfeinern, indem Sie mit einer Anweisung, um die Ergebnisse einzuschränken, die zurückgegeben werden.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">Im folgenden Beispiel führt die Foreach-Anweisung den gleichen Schleifen Vorgang wie im vorherigen Beispiel, aber es Fügt eine If-Anweisung die Ergebnisse von Dateien einzuschränken, die größer als 100 Kilobyte (KB):</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">Foreach ($file in Get-ChildItem) {Wenn ($file.length - Gt 100 KB) {Write-Host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">In diesem Beispiel verwendet die Foreach-Schleife eine Eigenschaft der $file Variablen, um eine Vergleichsoperation ($file.length - Gt 100 KB) ausführen.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">Die Variable $file enthält alle Eigenschaften in das Objekt, das vom Get-ChildItem-Cmdlet zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">Daher können Sie mehr als nur einen Dateinamen zurück.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">Im nächsten Beispiel gibt Windows PowerShell die Länge und den Zeitpunkt des letzten Zugriffs innerhalb der Anweisungsliste zurück:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">Foreach ($file in Get-ChildItem) {Wenn ($file.length - Gt 100 KB) {Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">In diesem Beispiel sind Sie nicht zum Ausführen eines einzelnen Befehls in einer Liste beschränkt.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">Sie können auch eine Variable außerhalb einer Foreach-Schleife verwenden und die Variable innerhalb der Schleife erhöht.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">Im folgenden Beispiel wird die Größe von über 100 KB-Dateien:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i = 0 Foreach ($file in Get-ChildItem) {Wenn ($file.length - Gt 100 KB) {Write-Host $file "Dateigröße:" ($file.length / 1024). ToString("F0") KB $i = $i + 1}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">Wenn ($i - Ne 0) {Write-Host Write-Host $i "Datei(en) über 100 KB im aktuellen Verzeichnis."}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">Else {Write-Host "Keine Dateien größer als 100 KB im aktuellen Verzeichnis."</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">Im vorhergehenden Beispiel die Variable $i 0 außerhalb der Schleife festgelegt ist, und die Variable wird innerhalb der Schleife für jede Datei gefunden wird, der größer als 100 KB erhöht.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">Beim Beenden der Schleife einer If-Anweisung ergibt den Wert des $i anzuzeigende Anzahl aller Dateien über 100 KB.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">Oder es wird eine Meldung, die besagt, dass keine Dateien über 100 KB gefunden wurden.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">Im vorherige Beispiel zeigt auch, wie so formatieren Sie die Datei Länge Ergebnisse:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length / 1024). ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">Der Wert wird durch 1.024, um die Ergebnisse anzuzeigen, in Kilobyte in Bytes geteilt, und der resultierende Wert wird formatiert mit dem Festkommaformatbezeichner alle Dezimalwerte aus dem Ergebnis entfernt.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">Die 0 wird den Formatbezeichner keine Dezimalstellen angezeigt.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Die Foreach-Anweisung innerhalb eines Befehl Pipeline Wenn Foreach in einer Befehlspipeline angezeigt wird, verwendet Windows PowerShell den Foreach-Alias, der aufgerufen wird, den ForEach-Object-Befehl.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">Wenn Sie den Foreach-Alias in einer Befehlspipeline verwenden, Sie enthalten nicht die ($<ph id="ph1">&lt;item&gt;</ph> $<ph id="ph2">&lt;collection&gt;</ph>) Syntax wie gehen Sie mit der Foreach-Anweisung.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">Dies ist, da der vorherige Befehl in die Pipeline diese Informationen bereitstellt.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">Die Syntax des Foreach-Alias bei der Verwendung in einer Befehlspipeline lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">| Foreach {&lt; Command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">Die Foreach-Schleife, in der folgende Befehl zeigt beispielsweise Prozesse, dessen Workingset (Speicherbedarf) größer als 20 Megabyte (MB) ist.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">Der Get-Process-Befehl ruft alle Prozesse auf dem Computer ab.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Die Foreach führt alias die Befehle im Skriptblock auf jeden Prozess in der Sequenz.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">Die IF-Anweisung wählt Prozesse mit einem Arbeitssatz (WS) größer als 20 MB.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">Das Write-Host-Cmdlet schreibt den Namen des Prozesses, gefolgt von einem Doppelpunkt.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">Dividiert den Wert arbeiten festzulegen, der in 1 MB zum Abrufen des Arbeit festgelegte Wert in Megabyte in Byte gespeichert wird.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">Klicken Sie dann konvertiert das Ergebnis in einen Double-Wert in eine Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">Es zeigt den Wert als eine Festkommazahl mit 0 Dezimalstellen (d0), Leerzeichen als Trennzeichen (""), und klicken Sie dann "MB".</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">Write-Host "Prozesse mit mehr als 20 MB Workingsets."</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-Process | Foreach {Wenn ($_. WS - Gt 20 MB) {Write-Host $.name ":" ($. WS/1MB). ToString("F0") MB-Trennzeichen ""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">Die Foreach unterstützt alias auch Anfang Befehlssätze, mittleren Befehlssätze und End-Befehlssätze.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">Anfang und Ende-Befehlssätze einmal ausführen und die mittlere Befehlsblock führt jedes Mal, wenn die Foreach-Schleife durchlaufen einer Auflistung oder einem Array.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">Die Syntax des Foreach-Alias bei der Verwendung in einer Befehlspipeline mit einem Anfang, Mitte und am Befehlssätze lautet wie folgt:</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">| Foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von den Start-, Mittel- und End-Befehlssätze.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-ChildItem | Foreach {$fileCount = $directoryCount = 0} {Wenn ($_. PsIsContainer) {$DirectoryCount ++} else {$FileCount ++}} {"$directoryCount Verzeichnisse und Dateien $fileCount"}</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">Der Anfang Block erstellt und zwei Variablen auf 0 initialisiert:</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount = $directoryCount = 0}</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">Der mittlere Block wertet aus, ob jedes Element von Get-ChildItem zurückgegebene ein Verzeichnis oder eine Datei ist:</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{Wenn ($_. PsIsContainer) {$DirectoryCount ++} else {$FileCount ++}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">Wenn das Element, das zurückgegeben wird, ein Verzeichnis ist, wird die Variable $directoryCount um 1 erhöht.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">Wenn das Element kein Verzeichnis ist, wird die Variable $fileCount um 1 erhöht.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">Der letzte Block wird ausgeführt, nachdem der mittleren Block den Schleifen-Vorgang beendet und das Ergebnis des Vorgangs zurückgegeben:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{"$directoryCount Verzeichnisse und Dateien $fileCount"}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">Die Struktur ab, in der Mitte und am Befehl Block und den Pipelineoperator verwenden, können Sie das vorherige Beispiel, um alle Dateien zu suchen, die größer als 100 KB, wie folgt sind umschreiben:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-ChildItem | Foreach {$i = 0} {Wenn ($_.length - Gt 100 KB) {Write-Host $.name "Dateigröße:" (Länge $ / 1024). ToString("F0") KB $i++}} {Wenn ($i - Ne 0) {Write-Host Write-Host "$i Datei(en) über 100 KB im aktuellen Verzeichnis."</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-Host "Keine Dateien größer als 100 KB im aktuellen Verzeichnis."}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">Im folgenden Beispiel, eine Funktion, die die Funktionen, mit denen in Skripts und Skriptmodule, gibt veranschaulicht, wie die MoveNext-Methode (das funktioniert auf ähnliche Weise zu X auf einer For-Schleife "Überspringen") und die Current-Eigenschaft der $foreach Variablen innerhalb einer Foreach-Skriptblock, selbst wenn es ungewöhnlich oder uneinheitlich – Kreditkartennummern Funktionsdefinitionen, die mehrere Zeilen, um den Namen der Funktion deklarieren umfassen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">Das Beispiel funktioniert auch auf, wenn Kommentare in in einem Skript oder das Skriptmodul verwendeten Funktionen vorhanden sind.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">Get-FunctionPosition Funktion {Param [CmdletBinding()] [OutputType('FunctionPosition')] ([Parameter (Position = 0, obligatorisch, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String []] $Path</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">Prozess {versuchen {$filesToProcess = if ($_-ist [System.IO.FileSystemInfo]) {}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-Item-Pfad $Path} Foreach ($item in $filesToProcess) {Wenn ($item. PSIsContainer- oder $item. Extension - Notin @('.ps1','.psm1')) {weiterhin} $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile ($item. FullName,([REF]$tokens),([REF]$errors)) Wenn ($errors) {Write-Warning "Datei" $($item. "FullName")' wurde $($errors. Anzahl) Parserfehler."</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: TokenLoop Foreach ($token im $tokens) {Wenn ($token. Kind - Ne 'Funktion') {weiterhin} $position = $token. Führen Sie Extent.StartLineNumber {Wenn (-nicht $foreach. MoveNext()) {Break TokenLoop} $token = $foreach. Aktuelle} bis ($token. Kind - in @('Generic','Identifier')) $functionPosition [Pscustomobject] = @{Name = $token. Text LineNumber = $position Path = $item. FullName} Add-Member - InputObject $functionPosition - TypeName FunctionPosition - PassThru}}} Catch {Throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">SIEHE AUCH</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">About_Automatic_Variables About_If Foreach-Object</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>