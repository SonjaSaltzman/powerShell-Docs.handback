<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e3678c50582d25cf0c15d13ad31c9a5f012b40e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Splatting.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e36ef81e5150035ee958828a7d6d78c0c3d9bdec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae441651a33a38fb6adb54d944f2fdf31e5766d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell-Cmdlets</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Splatting</source>
          <target state="translated">Zur Verteilung</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">KURZE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use splatting to pass parameters to commands in Windows PowerShell.</source>
          <target state="translated">Beschreibt die Verteilung zu verwenden, um Parameter auf in Windows PowerShell-Befehle übergeben.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">LANGE BESCHREIBUNG</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[This topic was contributed by Rohn Edwards of Gulfport, Mississippi, a system administrator and the winner of the Advanced Division of the 2012 Scripting Games.</source>
          <target state="translated">[Dieses Thema wurde durch Rohn Edwards von Gulfport, Mississippi Systemadministrator und der Gewinner des fortgeschrittene von der 2012 Scripting Games bereitgestellt.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Revised for Windows PowerShell 3.0.]</source>
          <target state="translated">Überarbeitet für WindowsPowerShell 3.0.]</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Splatting is a method of passing a collection of parameter values to a command as unit.</source>
          <target state="translated">Verteilung ist eine Methode zum Übergeben einer Auflistung von Parameterwerten an einen Befehl als Einheit.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell associates each value in the collection with a command parameter.</source>
          <target state="translated">Windows PowerShell ordnet jeder Wert in der Auflistung mit dem Befehlsparameter.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Splatted parameter values are stored in named splatting variables, which look like standard variables, but begin with an At symbol (@) instead of a dollar sign ($).</source>
          <target state="translated">Splatted-Parameterwerte werden gespeichert in benannte Splatting-Variablen, die Standardvariablen aussehen, aber beginnen mit einem At-Symbol (@) statt ein Dollarzeichen ($).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The At symbol tells Windows PowerShell that you are passing a collection of values, instead of a single value.</source>
          <target state="translated">Das At-Symbol weist Windows PowerShell, dass Sie eine Auflistung von Werten, anstelle eines einzelnen Wertes übergeben werden.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Splatting makes your commands shorter and easier to read.</source>
          <target state="translated">Verteilung macht Ihre Befehle kürzer und leichter zu lesen.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can re-use the splatting values in different command calls and use splatting to pass parameter values from the $PSBoundParameters automatic variable to other scripts and functions.</source>
          <target state="translated">Sie können in anderen Befehl aufrufen Splatting Werte Wiederverwendung und Verteilung Parameterwerte aus der automatischen $PSBoundParameters-Variablen an andere Skripts und Funktionen zu übergeben.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can also use splatting to represent all parameters of a command.</source>
          <target state="translated">Ab Windows PowerShell 3.0 auch können Verteilung Sie alle Parameter für einen Befehl darstellen.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">SYNTAX</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To provide parameter values for positional parameters, in which parameter names are not required, use the array syntax.</source>
          <target state="translated">Verwenden Sie die Arraysyntax, um Parameterwerte positionelle Parameter in der Parameter Namen nicht erforderlich sind.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To provide parameter name and value pairs, use the hash table syntax.</source>
          <target state="translated">Um Parameter Name-Wert-Paare bereitstellen, verwenden Sie die Syntax der Hash-Tabelle.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The splatted value can appear anywhere in the parameter list.</source>
          <target state="translated">Der Splatted-Wert kann an einer beliebigen Stelle in der Liste angezeigt.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When splatting, you do not need to use a hash table or an array to pass all parameters.</source>
          <target state="translated">Bei der Verteilung, Sie brauchen eine Hashtabelle oder ein Array zu verwenden, um alle Parameter übergeben.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You may pass some parameters by using splatting and pass others by position or by parameter name.</source>
          <target state="translated">Wählen Sie einige Parameter übergeben, mit der Verteilung und anderen nach Position oder nach Name des Parameters übergeben.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Also, you can splat multiple objects in a single command just so you pass no more than one value for each parameter.</source>
          <target state="translated">Sie können auch Splat mehrere Objekte in einem einzigen Befehl nur, damit Sie nicht mehr als ein Wert für die einzelnen Parameter übergeben.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH HASH TABLES</source>
          <target state="translated">VERTEILUNG HASHTABELLEN</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a hash table to splat parameter name and value pairs.</source>
          <target state="translated">Verwenden Sie eine Hashtabelle zum Splat Name-Wert-Paaren.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can use this format for all parameter types, including positional and named parameters and switch parameters.</source>
          <target state="translated">Sie können dieses Format für alle Parametertypen, einschließlich positionelle und benannte Parameter verwenden und switch-Parameter.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Die folgenden Beispiele vergleichen zwei Copy-Item-Befehle, die die Datei "Test.txt" in die Test2.txt-Datei im gleichen Verzeichnis zu kopieren.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are included.</source>
          <target state="translated">Im ersten Beispiel wird das herkömmliche Format in das Parameter Namen enthalten sind.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item - Pfad "test.txt"-Ziel "test2.txt" - WhatIf</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The second example uses hash table splatting.</source>
          <target state="translated">Im zweiten Beispiel wird die Verteilung der Hash-Tabelle.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter-name and parameter-value pairs and stores it in the $HashArguments variable.</source>
          <target state="translated">Der erste Befehl erstellt eine Hashtabelle der Parametername und Parameter-Wert-Paare und speichert ihn in der Variablen $HashArguments.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The second command uses the $HashArguments variable in a command with splatting.</source>
          <target state="translated">Der zweite Befehl verwendet die $HashArguments-Variable in einem Befehl mit der Verteilung.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The At symbol (@HashArguments) replaces the dollar sign ($HashArguments) in the command.</source>
          <target state="translated">Das At-Symbol (@HashArguments) ersetzt das Dollarzeichen ($HashArguments) im Befehl.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To provide a value for the WhatIf switch parameter, use $True or $False.</source>
          <target state="translated">Um einen Wert für den Switch-Parameter "WhatIf" bereitzustellen, verwenden Sie $True oder $False.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$HashArguments = @{ Path = "test.txt"; Destination = "test2.txt"; WhatIf = $true } PS C:&gt;Copy-Item @HashArguments</source>
          <target state="translated">PS C: &gt; $HashArguments = @{Path = "test.txt"; Ziel = "test2.txt"; WhatIf = $true} PS C: &gt; Copy-Item @HashArguments</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note: In the first command, the At symbol (@) indicates a hash table, not a splatted value.</source>
          <target state="translated">Hinweis: im ersten Befehl das At-Symbol (@) gibt eine Hashtabelle, jedoch kein Splatted-Wert an.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The syntax for hash tables in Windows PowerShell is: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>; …}</source>
          <target state="translated">Die Syntax für Hashtabellen in Windows PowerShell ist: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>;...}</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH ARRAYS</source>
          <target state="translated">VERTEILUNG MIT ARRAYS</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use an array to splat values for positional parameters, which do not require parameter names.</source>
          <target state="translated">Verwenden Sie ein Array mit Splat Werten für positionelle Parameter, die keine Parameternamen erforderlich sind.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The values must be in position-number order in the array.</source>
          <target state="translated">Die Werte müssen in Positionsnummer Reihenfolge im Array sein.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Die folgenden Beispiele vergleichen zwei Copy-Item-Befehle, die die Datei "Test.txt" in die Test2.txt-Datei im gleichen Verzeichnis zu kopieren.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are omitted.</source>
          <target state="translated">Im ersten Beispiel wird das traditionelle Format, in dem Parameternamen ausgelassen werden.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The parameter values appear in position order in the command.</source>
          <target state="translated">Die Parameterwerte, die in Position Reihenfolge im Befehl angezeigt werden.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Copy-Item "test.txt" "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item "test.txt" "test2.txt" - WhatIf</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second example uses array splatting.</source>
          <target state="translated">Im zweiten Beispiel wird die Array-Verteilung.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first command creates an array of the parameter values and stores it in the $ArrayArguments variable.</source>
          <target state="translated">Der erste Befehl erstellt ein Array der Parameterwerte und speichert ihn in der Variablen $ArrayArguments.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The values are in position order in the array.</source>
          <target state="translated">Die Werte sind in der Reihenfolge der Position im Array.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The second command uses the $ArrayArguments variable in a command in splatting.</source>
          <target state="translated">Der zweite Befehl verwendet die $ArrayArguments-Variable in einem Befehl in der Verteilung.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The At symbol (@ArrayArguments) replaces the dollar sign ($ArrayArguments) in the command.</source>
          <target state="translated">Das At-Symbol (@ArrayArguments) ersetzt das Dollarzeichen ($ArrayArguments) im Befehl.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$ArrayArguments = "test.txt", "test2.txt" PS C:&gt;Copy-Item @ArrayArguments -WhatIf</source>
          <target state="translated">PS C: &gt; $ArrayArguments = "test.txt", "test2.txt" PS C: &gt; Copy-Item @ArrayArguments - WhatIf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">BEISPIELE</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This example shows how to re-use splatted values in different commands.</source>
          <target state="translated">In diesem Beispiel wird veranschaulicht, wie Splatted Werte erneut in verschiedene Befehle zu verwenden.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The commands in this example use the Write-Host cmdlet to write messages to the host program console.</source>
          <target state="translated">Die Befehle in diesem Beispiel verwenden Sie das Write-Host-Cmdlet zum Schreiben von Nachrichten an die Konsole der Host-Anwendung.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It uses splatting to specify the foreground and background colors.</source>
          <target state="translated">Verteilung verwendet, um die Vordergrund- und Hintergrundfarben angegeben.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To change the colors of all commands, just change the value of the $Colors variable.</source>
          <target state="translated">Um die Farben aller Befehle zu ändern, ändern Sie einfach den Wert der Variablen $Colors.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter names and values and stores the hash table in the $Colors variable.</source>
          <target state="translated">Der erste Befehl erstellt eine Hashtabelle der Parameternamen und Werte und die Hash-Tabelle in der $Colors-Variablen gespeichert.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</source>
          <target state="translated">$Colors = @{ForegroundColor = "black" BackgroundColor = "White"}</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second and third commands use the $Colors variable for splatting in a Write-Host command.</source>
          <target state="translated">Die zweiten und dritten Befehl werden die $Colors-Variable für Verteilung in einem Befehl Write-Host verwenden.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To use the $Colors variable, replace the dollar sign ($Colors) with an At symbol (@Colors).</source>
          <target state="translated">Um die $Colors-Variable zu verwenden, ersetzen Sie das Dollarzeichen ($Colors) mit einem At-Symbol (@Colors).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Write a message with the colors in $Colors Write-Host "This is a test."</source>
          <target state="translated">Schreibt eine Nachricht mit den Farben im $Colors Write-Host "This is a Test".</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>@Colors</source>
          <target state="translated">@Colors</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Write second message with same colors.</source>
          <target state="translated">Schreiben Sie die zweite Nachricht mit der gleichen Farben.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The position of splatted hash table does not matter.</source>
          <target state="translated">Die Position des Splatted Hashtabelle spielt keine Rolle.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Write-Host @Colors "This is another test."</source>
          <target state="translated">Write-Host-@Colors "Dies ist ein weiterer Test."</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example shows how to forward their parameters to other commands by using splatting and the $PSBoundParameters automatic variable.</source>
          <target state="translated">Dieses Beispiel zeigt, wie ihre Parameter an andere Befehle mithilfe von Verteilung und die automatische $PSBoundParameters-Variable weitergeleitet wird.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The $PSBoundParameters automatic variable is a dictionary (System.Collections.Generic.Dictionary) that contains all of the parameter names and values that are used when a script or function is run.</source>
          <target state="translated">Die automatische $PSBoundParameters-Variable ist ein Wörterbuch (System.Collections.Generic.Dictionary), enthält alle Parameternamen und Werte, die verwendet werden, wenn ein Skript oder eine Funktion ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, we use the $PSBoundParameters variable to forward the parameters values passed to a script or function from Test2 function to the Test1 function.</source>
          <target state="translated">Im folgenden Beispiel verwenden wir die $PSBoundParameters Variable zum Weiterleiten von Parameterwerten, die mit einem Skript oder eine Funktion von Test2-Funktion, um die Test1-Funktion übergeben.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both calls to the Test1 function from Test2 use splatting.</source>
          <target state="translated">Beide Aufrufe an die Funktion "Test1" Test2 verwenden Verteilung.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>function Test1 { param($a, $b, $c)</source>
          <target state="translated">Funktion "Test1" {Param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>$a $b $c }</source>
          <target state="translated">$a $b $c}</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>function Test2 { param($a, $b, $c)</source>
          <target state="translated">Funktion Test2 {Param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $a, $b, and $c.</source>
          <target state="translated">Rufen Sie die Funktion "Test1" mit $a $b, und $c.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test1 @PsBoundParameters</source>
          <target state="translated">Test1 @PsBoundParameters</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $b and $c, but not with $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters }</source>
          <target state="translated">Rufen Sie die Funktion "Test1" $c mit $b, aber nicht mit der $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null "Test1" @LimitedParameters}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Test2 -a 1 -b 2 -c 3</source>
          <target state="translated">PS C: &gt; Test2 – ein 1 -b 2 - c-3</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>SPLATTING COMMAND PARAMETERS</source>
          <target state="translated">BEFEHLSPARAMETER VERTEILUNG</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use splatting to represent the parameters of a command.</source>
          <target state="translated">Verteilung können Sie die Parameter für einen Befehl darstellen.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This technique is useful when you are creating a proxy function, that is, a function that calls another command.</source>
          <target state="translated">Diese Methode ist hilfreich, wenn Sie eine Proxyfunktion erstellen, das aufgerufen wird, eine Funktion, die einen anderen Befehl.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">Diese Funktion ist in Windows PowerShell 3.0 eingeführt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To splat the parameters of a command, use @Args to represent the command parameters.</source>
          <target state="translated">Um Splat verwenden die Parameter für einen Befehl @Args zur Darstellung der Parameter des Befehls.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This technique is easier than enumerating command parameters and it works without revision even if the parameters of the called command change.</source>
          <target state="translated">Dieses Verfahren ist einfacher als Befehlsparameter auflisten und ohne Revision funktioniert, auch wenn die Parameter des aufgerufenen Befehls ändern.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The feature uses the $Args automatic variable, which contains all unassigned parameter values.</source>
          <target state="translated">Die Funktion verwendet die automatische $Args-Variable, die Werte für alle nicht zugewiesenen Parameter enthält.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following function calls the Get-Process cmdlet.</source>
          <target state="translated">Die folgende Funktion ruft z. B. das Cmdlet "Get-Process".</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this function, @Args represents all of the parameters of the Get-Process cmdlet.</source>
          <target state="translated">In dieser Funktion stellt die Parameter des Cmdlets Get-Process @Args dar.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>function Get-MyProcess { Get-Process @Args }</source>
          <target state="translated">Get-den Namen myProcess ein {Get-Process @Args}-Funktion</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use the Get-MyProcess function, all unassigned parameters and parameter values are passed to @Args, as shown in the following commands.</source>
          <target state="translated">Wenn Sie die Get-den Namen myProcess ein-Funktion verwenden, werden alle nicht zugewiesenen Parameter und Parameterwerte an @Args, übergeben, wie in den folgenden Befehlen angezeigt.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-den Namen myProcess ein-Namen von PowerShell</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Npm(k): PM(k): ws(k): VM(m): CPU(s) Id Prozessname behandelt</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>463      46   225484     237196   719    15.86   3228 powershell</source>
          <target state="translated">463 46 225484 237196 719 15.86 3228 Powershell</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell_Ise -FileVersionInfo</source>
          <target state="translated">PS C: &gt; Get-den Namen myProcess ein-PowerShell_Ise - FileVersionInfo-Namen</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>ProductVersion   FileVersion      FileName</source>
          <target state="translated">ProductVersion FileVersion Dateiname</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</source>
          <target state="translated">6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can use @Args in a function that has explicitly declared parameters.</source>
          <target state="translated">Sie können @Args in einer Funktion verwenden, die explizit Parameter deklariert hat.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use it more than once in a function, but all parameters that you enter are passed to all instances of @Args, as shown in the following example.</source>
          <target state="translated">Können mehr als einmal in einer Funktion verwenden, aber alle eingegebenen Parameter sind für alle Instanzen der @Args, übergeben, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Param ([switch]$P, [switch]$C) if ($P) { Get-Process @Args } if ($C) { Get-Command @Args } }</source>
          <target state="translated">Get-MyCommand Funktion {Param ([Option] $P [Option] $C) Wenn ($P) {Get-Process @Args} Wenn ($C) {Get-Command @Args}}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyCommand -P -C -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-MyCommand - P -C-Namen von PowerShell</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Npm(k): PM(k): ws(k): VM(m): CPU(s) Id Prozessname behandelt</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>408      28    75568      83176   620     1.33   1692 powershell</source>
          <target state="translated">408 28 75568 83176 620 1,33 1692 Powershell</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Path               : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension          : .exe Definition         : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Visibility         : Public OutputType         : {System.String} Name               : powershell.exe CommandType        : Application ModuleName         : Module             : RemotingCapability : PowerShell Parameters         : ParameterSets      : HelpUri            : FileVersionInfo    : File:             C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</source>
          <target state="translated">Pfad: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Erweiterung: .exe-Definition: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Sichtbarkeit: öffentliche OutputType: {System.String} Name: powershell.exe CommandType: Anwendung ModuleName: Modul: RemotingCapability: PowerShell-Parameter: ParameterSets: HelpUri: FileVersionInfo: Datei: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">SIEHE AUCH</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</source>
          <target state="translated">"about_arrays" About_Automatic_Variables About_Hash_Tables about_Parameters</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>