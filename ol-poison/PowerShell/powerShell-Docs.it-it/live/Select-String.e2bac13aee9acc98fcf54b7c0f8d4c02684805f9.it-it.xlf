<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c3c5b7bdd0e478e8ab19cf67260f8f8c174085a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Utility\Select-String.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c358da2d9d9b8479467113a2de169f81a829340f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">12fc95fed3a6aee8b0a46b7605518170fe283e9b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet PowerShell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Select-String</source>
          <target state="translated">Select-String</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Select-String</source>
          <target state="translated">Select-String</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SYNOPSIS</source>
          <target state="translated">RIEPILOGO</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Finds text in strings and files.</source>
          <target state="translated">Trova il testo in stringhe e file.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">SINTASSI</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>File (Default)</source>
          <target state="translated">File (predefinito)</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Oggetto</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LiteralFile</source>
          <target state="translated">LiteralFile</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">DESCRIZIONE</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> cmdlet searches for text and text patterns in input strings and files.</source>
          <target state="translated">Il <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> cmdlet Cerca testo e modelli di testo in file e le stringhe di input.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can use it like Grep in UNIX and Findstr in Windows.</source>
          <target state="translated">È possibile usarlo allo stesso modo di Grep in UNIX e Findstr in Windows.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can type <ph id="ph1">`Select-String`</ph> or its alias, <ph id="ph2">`sls`</ph>.</source>
          <target state="translated">È possibile digitare <ph id="ph1">`Select-String`</ph> o il relativo alias, <ph id="ph2">`sls`</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> is based on lines of text.</source>
          <target state="translated"><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> è basata sulle righe di testo.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> finds the first match in each line and, for each match, it displays the file name, line number, and all text in the line containing the match.</source>
          <target state="translated">Per impostazione predefinita, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Trova la prima corrispondenza in ogni riga e, per ogni corrispondenza, viene visualizzato il nome del file, numero di riga e tutto il testo nella riga contenente la corrispondenza.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>However, you can direct it to detect multiple matches per line, display text before and after the match, or display only a Boolean value (True or False) that indicates whether a match is found.</source>
          <target state="translated">Tuttavia, è possibile impostarlo per rilevare più corrispondenze per ogni riga, visualizzare il testo prima e dopo la corrispondenza o visualizzare solo un valore booleano (True o False) che indica se viene trovata una corrispondenza.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> uses regular expression matching, but it can also perform a simple match that searches the input for the text that you specify.</source>
          <target state="translated"><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> utilizza corrispondenza di espressioni regolari, ma è anche possibile eseguire una corrispondenza semplice che cerca l'input per il testo specificato.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> can display all of the text matches or stop after the first match in each input file.</source>
          <target state="translated"><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> consente di visualizzare tutte le corrispondenze di testo o arrestarsi dopo la prima corrispondenza in ogni file di input.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It can also display all text that does not match the specified pattern.</source>
          <target state="translated">Può anche visualizzare tutto il testo che non corrisponde al modello specificato.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can also specify that <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> should expect a particular character encoding, such as when you are searching files of Unicode text.</source>
          <target state="translated">È inoltre possibile specificare che <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> aspettarsi una particolare codifica dei caratteri, ad esempio quando si esegue la ricerca di file di testo Unicode.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">ESEMPI</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Example 1: Find a case-sensitive match</source>
          <target state="translated">Esempio 1: Trovare una corrispondenza tra maiuscole e minuscole</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>This command performs a case-sensitive match of the text that was piped to the <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> command.</source>
          <target state="translated">Questo comando esegue una corrispondenza tra maiuscole e minuscole del testo che è stato reindirizzato al <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> comando.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>As a result, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> finds only "HELLO", because "Hello" does not match.</source>
          <target state="translated">Di conseguenza, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Trova solo "HELLO", "Hello" corrisponde.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Because each of the quoted strings is treated as a line, without the <bpt id="p1">*</bpt>CaseSensitive<ept id="p1">*</ept> parameter, <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> would recognize both of the strings as matches.</source>
          <target state="translated">Poiché ogni stringa tra virgolette viene considerata come una riga, senza il <bpt id="p1">*</bpt>CaseSensitive<ept id="p1">*</ept> parametro <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> riconoscerebbe entrambe le stringhe come corrispondenze.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Example 2: Find matches in XML files only</source>
          <target state="translated">Esempio 2: Trovare corrispondenze in solo i file XML</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>This command searches through all files with the .xml file name extension in the current directory and displays the lines in those files that include the string "the the".</source>
          <target state="translated">Questo comando cerca in tutti i file con estensione di file XML nella directory corrente e visualizza le righe in tali file che includono la stringa "the the".</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Example 3: Find a pattern match</source>
          <target state="translated">Esempio 3: Trovare un criterio di ricerca</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command searches the Windows PowerShell conceptual Help files (about_*.txt) for information about the use of the at sign (@).</source>
          <target state="translated">Questo comando cerca nei file della Guida concettuale di Windows PowerShell (about_*.txt) informazioni sull'utilizzo del simbolo di chiocciola (@).</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To indicate the path, this command uses the value of the $pshome automatic variable, which stores the path to the Windows PowerShell installation directory.</source>
          <target state="translated">Per indicare il percorso, il comando usa il valore della variabile automatica $pshome, che archivia il percorso della directory di installazione di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In this example, the command searches the en-US subdirectory, which contains the English (US) language Help files for Windows PowerShell.</source>
          <target state="translated">In questo esempio, il comando cerca nella sottodirectory en-US, che contiene i file della Guida in lingua inglese (Stati Uniti) per Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Example 4: Use Select-String in a function</source>
          <target state="translated">Esempio 4: Utilizzare Select-String in una funzione</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>This simple function uses the <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> cmdlet to search the Windows PowerShell Help files for a particular string.</source>
          <target state="translated">Questa semplice funzione Usa il <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> cmdlet per la ricerca dei file della Guida di Windows PowerShell per una determinata stringa.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In this example, the function searches the "en-US" subdirectory for English-United States language files.</source>
          <target state="translated">In questo esempio, la funzione cerca nella sottodirectory "en-US" i file in lingua inglese (Stati Uniti).</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To use the function to find a string, such as "psdrive", type <ph id="ph1">`search-help psdrive`</ph>.</source>
          <target state="translated">Per utilizzare la funzione per trovare una stringa, ad esempio "psdrive", digitare <ph id="ph1">`search-help psdrive`</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To use this function in any Windows PowerShell console, change the path to point to the Windows PowerShell Help files on your system, and then paste the function in your Windows PowerShell profile.</source>
          <target state="translated">Per usare questa funzione in qualsiasi console di Windows PowerShell, modificare il percorso in modo che punti ai file della Guida di Windows PowerShell nel sistema e quindi incollare la funzione nel profilo di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Example 5: Search for a string in the Application log</source>
          <target state="translated">Esempio 5: Cercare una stringa nel registro dell'applicazione</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>This example searches for the string "failed" in the 100 newest events in the Application log in Event Viewer.</source>
          <target state="translated">Questo esempio cerca la stringa "failed" nei 100 eventi più recenti del registro applicazioni nel Visualizzatore eventi.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The first command uses the Get-EventLog cmdlet to get the 100 most recent events from the Application event log.</source>
          <target state="translated">Il primo comando usa il cmdlet Get-EventLog per ottenere i 100 eventi più recenti del registro eventi dell'applicazione.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Then it stores the events in the $Events variable.</source>
          <target state="translated">Gli eventi vengono quindi archiviati nella variabile $Events.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The second command uses a pipeline operator (|) to send the objects in the $Events variable to <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</source>
          <target state="translated">Il secondo comando Usa un operatore pipeline (|) per inviare gli oggetti nella variabile $Events per <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter to represent the input from the $Events variable.</source>
          <target state="translated">Usa il <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parametro per rappresentare l'input dalla variabile $Events.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The value of the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter is the Message property of each object as it travels through the pipeline.</source>
          <target state="translated">Il valore di <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parametro è la proprietà del messaggio di ogni oggetto inviato attraverso la pipeline.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The current object is represented by the $_ symbol.</source>
          <target state="translated">L'oggetto corrente è rappresentato dal simbolo $_.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>As each event arrives in the pipeline, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> searches the value of its Message property for the "failed" string, and then displays any lines that include a match.</source>
          <target state="translated">Come ogni evento arriva nella pipeline, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Cerca il valore della relativa proprietà del messaggio per la stringa "failed" e quindi Visualizza tutte le righe che contengono una corrispondenza.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Example 6: Find a string in subdirectories</source>
          <target state="translated">Esempio 6: Trovare una stringa in sottodirectory</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This command examines all files in the subdirectories of C:\Windows\System32 with the .txt file name extension and searches for the string "Microsoft".</source>
          <target state="translated">Questo comando esamina tutti i file con estensione di file txt nelle sottodirectory di C:\Windows\System32 e cerca la stringa "Microsoft".</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>CaseSensitive<ept id="p1">*</ept> parameter indicates that the "M" in "Microsoft" must be capitalized and that the rest of the characters must be lowercase for <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> to find a match.</source>
          <target state="translated">Il <bpt id="p1">*</bpt>CaseSensitive<ept id="p1">*</ept> parametro indica che la "M" in "Microsoft" deve essere in maiuscolo e che il resto dei caratteri deve essere minuscolo per <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> per trovare una corrispondenza.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Example 7: Find strings that do not match a pattern</source>
          <target state="translated">Esempio 7: Cercare le stringhe che corrispondono a un modello</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This command finds lines of text in the Process.txt file that do not include the words "idle" or "svchost".</source>
          <target state="translated">Questo comando trova le righe di testo nel file Process.txt che non contengono le parole "idle" o "svchost".</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Example 8: Find lines before and after a match</source>
          <target state="translated">Esempio 8: Individuare righe prima e dopo una corrispondenza</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The first command searches the Audit.Log file for the phrase "logon failed."</source>
          <target state="translated">Il primo comando cerca la frase "logon failed" nel file Audit.Log.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">*</bpt>Context<ept id="p1">*</ept> parameter to capture 2 lines before the match and 3 lines after the match.</source>
          <target state="translated">Usa il <bpt id="p1">*</bpt>contesto<ept id="p1">*</ept> per acquisire 2 righe prima della corrispondenza e 3 righe dopo la corrispondenza.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The second command uses the Count property of object arrays to display the number of matches found, in this case, 2.</source>
          <target state="translated">Il secondo comando usa la proprietà Count di matrici di oggetti per visualizzare il numero di corrispondenze trovate, in questo caso 2.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The third command displays the lines stored in the Context property of the first <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object.</source>
          <target state="translated">Il terzo comando Visualizza le righe archiviate nella proprietà di contesto del primo <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetto.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>It uses array notation to indicate the first match (match 0 in a zero-based array), and it uses the Format-List cmdlet to display the value of the Context property as a list.</source>
          <target state="translated">Usa la notazione di matrice per indicare la prima corrispondenza (corrispondenza 0 in una matrice in base zero) e Usa il cmdlet Format-List per visualizzare il valore della proprietà di contesto sotto forma di elenco.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The output consists of two MatchInfo objects, one for each match detected.</source>
          <target state="translated">L'output è costituito da due oggetti MatchInfo, uno per ogni corrispondenza rilevata.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The context lines are stored in the Context property of the <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object.</source>
          <target state="translated">Le righe di contesto sono archiviate nella proprietà del contesto di <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetto.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Example 9: Find all pattern matches</source>
          <target state="translated">Esempio 9: Trovare tutte le corrispondenze</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This example demonstrates the effect of the <bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> parameter of <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept>.</source>
          <target state="translated">Questo esempio viene illustrato l'effetto di <bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> parametro <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> finds all pattern matches in a line, instead of just finding the first match in each line.</source>
          <target state="translated"><bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> Trova tutte le corrispondenze in una riga, invece di trovare solo la prima corrispondenza in ogni riga.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The first command in the example searches the Windows PowerShell conceptual Help files ("about" Help) for instances of the word "transcript".</source>
          <target state="translated">Il primo comando dell'esempio cerca istanze della parola "transcript" nei file della Guida concettuale di Windows PowerShell ("about").</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The output of the first command is saved in the $A variable.</source>
          <target state="translated">L'output del primo comando viene salvato nella variabile $A.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The second command is identical, except that it uses the <bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Il secondo comando è identico, ad eccezione del fatto che utilizza il <bpt id="p1">*</bpt>AllMatches<ept id="p1">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The output of the second command is saved in the $B variable.</source>
          <target state="translated">L'output del secondo comando viene salvato nella variabile $B.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When you display the value of the variables, the default display is identical, as shown in the example output.</source>
          <target state="translated">Quando si visualizza il valore delle variabili, la visualizzazione predefinita è identica, come illustrato nell'output di esempio.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>However, the fifth and sixth commands display the value of the Matches property of each object.</source>
          <target state="translated">Tuttavia, il quinto comando e il sesto comando visualizzano il valore della proprietà Matches di ogni oggetto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The Matches property of the first command contains just one match (that is, one <bpt id="p1">**</bpt>System.Text.RegularExpressions.Match<ept id="p1">**</ept> object), whereas the Matches property of the second command contains objects for both of the matches in the line.</source>
          <target state="translated">La proprietà Matches del primo comando contiene una sola corrispondenza (vale a dire uno <bpt id="p1">**</bpt>System.Text.RegularExpressions.Match<ept id="p1">**</ept> oggetto), mentre la proprietà Matches del secondo comando contiene oggetti per entrambe le corrispondenze nella riga.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>PARAMETERS</source>
          <target state="translated">PARAMETRI</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>-AllMatches</source>
          <target state="translated">-AllMatches</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet searches for more than one match in each line of text.</source>
          <target state="translated">Indica che il cmdlet Cerca più corrispondenze in ogni riga di testo.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Without this parameter, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> finds only the first match in each line of text.</source>
          <target state="translated">Senza questo parametro, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Trova solo la prima corrispondenza in ogni riga di testo.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> finds more than one match in a line of text, it still emits only one <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> object for the line, but the Matches property of the object contains all of the matches.</source>
          <target state="translated">Quando <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> individua più di una corrispondenza in una riga di testo, genera un solo comunque <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> oggetto per la riga, ma la proprietà Matches dell'oggetto contiene tutte le corrispondenze.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>-CaseSensitive</source>
          <target state="translated">-CaseSensitive</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet makes matches case-sensitive.</source>
          <target state="translated">Indica che il cmdlet effettua le corrispondenze tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>By default, matches are not case-sensitive.</source>
          <target state="translated">Per impostazione predefinita, le corrispondenze non fanno distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>-Context</source>
          <target state="translated">: Contesto</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Captures the specified number of lines before and after the line with the match.</source>
          <target state="translated">Acquisisce il numero di righe specificato prima e dopo la riga che contiene la corrispondenza.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This allows you to view the match in context.</source>
          <target state="translated">In questo modo è possibile visualizzare la corrispondenza nel contesto.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If you enter one number as the value of this parameter, that number determines the number of lines captured before and after the match.</source>
          <target state="translated">Se si immette un numero come valore di questo parametro, tale numero determina il numero di righe acquisite prima e dopo la corrispondenza.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>If you enter two numbers as the value, the first number determines the number of lines before the match and the second number determines the number of lines after the match.</source>
          <target state="translated">Se si immettono due numeri come valore, il primo numero determina il numero di righe che precedono la corrispondenza e il secondo numero determina il numero di righe che seguono la corrispondenza.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>In the default display, lines with a match are indicated by a right angle bracket (ASCII 62) in the first column of the display.</source>
          <target state="translated">Nella visualizzazione predefinita, le righe con una corrispondenza sono indicate da una parentesi uncinata chiusa (ASCII 62) nella prima colonna della visualizzazione.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Unmarked lines are the context.</source>
          <target state="translated">Le righe non contrassegnate sono il contesto.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This parameter does not change the number of objects generated by <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</source>
          <target state="translated">Questo parametro non modifica il numero di oggetti generati da <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> generates one <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> (<bpt id="p3">**</bpt>Microsoft.PowerShell.Commands.MatchInfo<ept id="p3">**</ept>) object for each match.</source>
          <target state="translated"><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Genera uno <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> (<bpt id="p3">**</bpt>Microsoft.PowerShell.Commands.MatchInfo<ept id="p3">**</ept>) oggetto per ogni corrispondenza.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The context is stored as an array of strings in the Context property of the object.</source>
          <target state="translated">Il contesto viene archiviato come matrice di stringhe nella proprietà Context dell'oggetto.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>When you pipe the output of a <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> command to another <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> command, the receiving command searches only the text in the matched line (the value of the Line property of the <bpt id="p3">**</bpt>MatchInfo<ept id="p3">**</ept> object), not the text in the context lines.</source>
          <target state="translated">Quando si invia l'output di un <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> comando a un altro <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> comando, il comando ricevente Cerca solo il testo nella riga corrispondente (il valore della proprietà della riga di <bpt id="p3">**</bpt>MatchInfo<ept id="p3">**</ept> oggetto), non il testo nelle righe di contesto.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>As a result, the <bpt id="p1">*</bpt>Context<ept id="p1">*</ept> parameter is not valid on the receiving <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> command.</source>
          <target state="translated">Di conseguenza, il <bpt id="p1">*</bpt>contesto<ept id="p1">*</ept> parametro non è valido per la ricezione <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> comando.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When the context includes a match, the <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object for each match includes all of the context lines, but the overlapping lines appear only once in the display.</source>
          <target state="translated">Quando il contesto include una corrispondenza, il <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> per ogni corrispondenza include tutte le righe di contesto, ma le righe sovrapposte compaiono una sola volta nella visualizzazione dell'oggetto.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>-Encoding</source>
          <target state="translated">-Codifica</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Specifies the character encoding that <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> should assume when searching the file.</source>
          <target state="translated">Specifica la codifica dei caratteri <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> deve considerare durante la ricerca del file.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The default is UTF8.</source>
          <target state="translated">Il valore predefinito è UTF8.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The acceptable values for this parameter are:</source>
          <target state="translated">I valori accettabili per questo parametro sono:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>UTF7</source>
          <target state="translated">UTF7</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>UTF8</source>
          <target state="translated">UTF8</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>UTF32</source>
          <target state="translated">UTF32</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>BigEndianUnicode</source>
          <target state="translated">BigEndianUnicode</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>OEM</source>
          <target state="translated">OEM</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Default is the encoding of the system's current ANSI code page.</source>
          <target state="translated">Valore predefinito è la codifica della tabella codici ANSI corrente del sistema.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>OEM is the current original equipment manufacturer code page identifier for the operating system.</source>
          <target state="translated">OEM è l'identificatore della tabella codici OEM corrente per il sistema operativo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>-Exclude</source>
          <target state="translated">-Exclude</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Specifies an array of items that the cmdlet excludes from the operation.</source>
          <target state="translated">Specifica una matrice di elementi che il cmdlet esclude dall'operazione.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The value of this parameter qualifies the <bpt id="p1">*</bpt>Path<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Il valore di questo parametro qualifica il <bpt id="p1">*</bpt>percorso<ept id="p1">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Enter a path element or pattern, such as *.txt.</source>
          <target state="translated">Immettere un elemento del percorso o un modello, ad esempio *. txt.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Wildcards are permitted.</source>
          <target state="translated">I caratteri jolly sono consentiti.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-Include</source>
          <target state="translated">-Include</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Specifies an array of items that the cmdlet uses in the operation.</source>
          <target state="translated">Specifica una matrice di elementi che il cmdlet viene utilizzato nell'operazione.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The value of this parameter qualifies the <bpt id="p1">*</bpt>Path<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Il valore di questo parametro qualifica il <bpt id="p1">*</bpt>percorso<ept id="p1">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Enter a path element or pattern, such as *.txt.</source>
          <target state="translated">Immettere un elemento del percorso o un modello, ad esempio *. txt.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Wildcards are permitted.</source>
          <target state="translated">I caratteri jolly sono consentiti.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>-InputObject</source>
          <target state="translated">-InputObject</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Specifies the text to be searched.</source>
          <target state="translated">Specifica il testo da cercare.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the text, or type a command or expression that gets the text.</source>
          <target state="translated">Immettere una variabile che contiene il testo oppure digitare un comando o un'espressione che ottiene il testo.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Using the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter is not the same as piping strings to <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept>.</source>
          <target state="translated">Utilizzo di <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parametro non è lo stesso come stringhe tramite pipe a <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The differences are as follows:</source>
          <target state="translated">Le differenze sono le seguenti:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>When you pipe more than one string (a collection) to <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> searches for the specified text in each string and returns each string that contains the search text.</source>
          <target state="translated">Quando si invia tramite pipe più stringhe (insieme) a <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> Cerca il testo specificato in ogni stringa e restituisce ogni stringa che contiene il testo di ricerca.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter to submit a collection of strings, <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> treats the collection as a single combined string and returns the strings as a unit if it finds the search text in any string.</source>
          <target state="translated">Quando si utilizza il <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parametro per inviare una raccolta di stringhe, <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> considera la raccolta come una singola stringa combinata e restituisce le stringhe come unità se trova il testo di ricerca in una stringa.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>-List</source>
          <target state="translated">-Elenco</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet returns only the first match in each input file.</source>
          <target state="translated">Indica che il cmdlet restituisce solo la prima corrispondenza in ogni file di input.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> returns a <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> object for each match it finds.</source>
          <target state="translated">Per impostazione predefinita, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> restituisce un <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> oggetto per ogni corrispondenza trovata.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>-LiteralPath</source>
          <target state="translated">-LiteralPath</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Specifies the path to the files to be searched.</source>
          <target state="translated">Specifica il percorso dei file in cui cercare.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Unlike <bpt id="p1">**</bpt>Path<ept id="p1">**</ept>, the value of the <bpt id="p2">**</bpt>LiteralPath<ept id="p2">**</ept> parameter is used exactly as it is typed.</source>
          <target state="translated">A differenza di <bpt id="p1">**</bpt>percorso<ept id="p1">**</ept>, il valore di <bpt id="p2">**</bpt>LiteralPath<ept id="p2">**</ept> parametro viene usato esattamente com'è digitato.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>No characters are interpreted as wildcards.</source>
          <target state="translated">Nessun carattere viene interpretato come carattere jolly.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If the path includes escape characters, enclose it in single quotation marks.</source>
          <target state="translated">Se il percorso include caratteri di escape, racchiuderlo tra virgolette singole.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Single quotation marks tell Windows PowerShell not to interpret any characters as escape sequences.</source>
          <target state="translated">Le virgolette singole indicano a Windows PowerShell di non interpretare i caratteri come sequenze di escape.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>-NotMatch</source>
          <target state="translated">-NotMatch</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet finds text that does not match the specified pattern.</source>
          <target state="translated">Indica che il cmdlet trova il testo che non corrisponde al modello specificato.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>-Path</source>
          <target state="translated">-Path</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Specifies the path to the files to search.</source>
          <target state="translated">Specifica il percorso dei file da cercare.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Wildcards are permitted.</source>
          <target state="translated">I caratteri jolly sono consentiti.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The default location is the local directory.</source>
          <target state="translated">Il percorso predefinito è la directory locale.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Specify files in the directory, such as log1.txt, <bpt id="p1">*</bpt>.doc, or <ept id="p1">*</ept>.*.</source>
          <target state="translated">Specificare i file nella directory, ad esempio log1. txt, <bpt id="p1">*</bpt>. doc, o <ept id="p1">*</ept>. *.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>If you specify only a directory, the command fails.</source>
          <target state="translated">Se si specifica solo una directory, il comando non riesce.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>-Pattern</source>
          <target state="translated">-Modello</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Specifies the text to find.</source>
          <target state="translated">Specifica il testo da cercare.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Type a string or regular expression.</source>
          <target state="translated">Digitare una stringa o un'espressione regolare.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>If you type a string, use the <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Se si digita una stringa, utilizzare il <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>To learn about regular expressions, see about_Regular_Expressions.</source>
          <target state="translated">Per informazioni sulle espressioni regolari, vedere about_Regular_Expressions.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>-Quiet</source>
          <target state="translated">-Quiet</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet returns a Boolean value (True or False), instead of a <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object.</source>
          <target state="translated">Indica che il cmdlet restituisce un valore booleano (True o False), anziché un <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetto.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>The value is True if the pattern is found; otherwise, the value is False.</source>
          <target state="translated">Il valore è True se viene trovato; in caso contrario, il valore è False.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>-SimpleMatch</source>
          <target state="translated">-SimpleMatch</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Indicates that the cmdlet uses a simple match rather than a regular expression match.</source>
          <target state="translated">Indica che il cmdlet utilizza una corrispondenza semplice anziché una corrispondenza di espressione regolare.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>In a simple match, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> searches the input for the text in the <bpt id="p2">*</bpt>Pattern<ept id="p2">*</ept> parameter.</source>
          <target state="translated">In una corrispondenza semplice <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> Cerca l'input per il testo di <bpt id="p2">*</bpt>modello<ept id="p2">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>It does not interpret the value of the <bpt id="p1">*</bpt>Pattern<ept id="p1">*</ept> parameter as a regular expression statement.</source>
          <target state="translated">Non interpreta il valore di <bpt id="p1">*</bpt>modello<ept id="p1">*</ept> parametro come un'istruzione di espressione regolare.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>CommonParameters</source>
          <target state="translated">CommonParameters</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable.</source>
          <target state="translated">Questo cmdlet supporta i parametri comuni:-eseguire il Debug, - ErrorAction, - ErrorVariable, - InformationAction, InformationVariable-, - OutVariable,-OutBuffer, - PipelineVariable, - Verbose, - WarningAction e - WarningVariable.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For more information, see about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</source>
          <target state="translated">Per ulteriori informazioni, vedere about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>INPUTS</source>
          <target state="translated">INPUT</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>You can pipe any object that has a ToString method to <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</source>
          <target state="translated">È possibile inviare tramite pipe qualsiasi oggetto che dispone di un metodo ToString per <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>OUTPUTS</source>
          <target state="translated">OUTPUT</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Microsoft.PowerShell.Commands.MatchInfo or System.Boolean</source>
          <target state="translated">Microsoft.PowerShell.Commands.MatchInfo o System. Boolean</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>By default, the output is a set of <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> objects, one for each match found.</source>
          <target state="translated">Per impostazione predefinita, l'output è un set di <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetti, uno per ogni corrispondenza trovata.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>If you use the <bpt id="p1">*</bpt>Quiet<ept id="p1">*</ept> parameter, the output is a Boolean value indicating whether the pattern was found.</source>
          <target state="translated">Se si utilizza il <bpt id="p1">*</bpt>Quiet<ept id="p1">*</ept> parametro, l'output è un valore booleano che indica se il modello è stato trovato.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">NOTE</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> is like the Grep command in UNIX and the FindStr command in Windows.</source>
          <target state="translated"><bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> è simile al comando Grep di UNIX e il comando FindStr in Windows.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>sst<ept id="p1">**</ept> alias for the <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> cmdlet was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">Il <bpt id="p1">**</bpt>sst<ept id="p1">**</ept> alias per il <bpt id="p2">**</bpt>Select-String<ept id="p2">**</ept> cmdlet è stato introdotto in Windows PowerShell 3.0.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>To use <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>, type the text that you want to find as the value of the <bpt id="p2">*</bpt>Pattern<ept id="p2">*</ept> parameter.</source>
          <target state="translated">Utilizzare <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>, digitare il testo che si desidera trovare come valore di <bpt id="p2">*</bpt>modello<ept id="p2">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>To specify the text to be searched, do the following:</source>
          <target state="translated">Per specificare il testo da trovare, eseguire le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Type the text in a quoted string, and then pipe it to <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</source>
          <target state="translated">Digitare il testo in una stringa tra virgolette e quindi inviarlo tramite pipe a <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Store a text string in a variable, and then specify the variable as the value of the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter.</source>
          <target state="translated">Archiviare una stringa di testo in una variabile e quindi specificare la variabile come valore di <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parametro.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>If the text is stored in files, use the <bpt id="p1">*</bpt>Path<ept id="p1">*</ept> parameter to specify the path to the files.</source>
          <target state="translated">Se il testo viene archiviato nei file, utilizzare il <bpt id="p1">*</bpt>percorso<ept id="p1">*</ept> parametro per specificare il percorso dei file.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>By default, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> interprets the value of the <bpt id="p2">*</bpt>Pattern<ept id="p2">*</ept> parameter as a regular expression.</source>
          <target state="translated">Per impostazione predefinita, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> interpreta il valore di <bpt id="p2">*</bpt>modello<ept id="p2">*</ept> parametro come un'espressione regolare.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(For more information, see about_Regular_Expressions.) However, you can use the <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parameter to override the regular expression matching.</source>
          <target state="translated">Per altre informazioni, vedere about_Regular_Expressions. Tuttavia, è possibile utilizzare il <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parametro per eseguire l'override di corrispondenze di espressioni regolari.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parameter finds instances of the value of the <bpt id="p2">*</bpt>Pattern<ept id="p2">*</ept> parameter in the input.</source>
          <target state="translated">Il <bpt id="p1">*</bpt>SimpleMatch<ept id="p1">*</ept> parametro visualizzate tutte le occorrenze del valore di <bpt id="p2">*</bpt>modello<ept id="p2">*</ept> parametro di input.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The default output of <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> is a <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> object, which includes detailed information about the matches.</source>
          <target state="translated">L'output predefinito di <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> è un <bpt id="p2">**</bpt>MatchInfo<ept id="p2">**</ept> oggetto, che include informazioni dettagliate sulle corrispondenze.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The information in the object is useful when you are searching for text in files, because <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> objects have properties such as Filename and Line.</source>
          <target state="translated">Le informazioni nell'oggetto sono utile quando esegue una ricerca di testo nei file, perché <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetti dispongono di proprietà come Filename e Line.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When the input is not from the file, the value of these parameters is InputStream.</source>
          <target state="translated">Quando l'input non è presente nel file, il valore di questi parametri è InputStream.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If you do not need the information in the <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object, use the <bpt id="p2">*</bpt>Quiet<ept id="p2">*</ept> parameter, which returns a Boolean value (True or False) to indicate whether it found a match, instead of a <bpt id="p3">**</bpt>MatchInfo<ept id="p3">**</ept> object.</source>
          <target state="translated">Se non è necessario le informazioni contenute nel <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> utilizzare il <bpt id="p2">*</bpt>Quiet<ept id="p2">*</ept> parametro, che restituisce un valore booleano (True o False) per indicare se è stata trovata una corrispondenza, invece di un <bpt id="p3">**</bpt>MatchInfo<ept id="p3">**</ept> oggetto.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>When matching phrases, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> uses the current culture that is set for the system.</source>
          <target state="translated">In caso di corrispondenza delle frasi, <bpt id="p1">**</bpt>Select-String<ept id="p1">**</ept> utilizza le impostazioni cultura correnti impostate per il sistema.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>To find the current culture, use the Get-Culture cmdlet.</source>
          <target state="translated">Per trovare le impostazioni cultura correnti, utilizzare il cmdlet Get-Culture.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>To find the properties of a <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> object, type the following:</source>
          <target state="translated">Per individuare le proprietà di un <bpt id="p1">**</bpt>MatchInfo<ept id="p1">**</ept> oggetto, digitare quanto segue:</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>RELATED LINKS</source>
          <target state="translated">COLLEGAMENTI CORRELATI</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators</source>
          <target state="translated">about_Comparison_Operators</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>about_Regular_Expressions</source>
          <target state="translated">about_Regular_Expressions</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>