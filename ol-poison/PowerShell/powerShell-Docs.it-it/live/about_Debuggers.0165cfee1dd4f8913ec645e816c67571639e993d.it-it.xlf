<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c786ceb4458672696d532d5b8270d93b1e8cdff1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Debuggers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">586a12b6249cea8160d2f9809497d293836bbc3c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d08eb5c290e8115c8fcfa118dc56a6beea7adf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Debuggers</source>
          <target state="translated">Su debugger</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIZIONE BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes the Windows PowerShell debugger.</source>
          <target state="translated">Viene descritto il debugger di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIZIONE LUNGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Debugging is the process of examining a script while it is running to identify and correct errors in the script instructions.</source>
          <target state="translated">Il debug è il processo di analisi di uno script in fase di esecuzione per identificare e correggere gli errori nelle istruzioni di script.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can help you examine and identify errors and inefficiencies in your scripts, functions, commands, Windows PowerShell workflows, Windows PowerShell Desired State Configuration (DSC) configurations, or expressions.</source>
          <target state="translated">Il debugger di Windows PowerShell consentono di esaminare e identificare gli errori e le inefficienze script, funzioni, comandi, i flussi di lavoro di Windows PowerShell, le configurazioni di Windows PowerShell Desired State Configuration (DSC) o espressioni.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, the Windows PowerShell debugger has been updated to debug scripts, functions, workflows, commands, configurations, or expressions that are running in either the console or Windows PowerShell ISE on remote computers.</source>
          <target state="translated">A partire da Windows PowerShell 5.0, il debugger di Windows PowerShell è stato aggiornato per eseguire il debug di script, funzioni, flussi di lavoro, i comandi, le configurazioni o espressioni che eseguono la console o Windows PowerShell ISE in computer remoti.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can run Enter-PSSession to start an interactive remote PowerShell session in which you can set breakpoints and debug script files and commands on the remote computer.</source>
          <target state="translated">È possibile eseguire Enter-PSSession per avviare una remoto PowerShell sessione interattiva in cui è possibile impostare punti di interruzione ed eseguire il debug di file di script e comandi nel computer remoto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running a script or command on a remote computer.</source>
          <target state="translated">Funzionalità di Enter-PSSession è stata aggiornata per la riconnessione e immettere una sessione disconnessa che esegue uno script o un comando in un computer remoto.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">Se lo script in esecuzione raggiunge un punto di interruzione, la sessione client viene automaticamente avviato il debugger.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the disconnected session that is running a script has already hit a breakpoint, and is stopped at the breakpoint, Enter-PSSession automatically starts the command-line debugger, after you reconnect to the session.</source>
          <target state="translated">Se la sessione disconnessa che esegue uno script ha già raggiunto un punto di interruzione e si interrompe al punto di interruzione, Enter-PSSession viene avviato automaticamente il debugger della riga di comando, dopo la riconnessione della sessione.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can also be used to debug Windows PowerShell workflows, in either the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Il debugger di Windows PowerShell può essere utilizzato anche per eseguire il debug di flussi di lavoro di Windows PowerShell, nella console Windows PowerShell o in Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can debug within running jobs or processes, either locally or remotely.</source>
          <target state="translated">A partire da Windows PowerShell 5.0, è possibile eseguire il debug all'interno di processi e processi in esecuzione, in locale o remoto.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use the features of the Windows PowerShell debugger to examine a Windows PowerShell script, function, command, workflow, or expression while it is running.</source>
          <target state="translated">È possibile utilizzare le funzionalità del debugger di Windows PowerShell per esaminare un script, funzione, comando, flusso di lavoro o espressione di Windows PowerShell in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger includes a set of cmdlets that let you set breakpoints, manage breakpoints, and view the call stack.</source>
          <target state="translated">Il debugger di Windows PowerShell include un set di cmdlet che consentono di impostare punti di interruzione, gestire i punti di interruzione e visualizzare lo stack di chiamate.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Debugger Cmdlets The Windows PowerShell debugger includes the following set of cmdlets:</source>
          <target state="translated">Debugger di cmdlet Windows PowerShell debugger include il set di cmdlet seguente:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Set-PsBreakpoint:     Sets breakpoints on lines, variables, and commands.</source>
          <target state="translated">Set-PsBreakpoint: Imposta punti di interruzione nelle righe, le variabili e comandi.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Get-PsBreakpoint:     Gets breakpoints in the current session.</source>
          <target state="translated">Get-PsBreakpoint: Ottiene i punti di interruzione nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint: Turns off breakpoints in the current session.</source>
          <target state="translated">Disable-PsBreakpoint: Consente di disattivare i punti di interruzione nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enable-PsBreakpoint:  Re-enables breakpoints in the current session.</source>
          <target state="translated">Enable-PsBreakpoint: Abilita nuovamente i punti di interruzione nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Remove-PsBreakpoint:  Deletes breakpoints from the current session.</source>
          <target state="translated">Remove-PsBreakpoint: Elimina i punti di interruzione dalla sessione corrente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Get-PsCallStack:      Displays the current call stack.</source>
          <target state="translated">Get-PsCallStack: Consente di visualizzare lo stack di chiamate corrente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Starting and Stopping the Debugger To start the debugger, set one or more breakpoints.</source>
          <target state="translated">Avviare e arrestare il Debugger per avviare il debugger, impostare uno o più punti di interruzione.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Then, run the script, command, or function that you want to debug.</source>
          <target state="translated">Quindi, eseguire lo script, comando o funzione che si desidera eseguire il debug.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When you reach a breakpoint, execution stops, and control is turned over to the debugger.</source>
          <target state="translated">Quando si raggiunge un punto di interruzione, l'esecuzione viene arrestata e il controllo è attivato al debugger.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To stop the debugger, run the script, command, or function until it is complete.</source>
          <target state="translated">Per arrestare il debugger, eseguire lo script, un comando o una funzione fino al completamento.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Or, type "stop" or "t".</source>
          <target state="translated">In alternativa, digitare "stop" o "t".</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Debugger Commands When you use the debugger in the Windows PowerShell console, use the following commands to control the execution.</source>
          <target state="translated">Quando i comandi del debugger è utilizzare il debugger nella console di Windows PowerShell, usare i comandi seguenti per controllare l'esecuzione.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell ISE, use commands on the Debug menu.</source>
          <target state="translated">In Windows PowerShell ISE, utilizzare i comandi dal menu Debug.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note: For information about how to use the debugger in other host applications, see the host application documentation.</source>
          <target state="translated">Nota: Per informazioni su come utilizzare il debugger in altre applicazioni host, vedere la documentazione dell'applicazione host.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>s, Step-into        Executes the next statement and then stops.</source>
          <target state="translated">s, istruzione esegue l'istruzione successiva e quindi si arresta.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>v, Step-over        Executes the next statement, but skips functions and invocations.</source>
          <target state="translated">v, il passaggio esegue l'istruzione successiva, ma ignora le funzioni e chiamate.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Le istruzioni ignorate vengono eseguite, ma non una alla volta.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Ctrl+Break (Break All in ISE)  Breaks into a running script within either the Windows PowerShell console, or Windows PowerShell ISE.</source>
          <target state="translated">CTRL + INTERR (Interrompi tutto in ISE) si interrompe in uno script in esecuzione all'interno, la console di Windows PowerShell o Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that Ctrl+Break in Windows PowerShell 2.0, 3.0, and 4.0 closes the program.</source>
          <target state="translated">Si noti che il programma viene chiuso da Ctrl + INTERR in Windows PowerShell 2.0, 3.0 e 4.0.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Break All works on both local and remote interactively-running scripts.</source>
          <target state="translated">Interrompere tutte le attività eseguite in locale e remoto script in modo interattivo a esecuzione prolungata.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>o, Step-out         Steps out of the current function; up one level if nested.</source>
          <target state="translated">o,-Esci esce dalla funzione corrente. al superiore livello se nidificate.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If in the main body, it continues to the end or the next breakpoint.</source>
          <target state="translated">Se nel corpo principale, continuano a fine o il punto di interruzione successivo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Le istruzioni ignorate vengono eseguite, ma non una alla volta.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>c, Continue         Continues to run until the script is complete or until the next breakpoint is reached.</source>
          <target state="translated">c, continuare l'esecuzione continua fino a quando lo script è stato completato o finché non viene raggiunto il punto di interruzione successivo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">Le istruzioni ignorate vengono eseguite, ma non una alla volta.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>l, List             Displays the part of the script that is executing.</source>
          <target state="translated">l, elenco, viene visualizzata la parte dello script che è in esecuzione.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, it displays the current line, five previous lines, and 10 subsequent lines.</source>
          <target state="translated">Per impostazione predefinita, Visualizza la riga corrente e cinque righe precedenti 10 righe successive.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To continue listing the script, press ENTER.</source>
          <target state="translated">Per continuare a elencare lo script, premere INVIO.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph>, List         Displays 16 lines of the script beginning with the line number specified by <ph id="ph2">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph>, righe 16 Visualizza elenco di inizio script con il numero di riga specificato da <ph id="ph2">&lt;m&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, List     Displays <ph id="ph3">&lt;n&gt;</ph> lines of the script, beginning with the line number specified by <ph id="ph4">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, visualizzazioni elenco <ph id="ph3">&lt;n&gt;</ph> righe dello script, che iniziano con il numero di riga specificato da <ph id="ph4">&lt;m&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>q, Stop, Exit       Stops executing the script, and exits the debugger.</source>
          <target state="translated">q, arrestare, uscita interrompe l'esecuzione dello script e chiude il debugger.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you are debugging a job by running the Debug-Job cmdlet, the Exit command detaches the debugger, and allows the job to continue running.</source>
          <target state="translated">Se si esegue il debug di un processo eseguendo il cmdlet di processo di Debug, il comando Exit disconnette il debugger e consente di continuare l'esecuzione del processo.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>k, Get-PsCallStack  Displays the current call stack.</source>
          <target state="translated">k, Get-PsCallStack Visualizza lo stack di chiamate corrente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Repeats the last command if it was Step (s), Step-over (v), or List (l).</source>
          <target state="translated">Ripete l'ultimo comando se si trattasse di passaggio (s), il passaggio (v) o un elenco (l).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, represents a submit action.</source>
          <target state="translated">In caso contrario, rappresenta un'azione di invio.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>?, h                Displays the debugger command Help.</source>
          <target state="translated">?, h Visualizza le informazioni sui comandi del debugger.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To exit the debugger, you can use Stop (q).</source>
          <target state="translated">Per uscire dal debugger, è possibile utilizzare Stop (q).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can run the Exit command to exit a nested debugging session that you started by running either Debug-Job or Debug-Runspace.</source>
          <target state="translated">A partire da Windows PowerShell 5.0, è possibile eseguire il comando Exit per chiudere una sessione di debug annidata che è stato avviato l'esecuzione di processi di Debug o Debug spazio di esecuzione.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By using these debugger commands, you can run a script, stop on a point of concern, examine the values of variables and the state of the system, and continue running the script until you have identified a problem.</source>
          <target state="translated">Utilizzando i comandi del debugger, è possibile eseguire uno script, interrompere su un punto di interesse, esaminare i valori delle variabili e lo stato del sistema e continuare l'esecuzione dello script fino a quando non è stato identificato un problema.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>NOTE:  If you step into a statement with a redirection operator, such as "&gt;", the Windows PowerShell debugger steps over all remaining statements in the script.</source>
          <target state="translated">NOTA: Se si esegue un'istruzione con un operatore di reindirizzamento, ad esempio "&gt;", il debugger di Windows PowerShell passaggi su tutte le restanti istruzioni nello script.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Displaying the Values of script Variables</source>
          <target state="translated">Visualizzazione dei valori delle variabili di script</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>While you are in the debugger, you can also enter commands, display the value of variables, use cmdlets, and run scripts at the command line.</source>
          <target state="translated">Mentre si è nel debugger, è anche possibile immettere i comandi, visualizzare il valore delle variabili, utilizzare i cmdlet ed eseguire script dalla riga di comando.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can display the current value of all variables in the script that is being debugged, except for the following automatic variables:</source>
          <target state="translated">È possibile visualizzare il valore corrente di tutte le variabili nello script che viene eseguito il debug, tranne le seguenti variabili automatiche:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>$Args $Input $MyInvocation $PSBoundParameters</source>
          <target state="translated">$Args $Input $MyInvocation $PSBoundParameters</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you try to display the value of any of these variables, you get the value of that variable for in an internal pipeline the debugger uses, not the value of the variable in the script.</source>
          <target state="translated">Se si prova a visualizzare il valore di una di queste variabili, si ottiene il valore della variabile per una pipeline interna usata dal debugger, non il valore della variabile nello script.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To display the value these variables for the script that is being debugged, in the script, assign the value of the automatic variable to a new variable.</source>
          <target state="translated">Per visualizzare il valore per lo script che viene eseguito il debug, queste variabili nello script, assegnare il valore della variabile automatica a una nuova variabile.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Then you can display the value of the new variable.</source>
          <target state="translated">È quindi possibile visualizzare il valore della nuova variabile.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>$scriptArgs = $Args $scriptArgs</source>
          <target state="translated">$scriptArgs = $Args $scriptArgs</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the example in this topic, the value of the $MyInvocation variable is reassigned as follows:</source>
          <target state="translated">Nell'esempio in questo argomento, il valore della variabile $MyInvocation viene riassegnato come indicato di seguito:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Debugger Environment When you reach a breakpoint, you enter the debugger environment.</source>
          <target state="translated">Il Debugger ambiente si raggiunge un punto di interruzione, immettere l'ambiente del debugger.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The command prompt changes so that it begins with "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</source>
          <target state="translated">Il comando prompt cambia in modo che inizia con "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you are debugging a workflow, the prompt is "[WFDBG]".</source>
          <target state="translated">Se si esegue il debug di un flusso di lavoro, la richiesta è "[WFDBG]".</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can customize the prompt.</source>
          <target state="translated">È possibile personalizzare il prompt dei comandi.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, in some host applications, such as the Windows PowerShell console, (but not in Windows PowerShell Integrated Scripting Environment [ISE]), a nested prompt opens for debugging.</source>
          <target state="translated">Inoltre, in alcune applicazioni host, ad esempio la console di Windows PowerShell (ma non in Windows PowerShell Integrated Scripting Environment [ISE]), verrà visualizzata una richiesta nidificata per il debug.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can detect the nested prompt by the repeating greater-than characters (ASCII 62) that appear at the command prompt.</source>
          <target state="translated">È possibile rilevare il prompt nidificato ripetendo la maggiore-di caratteri (ASCII 62) che vengono visualizzate al prompt dei comandi.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, the following is the default debugging prompt in the Windows PowerShell console:</source>
          <target state="translated">Di seguito è ad esempio, il prompt dei comandi nella console di Windows PowerShell di debug predefinito:</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">FILE DBG</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can find the nesting level by using the $NestedPromptLevel automatic variable.</source>
          <target state="translated">È possibile trovare il livello di nidificazione utilizzando la variabile automatica $NestedPromptLevel.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Additionally, an automatic variable, $PSDebugContext, is defined in the local scope.</source>
          <target state="translated">Inoltre, una variabile automatica, $PSDebugContext, è definita nell'ambito locale.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use the presence of the $PsDebugContext variable to determine whether you are in the debugger.</source>
          <target state="translated">È possibile utilizzare la presenza della variabile $PsDebugContext per determinare se ci si trova nel debugger.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>if ($psdebugcontext) {"Debugging"} else {"Not Debugging"}</source>
          <target state="translated">Se ($psdebugcontext) {"debug"} else {"non eseguire debug"}</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the value of the $PSDebugContext variable in your debugging.</source>
          <target state="translated">È possibile utilizzare il valore della variabile $PSDebugContext l'esecuzione del debug.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">FILE DBG</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Name   CommandLineParameters  UnboundArguments  Location</source>
          <target state="translated">Nome CommandLineParameters UnboundArguments percorso</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>=      {}                     {}                C:\ps-test\vote.ps1 (1)</source>
          <target state="translated">= {} {C:\ps-test\vote.ps1 (1)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Debugging and Scope Breaking into the debugger does not change the scope in which you are operating, but when you reach a breakpoint in a script, you move into the script scope.</source>
          <target state="translated">Ambito interruzione del debugger e debug non modificare l'ambito in cui si opera, ma quando si raggiunge un punto di interruzione in uno script, si sposta nell'ambito dello script.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The script scope is a child of the scope in which you ran the debugger.</source>
          <target state="translated">L'ambito dello script è un figlio dell'ambito in cui è stato eseguito il debugger.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To find the variables and aliases that are defined in the script scope, use the Scope parameter of the Get-Alias or Get-Variable cmdlets.</source>
          <target state="translated">Per trovare le variabili e gli alias definiti nell'ambito dello script, utilizzare il parametro di ambito dei cmdlet Get-Alias o Get-Variable.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the variables in the local (script) scope:</source>
          <target state="translated">Ad esempio, il comando seguente ottiene le variabili nell'ambito locale (script):</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>get-variable -scope 0</source>
          <target state="translated">Get-variable - ambito 0</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">È possibile abbreviare il comando come:</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>gv -s 0</source>
          <target state="translated">GV -s 0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is a useful way to see only the variables that you defined in the script and that you defined while debugging.</source>
          <target state="translated">Ciò è utile per visualizzare solo le variabili definite nello script e che sia definita durante il debug.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Debugging at the Command Line When you set a variable breakpoint or a command breakpoint, you can set the breakpoint only in a script file.</source>
          <target state="translated">Il debug nella riga di comando quando si imposta un punto di interruzione variabile o un punto di interruzione del comando, è possibile impostare il punto di interruzione solo in un file di script.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, by default, the breakpoint is set on anything that runs in the current session.</source>
          <target state="translated">Tuttavia, per impostazione predefinita, il punto di interruzione è impostato su tutto ciò che viene eseguito nella sessione corrente.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if you set a breakpoint on the $name variable, the debugger breaks on any $name variable in any script, command, function, script cmdlet or expression that you run until you disable or remove the breakpoint.</source>
          <target state="translated">Ad esempio, se si imposta un punto di interruzione nella variabile $name, il debugger si interrompe in qualsiasi variabile $ $name in qualsiasi script, comandi, funzioni, cmdlet script o espressione che si esegue fino a quando non si disabilita o rimuove il punto di interruzione.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This allows you to debug your scripts in a more realistic context in which they might be affected by functions, variables, and other scripts in the session and in the user's profile.</source>
          <target state="translated">Ciò consente di eseguire il debug di script in un contesto più realistico in cui che potrebbero essere influenzati dalle funzioni, variabili e altri script nella sessione e nel profilo dell'utente.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Line breakpoints are specific to script files, so they are set only in script files.</source>
          <target state="translated">I punti di interruzione di riga sono specifici per i file di script, pertanto sono impostate solo nei file di script.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Debugging Workflows The Windows PowerShell 4.0 debugger can be used to debug Windows PowerShell workflows, either in the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Debug dei flussi di lavoro di Windows PowerShell 4.0 debugger può essere usato per eseguire il debug di flussi di lavoro di Windows PowerShell, nella console di Windows PowerShell o in Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There are some limitations with using the Windows PowerShell debugger to debug workflows.</source>
          <target state="translated">Esistono alcune limitazioni all'utilizzo del debugger di Windows PowerShell per eseguire il debug dei flussi di lavoro.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>-- You can view workflow variables while you are in the debugger, but setting workflow variables from within the debugger is not supported.</source>
          <target state="translated">-È possibile visualizzare le variabili del flusso di lavoro mentre si è nel debugger, ma l'impostazione di variabili del flusso di lavoro all'interno del debugger non è supportata.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>-- Tab completion when stopped in the workflow debugger is not available.</source>
          <target state="translated">Completamento tramite tab quando si è interrotta nel debugger del flusso di lavoro non è disponibile.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>-- Workflow debugging works only with synchronous running of workflows from a Windows PowerShell script.</source>
          <target state="translated">-Debug flusso di lavoro funziona solo con l'esecuzione sincrona dei flussi di lavoro da uno script di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot debug workflows if they are running as a job (with the –AsJob parameter).</source>
          <target state="translated">È possibile eseguire il debug di flussi di lavoro se sono in esecuzione come processo (con il parametro AsJob).</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-- Other nested debugging scenarios--such as a workflow calling another workflow, or a workflow calling a script--are not implemented.</source>
          <target state="translated">-Altri scenari di debug nidificate: ad esempio un flusso di lavoro chiama un altro flusso di lavoro o un flusso di lavoro chiamare uno script, non sono implementate.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example demonstrates debugging a workflow.</source>
          <target state="translated">Nell'esempio seguente viene illustrato il debug di un flusso di lavoro.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that when the debugger steps into the workflow function, the debugger prompt changes to [WFDBG].</source>
          <target state="translated">Si noti che quando il debugger esegue la funzione di flusso di lavoro, il prompt dei comandi del debugger a [WFDBG].</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Set-PSBreakpoint -Script C:\TestWFDemo1.ps1 -Line 8</source>
          <target state="translated">PS C: &gt; Set-PSBreakpoint-Script C:\TestWFDemo1.ps1-Line 8</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ID Script           Line Command    Variable     Action</source>
          <target state="translated">Variabile azione di Script ID riga comando</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>0 TestWFDemo1.ps1   8</source>
          <target state="translated">0 TestWFDemo1.ps1 8</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>PS C:&gt; C:\TestWFDemo1.ps1 Entering debug mode.</source>
          <target state="translated">PS C: &gt; C:\TestWFDemo1.ps1 immettendo la modalità di debug.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Utilizzare h o?</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Per assistenza.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\TestWFDemo1.ps1:8'</source>
          <target state="translated">Interruzione di riga in 'C:\TestWFDemo1.ps1:8'</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>At C:\TestWFDemo1.ps1:8 char:5</source>
          <target state="translated">C:\TestWFDemo1.ps1:8 char: 5</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Now writing output:"</source>
          <target state="translated">Write-Output - InputObject "ora la scrittura dell'output:"</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~</source>
          <target state="translated">+! INCLUDERE [~ ~ ~</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>3:</source>
          <target state="translated">3:</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: flusso di lavoro SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>8:*     Write-Output -InputObject "Now writing output:" 9:      Write-Output -Input $MyOutput</source>
          <target state="translated">8: * write-Output - InputObject "ora la scrittura dell'output:" 9: Write-Output - Input $MyOutput</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: write-Output - InputObject "ottenere il processo di PowerShell:" 12: Get-Process - nome powershell</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: write-Output - InputObject "Funzione del flusso di lavoro completata."</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # chiamata di funzione di flusso di lavoro 18: SampleWorkflowTest - MyOutput "Hello"</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">Hello</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Now writing output: At C:\TestWFDemo1.ps1:9 char:5</source>
          <target state="translated">A questo punto la scrittura dell'output: C:\TestWFDemo1.ps1:9 in char: 5</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Write-Output -Input $MyOutput</source>
          <target state="translated">Write-Output - $MyOutput di Input</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~</source>
          <target state="translated">+! INCLUDERE ~</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: flusso di lavoro SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>8:      Write-Output -InputObject "Now writing output:" 9:*     Write-Output -Input $MyOutput</source>
          <target state="translated">8: write-Output - InputObject "ora la scrittura dell'output:" 9: * Write-Output - Input $MyOutput</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: write-Output - InputObject "ottenere il processo di PowerShell:" 12: Get-Process - nome powershell</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: write-Output - InputObject "Funzione del flusso di lavoro completata."</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # chiamata di funzione di flusso di lavoro 18: SampleWorkflowTest - MyOutput "Hello"</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Hello At C:\TestWFDemo1.ps1:11 char:5</source>
          <target state="translated">Hello in C:\TestWFDemo1.ps1:11 char: 5</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Get PowerShell process:"</source>
          <target state="translated">Write-Output - InputObject "ottenere il processo di PowerShell:"</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~</source>
          <target state="translated">+! INCLUDERE [~ ~ ~</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Get PowerShell process:</source>
          <target state="translated">Ottenere il processo di PowerShell:</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)   WS(K) VM(M)   CPU(s)     Id ProcessName    PSComputerName</source>
          <target state="translated">Gestisce NPM(K) PM(K) WS(K) VM(M) Id CPU ProcessName PSComputerName</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>433      35   106688   128392   726     2.67   7124 powershell    localhost 499      44   134244   172096   787     2.79   7452 powershell    localhost Workflow function complete.</source>
          <target state="translated">433 35 106688 128392 726 2.67 7124 powershell localhost 499 44 134244 172096 787 2.79 7452 powershell localhost funzione del flusso di lavoro completato.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Debugging Functions When you set a breakpoint on a function that has Begin, Process, and End sections, the debugger breaks at the first line of each section.</source>
          <target state="translated">Debug di funzioni quando si imposta un punto di interruzione in una funzione che dispone di sezioni Begin, Process ed End, il debugger si interrompe alla prima riga di ogni sezione.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>function test-cmdlet { begin { write-output "Begin" } process { write-output "Process" } end { write-output "End" } }</source>
          <target state="translated">funzione cmdlet test-{iniziare fine processo {write-output "processo"} {write-output "Begin"} {write-output "End"}}</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; set-psbreakpoint -command test-cmdlet</source>
          <target state="translated">C:\ps&gt; &gt; set-psbreakpoint-cmdlet test-comando</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; test-cmdlet</source>
          <target state="translated">C:\ps&gt; &gt; cmdlet test-</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Begin Entering debug mode.</source>
          <target state="translated">Iniziare a immettere la modalità di debug.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Utilizzare h o?</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Per assistenza.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Raggiunto punto di interruzione comando ' prompt dei comandi: test-cmdlet'</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">cmdlet di prova</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">FILE DBG</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Process Entering debug mode.</source>
          <target state="translated">Elaborare immettere la modalità di debug.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Utilizzare h o?</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Per assistenza.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Raggiunto punto di interruzione comando ' prompt dei comandi: test-cmdlet'</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">cmdlet di prova</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">FILE DBG</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Entering debug mode.</source>
          <target state="translated">Modalità di debug immettere finale.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Utilizzare h o?</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Per assistenza.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">Raggiunto punto di interruzione comando ' prompt dei comandi: test-cmdlet'</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">cmdlet di prova</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;</source>
          <target state="translated"><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;GET-APPLOCKERPOLICY &gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Debugging Remote Scripts Starting in Windows PowerShell 5.0, you can run the Windows PowerShell debugger in a remote session, in either the console, or Windows PowerShell ISE.</source>
          <target state="translated">Debug remoto script a partire da Windows PowerShell 5.0, è possibile eseguire il debugger di Windows PowerShell in una sessione remota, in, la console o Windows PowerShell ISE.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running on a remote computer, and currently running a script.</source>
          <target state="translated">Funzionalità di Enter-PSSession è stata aggiornata per la riconnessione e immettere una sessione disconnessa è in esecuzione in un computer remoto e attualmente in esecuzione uno script.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">Se lo script in esecuzione raggiunge un punto di interruzione, la sessione client viene automaticamente avviato il debugger.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following is an example that shows how this works, with breakpoints set in a script at lines 6, 11, 22, and 25.</source>
          <target state="translated">Di seguito è riportato un esempio che illustra il funzionamento, i punti di interruzione impostati in uno script le righe 6, 11, 22 e 25.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Note that in the example, when the debugger starts, there are two identifying prompts: the name of the computer on which the session is running, and the DBG prompt that lets you know you are in debugging mode.</source>
          <target state="translated">Si noti che nell'esempio, quando il debugger viene avviato, esistono due richieste di identificazione: il nome del computer in cui la sessione è in esecuzione e il messaggio di richiesta DBG informa l'utente si è in modalità di debug.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Enter-Pssession -Cn localhost</source>
          <target state="translated">Enter-Pssession - Cn localhost</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>ID Script          Line     Command          Variable          Action</source>
          <target state="translated">Variabile azione di Script ID riga comando</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0 ttest19.ps1          6 1 ttest19.ps1          11 2 ttest19.ps1          22 3 ttest19.ps1          25</source>
          <target state="translated">ttest19.ps1 0 1 6 ttest19.ps1 11 2 ttest19.ps1 3 22 ttest19.ps1 25</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\psscripts\ttest19.ps1:11'</source>
          <target state="translated">Interruzione di riga in 'C:\psscripts\ttest19.ps1:11'</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:11 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:11 char: 1</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>$winRMName = "WinRM"</source>
          <target state="translated">$winRMName = "Gestione remota Windows"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>6:      1..5 | foreach { sleep 1; Write-Output "hello2day $_" } 7:  }</source>
          <target state="translated">6: 1..5 | foreach {sospensione 1; Write-Output "_ $hello2day"} 7:}</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>8:</source>
          <target state="translated">8:</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>9:  $count = 10 10:  $psName = "PowerShell" 11:* $winRMName = "WinRM" 12:  $myVar = 102</source>
          <target state="translated">9: $count = 10 10: $psName = "PowerShell" 11: * $winRMName = "WinRM" 12: $myVar = 102</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>14:  for ($i=0; $i -lt $count; $i++) 15:  { 16:      sleep 1 17:      Write-Output "Loop iteration is: $i" 18:      Write-Output "MyVar is $myVar"</source>
          <target state="translated">14: per ($i = 0; $count $i - lt; $i + +) 15: {16: sospensione 1 17: Write-Output "iterazione del ciclo è: $i" 18: Write-Output "MyVar è $myVar"</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>20:      hello2day</source>
          <target state="translated">20: hello2day</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>21:</source>
          <target state="translated">21:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:12 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:12 char: 1</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>$myVar = 102</source>
          <target state="translated">$myVar = 102</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>PS C:\psscripts&gt;</source>
          <target state="translated">PS C:\psscripts &gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Examples This test script detects the version of the operating system and displays a system-appropriate message.</source>
          <target state="translated">Esempi di questo script di test rileva la versione del sistema operativo e viene visualizzato un messaggio appropriato al sistema.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It includes a function, a function call, and a variable.</source>
          <target state="translated">Include una funzione, una chiamata di funzione e una variabile.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following command displays the contents of the test script file:</source>
          <target state="translated">Il comando seguente visualizza il contenuto del file di script di test:</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>c:&gt;\PS-test&gt;  get-content test.ps1</source>
          <target state="translated">c: &gt; \PS-test &gt; get-content ps1</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>function psversion { "Windows PowerShell " + $psversiontable.psversion if ($psversiontable.psversion.major -lt 2) { "Upgrade to Windows PowerShell 2.0!"</source>
          <target state="translated">funzione psversion {"Windows PowerShell" + $psversiontable.psversion se ($psversiontable.psversion.major - lt 2) {"l'aggiornamento a Windows PowerShell 2.0!"</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>} else { "Have you run a background job today (start-job)?"</source>
          <target state="translated">} else {"hanno è eseguire un processo in background oggi (processo di avvio)?"</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>} }</source>
          <target state="translated">} }</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path psversion "Done $scriptname."</source>
          <target state="translated">$scriptname = psversion $MyInvocation.MyCommand.Path "$scriptname completata".</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To start, set a breakpoint at a point of interest in the script, such as a line, command, variable, or function.</source>
          <target state="translated">Per iniziare, impostare un punto di interruzione in un punto di interesse nello script, ad esempio una riga, comando, variabile o funzione.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Start by creating a line breakpoint on the first line of the Test.ps1 script in the current directory.</source>
          <target state="translated">Iniziare creando un punto di interruzione di riga nella prima riga dello script ps1 nella directory corrente.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -line 1 -script test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; set-psbreakpoint-riga 1 - script ps1</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">È possibile abbreviare il comando in</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; spb 1 -s test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; spb 1 -s ps1</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The command returns a line-breakpoint object (System.Management.Automation.LineBreakpoint).</source>
          <target state="translated">Il comando restituisce un oggetto punto di interruzione riga (System.Management.Automation.LineBreakpoint).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Column     : 0 Line       : 1 Action     : Enabled    : True HitCount   : 0 Id         : 0 Script     : C:\ps-test\test.ps1 ScriptName : C:\ps-test\test.ps1</source>
          <target state="translated">Colonna: riga 0: 1 azione: attivato: True HitCount: Id 0: 0 Script: ScriptName C:\ps-test\test.ps1: C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">A questo punto, avviare lo script.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt;.\test.ps1</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When the script reaches the first breakpoint, the breakpoint message indicates that the debugger is active.</source>
          <target state="translated">Quando lo script raggiunge il primo punto di interruzione, il messaggio di punto di interruzione indica che il debugger è attivo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It describes the breakpoint and previews the first line of the script, which is a function declaration.</source>
          <target state="translated">Descrive il punto di interruzione e visualizza in anteprima la prima riga dello script, ovvero una dichiarazione di funzione.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The command prompt also changes to indicate that the debugger has control.</source>
          <target state="translated">Prompt dei comandi cambia anche per indicare che il debugger disponga del controllo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The preview line includes the script name and the line number of the previewed command.</source>
          <target state="translated">La riga di anteprima include il nome dello script e il numero di riga di comando in anteprima.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Entering debug mode.</source>
          <target state="translated">Modalità di debug.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">Utilizzare h o?</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">Per assistenza.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\ps-test\test.ps1:1'</source>
          <target state="translated">Interruzione di riga in 'C:\ps-test\test.ps1:1'</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>test.ps1:1   function psversion {</source>
          <target state="translated">{psversion di test.ps1:1 (funzione)</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Use the Step command (s) to execute the first statement in the script and to preview the next statement.</source>
          <target state="translated">Utilizzare il comando del passaggio (s) per eseguire la prima istruzione nello script e visualizzare in anteprima l'istruzione successiva.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The next statement uses the $MyInvocation automatic variable to set the value of the $ScriptName variable to the path and file name of the script file.</source>
          <target state="translated">L'istruzione successiva viene utilizzata la variabile automatica $MyInvocation per impostare il valore della variabile $ScriptName per il percorso e il nome del file di script.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:11  $scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">DBG &gt; s test.ps1:11 $scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is not populated, but you can verify the value of the variable by displaying its value.</source>
          <target state="translated">A questo punto, la variabile $ScriptName non viene popolata, ma è possibile verificare il valore della variabile visualizzando il relativo valore.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In this case, the value is $null.</source>
          <target state="translated">In questo caso, il valore è $null.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Use another Step command (s) to execute the current statement and to preview the next statement in the script.</source>
          <target state="translated">Utilizzare un altro comando del passaggio (s) per eseguire l'istruzione corrente e per visualizzare in anteprima l'istruzione successiva nello script.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The next statement calls the PsVersion function.</source>
          <target state="translated">L'istruzione successiva chiama la funzione PsVersion.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is populated, but you verify the value of the variable by displaying its value.</source>
          <target state="translated">A questo punto, la variabile $ScriptName viene popolata, ma si verifica il valore della variabile visualizzando il relativo valore.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>In this case, the value is set to the script path.</source>
          <target state="translated">In questo caso, il valore è impostato per il percorso dello script.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Use another Step command to execute the function call.</source>
          <target state="translated">Utilizzare un altro comando del passaggio per eseguire la chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Press ENTER, or type "s" for Step.</source>
          <target state="translated">Premere INVIO oppure digitare "s" per passaggio.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:2       "Windows PowerShell " + $psversiontable.psversion</source>
          <target state="translated">DBG &gt; s test.ps1:2 "Windows PowerShell" + $psversiontable.psversion</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The debug message includes a preview of the statement in the function.</source>
          <target state="translated">Il messaggio di debug include un'anteprima dell'istruzione nella funzione.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To execute this statement and to preview the next statement in the function, you can use a Step command.</source>
          <target state="translated">Per eseguire questa istruzione e l'istruzione successiva nella funzione di anteprima, è possibile utilizzare un comando del passaggio.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But, in this case, use a Step-Out command (o).</source>
          <target state="translated">Ma, in questo caso, utilizzare un comando Step-Out (o).</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It completes the execution of the function (unless it reaches a breakpoint) and steps to the next statement in the script.</source>
          <target state="translated">Esegue l'esecuzione della funzione (a meno che non raggiunge un punto di interruzione) e i passaggi per l'istruzione successiva nello script.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>DBG&gt; o Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; o Windows PowerShell 2.0 è eseguire un processo in background oggi (processo di avvio)?</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">test.ps1:13 "Done $scriptname"</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Because we are on the last statement in the script, the Step, Step-Out, and Continue commands have the same effect.</source>
          <target state="translated">Poiché stiamo per l'ultima istruzione nello script, il passaggio Step-Out e continua comandi hanno lo stesso effetto.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In this case, use Step-Out (o).</source>
          <target state="translated">In questo caso, utilizzare Esci (o).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1 PS C:\ps-test&gt;</source>
          <target state="translated">Fatto c:\ps-test. C:\ps-test\test.ps1 PS &gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The Step-Out command executes the last command.</source>
          <target state="translated">Il comando Step-Out viene eseguito l'ultimo comando.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The standard command prompt indicates that the debugger has exited and returned control to the command processor.</source>
          <target state="translated">Prompt dei comandi standard indica che il debugger ha terminato e restituzione del controllo per il processore dei comandi.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Now, run the debugger again.</source>
          <target state="translated">A questo punto, eseguire nuovamente il debugger.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>First, to delete the current breakpoint, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">In primo luogo, per eliminare il punto di interruzione corrente, utilizzare il cmdlet Get-PsBreakpoint e Remove-PsBreakpoint.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>(If you think you might reuse the breakpoint, use the Disable-PsBreakpoint cmdlet instead of Remove-PsBreakpoint.)</source>
          <target state="translated">(Se si ritiene che è possibile riutilizzare il punto di interruzione, utilizzare il cmdlet Disable-PsBreakpoint anziché Remove-PsBreakpoint.)</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test. &gt; Get-PsBreakpoint | Remove-PSBreakpoint</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">È possibile abbreviare il comando in</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; gbp | rbp</source>
          <target state="translated">PS C:\ps-test. &gt; gbp | RBP</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Or, run the command by writing a function, such as the following function:</source>
          <target state="translated">In alternativa, eseguire il comando scrivendo una funzione, ad esempio la funzione seguente:</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>function delbr { gbp | rbp }</source>
          <target state="translated">funzione delbr {gbp | rbp}</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Now, create a breakpoint on the $scriptname variable.</source>
          <target state="translated">A questo punto, creare un punto di interruzione nella variabile $scriptname.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -variable scriptname -script test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; set-psbreakpoint-scriptname variabile-script ps1</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">È possibile abbreviare il comando come:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -v scriptname -s test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; sbp - v scriptname -s ps1</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">A questo punto, avviare lo script.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The script reaches the variable breakpoint.</source>
          <target state="translated">Lo script raggiunge il punto di interruzione variabile.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The default mode is Write, so execution stops just before the statement that changes the value of the variable.</source>
          <target state="translated">La modalità predefinita è Write, pertanto l'esecuzione viene arrestata prima dell'istruzione che modifica il valore della variabile.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Variable breakpoint on 'C:\ps-test\test.ps1:$scriptname' (Write access)</source>
          <target state="translated">PS C:\ps-test. &gt; punto di interruzione raggiunto variabile.\test.ps1 su 'C:\ps-test\test.ps1:$scriptname' (accesso in scrittura)</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>test.ps1:11  $scriptname = $MyInvocation.mycommand.path</source>
          <target state="translated">test.ps1:11 $scriptname = $MyInvocation.mycommand.path</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Display the current value of the $scriptname variable, which is $null.</source>
          <target state="translated">Visualizzare il valore corrente della variabile $scriptname, ovvero $null.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to execute the statement that populates the variable.</source>
          <target state="translated">Utilizzare un comando del passaggio (s) per eseguire l'istruzione che popola la variabile.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Then, display the new value of the $scriptname variable.</source>
          <target state="translated">Quindi, visualizzare il nuovo valore della variabile $scriptname.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to preview the next statement in the script.</source>
          <target state="translated">Utilizzare un comando del passaggio (s) per visualizzare in anteprima l'istruzione successiva nello script.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The next statement is a call to the PsVersion function.</source>
          <target state="translated">L'istruzione successiva è una chiamata alla funzione PsVersion.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To skip the function but still execute it, use a Step-Over command (v).</source>
          <target state="translated">Per ignorare la funzione, ma ancora eseguirlo, utilizzare un comando di sovrapposizione (v).</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>If you are already in the function when you use Step-Over, it is not effective.</source>
          <target state="translated">Se si ha già nella funzione quando si utilizza del passaggio, non è valida.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The function call is displayed, but it is not executed.</source>
          <target state="translated">Viene visualizzata la chiamata di funzione, ma non viene eseguita.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>DBG&gt; v Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; v in Windows PowerShell 2.0 è eseguire un processo in background oggi (processo di avvio)?</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">test.ps1:13 "Done $scriptname"</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The Step-Over command executes the function, and it previews the next statement in the script, which prints the final line.</source>
          <target state="translated">La funzione viene eseguita dal comando di sovrapposizione e visualizza in anteprima l'istruzione successiva nello script, che consente di stampare la riga finale.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use a Stop command (t) to exit the debugger.</source>
          <target state="translated">Utilizzare il comando Arresta (t) per uscire dal debugger.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The command prompt reverts to the standard command prompt.</source>
          <target state="translated">Prompt dei comandi ritorna al prompt dei comandi standard.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>C:\ps-test&gt;</source>
          <target state="translated">C:\ps-test. &gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>To delete the breakpoints, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">Per eliminare i punti di interruzione, utilizzare il cmdlet Get-PsBreakpoint e Remove-PsBreakpoint.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test. &gt; Get-PsBreakpoint | Remove-PSBreakpoint</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Create a new command breakpoint on the PsVersion function.</source>
          <target state="translated">Creare un nuovo punto di interruzione comando nella funzione PsVersion.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Set-PsBreakpoint -command psversion -script test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; Set-PsBreakpoint-psversion comando-script ps1</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command to:</source>
          <target state="translated">È possibile abbreviare il comando:</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -c psversion -s test.ps1</source>
          <target state="translated">PS C:\ps-test. &gt; ps1 sbp - c psversion -s</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">A questo punto, eseguire lo script.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test. &gt; punto di interruzione raggiunto comando.\test.ps1 su 'C:\ps-test\test.ps1:psversion'</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The script reaches the breakpoint at the function call.</source>
          <target state="translated">Lo script raggiunge il punto di interruzione in corrispondenza della chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>At this point, the function has not yet been called.</source>
          <target state="translated">A questo punto, la funzione non è ancora stata chiamata.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This gives you the opportunity to use the Action parameter of Set-PsBreakpoint to set conditions for the execution of the breakpoint or to perform preparatory or diagnostic tasks, such as starting a log or invoking a diagnostic or security script.</source>
          <target state="translated">Questo offre la possibilità di utilizzare il parametro di azione del Set-PsBreakpoint per impostare le condizioni per l'esecuzione del punto di interruzione o eseguire attività preparatorie o diagnostica, quali l'avvio di un log o richiamare uno script di diagnostica o di sicurezza.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>To set an action, use a Continue command (c) to exit the script, and a Remove-PsBreakpoint command to delete the current breakpoint.</source>
          <target state="translated">Per impostare un'azione, utilizzare un comando Continue (c) per uscire dallo script e un comando Remove-PsBreakpoint per eliminare il punto di interruzione corrente.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>(Breakpoints are read-only, so you cannot add an action to the current breakpoint.)</source>
          <target state="translated">(I punti di interruzione sono sola lettura, pertanto non è possibile aggiungere un'azione per il punto di interruzione corrente).</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>DBG&gt; c Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; c in Windows PowerShell 2.0 è eseguire un processo in background oggi (processo di avvio)?</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1</source>
          <target state="translated">C:\ps-test\test.ps1 completato</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; get-psbreakpoint | remove-psbreakpoint PS C:\ps-test&gt;</source>
          <target state="translated">PS C:\ps-test. &gt; get-psbreakpoint | Remove-psbreakpoint PS c:\ps-test. &gt;</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Now, create a new command breakpoint with an action.</source>
          <target state="translated">A questo punto, creare un nuovo punto di interruzione comando con un'azione.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The following command sets a command breakpoint with an action that logs the value of the $scriptname variable when the function is called.</source>
          <target state="translated">Il seguente comando imposta un punto di interruzione comando con un'azione che registra il valore della variabile $scriptname quando viene chiamata la funzione.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Because the Break keyword is not used in the action, execution does not stop.</source>
          <target state="translated">Poiché la parola chiave Break non viene utilizzata nell'azione, l'esecuzione non viene arrestata.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the line-continuation character.)</source>
          <target state="translated">(L'apice inverso (') è il carattere di continuazione di riga).</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -command psversion -script test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname is $scriptname."</source>
          <target state="translated">PS C:\ps-test. &gt; set-psbreakpoint-psversion comando-script ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname è $scriptname. "</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>` -path action.log}</source>
          <target state="translated">-percorso action.log}</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can also add actions that set conditions for the breakpoint.</source>
          <target state="translated">È inoltre possibile aggiungere azioni che impostano le condizioni del punto di interruzione.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>In the following command, the command breakpoint is executed only if the execution policy is set to RemoteSigned, the most restrictive policy that still permits you to run scripts.</source>
          <target state="translated">Il comando seguente, il punto di interruzione comando viene eseguito solo se i criteri di esecuzione sono impostato su RemoteSigned, il criterio più restrittivo che consente di eseguire gli script.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the continuation character.)</source>
          <target state="translated">(L'apice inverso (') è il carattere di continuazione).</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -script test.ps1 -command psversion ` -action { if ((get-executionpolicy) -eq "RemoteSigned") { break }}</source>
          <target state="translated">PS C:\ps-test. &gt; set-psbreakpoint-script ps1-psversion comando '-azione {se ((get-executionpolicy) - eq "RemoteSigned") {interruzione}}</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The Break keyword in the action directs the debugger to execute the breakpoint.</source>
          <target state="translated">La parola chiave Break nell'azione indica al debugger di eseguire il punto di interruzione.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>You can also use the Continue keyword to direct the debugger to execute without breaking.</source>
          <target state="translated">È inoltre possibile utilizzare la parola chiave Continue per indicare al debugger di eseguire senza interruzioni.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Because the default keyword is Continue, you must specify Break to stop execution.</source>
          <target state="translated">Poiché la parola chiave default è continua, è necessario specificare interruzione per arrestare l'esecuzione.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">A questo punto, eseguire lo script.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test. &gt; punto di interruzione raggiunto comando.\test.ps1 su 'C:\ps-test\test.ps1:psversion'</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Because the execution policy is set to RemoteSigned, execution stops at the function call.</source>
          <target state="translated">Poiché i criteri di esecuzione sono impostato su RemoteSigned, l'esecuzione viene arrestata in corrispondenza della chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>At this point, you might want to check the call stack.</source>
          <target state="translated">A questo punto, si potrebbe dover controllare lo stack di chiamate.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Use the Get-PsCallStack cmdlet or the Get-PsCallStack debugger command (k).</source>
          <target state="translated">Utilizzare il cmdlet Get-PsCallStack o il comando Get-PsCallStack del debugger (k).</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The following command gets the current call stack.</source>
          <target state="translated">Il comando seguente ottiene lo stack di chiamate corrente.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>DBG&gt; k 2: prompt 1: .\test.ps1: $args=[] 0: prompt: $args=[]</source>
          <target state="translated">DBG &gt; k 2: richiedere 1:.\test.ps1: $args = [0: prompt dei comandi: $args =]</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example demonstrates just a few of the many ways to use the Windows PowerShell debugger.</source>
          <target state="translated">In questo esempio viene solo alcune delle diverse modalità di utilizzo del debugger di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For more information about the debugger cmdlets, type the following command:</source>
          <target state="translated">Per ulteriori informazioni sui cmdlet di debugger, digitare il comando seguente:</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>help &lt;cmdlet-name&gt; -full</source>
          <target state="translated">Guida in linea &lt; cmdlet-name &gt; - completo</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>For example, type:</source>
          <target state="translated">Ad esempio, digitare il comando seguente:</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>help set-psbreakpoint -full</source>
          <target state="translated">Guida di set-psbreakpoint-completo</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Other Debugging Features in Windows PowerShell</source>
          <target state="translated">Altre funzionalità di debug in Windows PowerShell</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>In addition to the Windows PowerShell debugger, Windows PowerShell includes several other features that you can use to debug scripts and functions.</source>
          <target state="translated">Oltre ai debugger di Windows PowerShell, Windows PowerShell include numerose altre funzionalità che è possibile utilizzare per eseguire il debug di script e funzioni.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-- Windows PowerShell Integrated Scripting Environment (ISE) includes an interactive graphical debugger.</source>
          <target state="translated">-- Windows PowerShell Integrated Scripting Environment (ISE) include un debugger grafico interattivo.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, start Windows PowerShell ISE and press F1.</source>
          <target state="translated">Per ulteriori informazioni, avviare Windows PowerShell ISE e premere F1.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-- The Set-PSDebug cmdlet offers very basic script debugging features, including stepping and tracing.</source>
          <target state="translated">-- Il cmdlet Set-PSDebug offre funzionalità di traccia e debug funzionalità, tra cui l'esecuzione di script molto semplice.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-- Use the Set-StrictMode cmdlet to detect references to uninitialized variables, to references to non-existent properties of an object, and to function syntax that is not valid.</source>
          <target state="translated">-Utilizzare il cmdlet Set-StrictMode per rilevare i riferimenti a variabili non inizializzate, per i riferimenti a proprietà inesistente di un oggetto e alla sintassi delle funzioni che non è valida.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>-- Add diagnostic statements to a script, such as statements that display the value of variables, statements that read input from the command line, or statements that report the current instruction.</source>
          <target state="translated">-- Aggiunta di istruzioni di diagnostica per uno script, ad esempio le istruzioni che consentono di visualizzare il valore delle variabili, le istruzioni che legge l'input dalla riga di comando o istruzioni che fanno riferimento l'istruzione corrente.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Use the cmdlets that contain the Write verb for this task, such as Write-Host, Write-Debug, Write-Warning, and Write-Verbose.</source>
          <target state="translated">Utilizzare i cmdlet che contengono il verbo di scrittura per questa attività, ad esempio Write-Host, Write-Debug. Write-Warning e Write-Verbose.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEDERE ANCHE</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</source>
          <target state="translated">Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>