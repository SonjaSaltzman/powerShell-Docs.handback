<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e3678c50582d25cf0c15d13ad31c9a5f012b40e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Splatting.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e36ef81e5150035ee958828a7d6d78c0c3d9bdec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae441651a33a38fb6adb54d944f2fdf31e5766d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Splatting</source>
          <target state="translated">Sullo Splatting</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIZIONE BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use splatting to pass parameters to commands in Windows PowerShell.</source>
          <target state="translated">Viene descritto come usare lo splatting per passare parametri ai comandi di Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIZIONE LUNGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[This topic was contributed by Rohn Edwards of Gulfport, Mississippi, a system administrator and the winner of the Advanced Division of the 2012 Scripting Games.</source>
          <target state="translated">[Questo argomento è stato reso disponibile da Rohn Edwards di Gulfport, Campania, un amministratore di sistema e il vincitore della divisione avanzata dei giochi di Scripting 2012.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Revised for Windows PowerShell 3.0.]</source>
          <target state="translated">Rivisto per Windows PowerShell 3.0.]</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Splatting is a method of passing a collection of parameter values to a command as unit.</source>
          <target state="translated">Lo splatting è un metodo del passaggio di una raccolta di valori di parametro a un comando come unità.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell associates each value in the collection with a command parameter.</source>
          <target state="translated">Windows PowerShell associa ogni valore nella raccolta con un parametro del comando.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Splatted parameter values are stored in named splatting variables, which look like standard variables, but begin with an At symbol (@) instead of a dollar sign ($).</source>
          <target state="translated">I valori dei parametri Splatted vengono archiviati nelle variabili lo splatting denominata, simile a variabili standard che iniziano con un simbolo At (@) anziché un segno di dollaro ($).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The At symbol tells Windows PowerShell that you are passing a collection of values, instead of a single value.</source>
          <target state="translated">Il simbolo At indica a Windows PowerShell che si sta passando una raccolta di valori, anziché un solo valore.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Splatting makes your commands shorter and easier to read.</source>
          <target state="translated">Lo splatting rende i comandi più brevi e facili da leggere.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can re-use the splatting values in different command calls and use splatting to pass parameter values from the $PSBoundParameters automatic variable to other scripts and functions.</source>
          <target state="translated">È possibile riutilizzare i valori lo splatting nelle chiamate al comando diverso e usare lo splatting per passare valori di parametro della variabile automatica $PSBoundParameters ad altri script e funzioni.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can also use splatting to represent all parameters of a command.</source>
          <target state="translated">A partire da Windows PowerShell 3.0, è possibile utilizzare anche lo splatting per rappresentare tutti i parametri di un comando.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">SINTASSI</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To provide parameter values for positional parameters, in which parameter names are not required, use the array syntax.</source>
          <target state="translated">Per fornire i valori dei parametri per i parametri posizionali, nella quale parametro nomi non sono necessari, utilizzare la sintassi di matrice.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To provide parameter name and value pairs, use the hash table syntax.</source>
          <target state="translated">Per fornire coppie nome / valore di parametro, utilizzare la sintassi di tabella hash.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The splatted value can appear anywhere in the parameter list.</source>
          <target state="translated">Il valore splatted può trovarsi in qualsiasi punto nell'elenco di parametri.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When splatting, you do not need to use a hash table or an array to pass all parameters.</source>
          <target state="translated">Quando lo splatting, non devi utilizzare una tabella hash o una matrice per passare tutti i parametri.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You may pass some parameters by using splatting and pass others by position or by parameter name.</source>
          <target state="translated">È possibile passare alcuni parametri utilizzando lo splatting e passare ad altri utenti in base alla posizione o nome del parametro.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Also, you can splat multiple objects in a single command just so you pass no more than one value for each parameter.</source>
          <target state="translated">Inoltre, è possibile gocce più oggetti in un unico comando solo in modo da passare non più di un valore per ogni parametro.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH HASH TABLES</source>
          <target state="translated">SPLATTING CON LE TABELLE HASH</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a hash table to splat parameter name and value pairs.</source>
          <target state="translated">Utilizzare una tabella hash di coppie nome / valore del parametro gocce.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can use this format for all parameter types, including positional and named parameters and switch parameters.</source>
          <target state="translated">È possibile utilizzare questo formato per tutti i tipi di parametro, inclusi i parametri posizionali e denominati e passare i parametri.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Nell'esempio seguente confronta i due comandi Copy-Item che copiare il file test. txt nel file test2. txt nella stessa directory.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are included.</source>
          <target state="translated">Nel primo esempio utilizza il formato tradizionale in quale parametro sono inclusi i nomi.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item - Path "txt"-"test2. txt" - WhatIf di destinazione</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The second example uses hash table splatting.</source>
          <target state="translated">Il secondo esempio viene utilizzato lo splatting tabella hash.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter-name and parameter-value pairs and stores it in the $HashArguments variable.</source>
          <target state="translated">Il primo comando crea una tabella hash del nome di parametro e valore di parametro coppie e la archivia nella variabile $HashArguments.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The second command uses the $HashArguments variable in a command with splatting.</source>
          <target state="translated">Il secondo comando Usa la variabile $HashArguments in un comando con lo splatting.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The At symbol (@HashArguments) replaces the dollar sign ($HashArguments) in the command.</source>
          <target state="translated">Il simbolo At (@HashArguments) sostituisce il segno di dollaro ($HashArguments) nel comando.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To provide a value for the WhatIf switch parameter, use $True or $False.</source>
          <target state="translated">Per fornire un valore per il parametro WhatIf, utilizzare $True o $False.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$HashArguments = @{ Path = "test.txt"; Destination = "test2.txt"; WhatIf = $true } PS C:&gt;Copy-Item @HashArguments</source>
          <target state="translated">PS C: &gt; $HashArguments = @{Path = "test. txt"; Destinazione = "test2. txt"; WhatIf = $true} c: PS &gt; Copy-Item @HashArguments</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note: In the first command, the At symbol (@) indicates a hash table, not a splatted value.</source>
          <target state="translated">Nota: nel primo comando, il simbolo At (@) indica una tabella hash, non un valore splatted.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The syntax for hash tables in Windows PowerShell is: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>; …}</source>
          <target state="translated">La sintassi per le tabelle hash in Windows PowerShell è: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>;...}</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH ARRAYS</source>
          <target state="translated">SPLATTING CON MATRICI</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use an array to splat values for positional parameters, which do not require parameter names.</source>
          <target state="translated">Utilizzare una matrice di valori gocce per i parametri posizionali, che non richiedono i nomi dei parametri.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The values must be in position-number order in the array.</source>
          <target state="translated">I valori devono essere nell'ordine di numero di posizione nella matrice.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Nell'esempio seguente confronta i due comandi Copy-Item che copiare il file test. txt nel file test2. txt nella stessa directory.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are omitted.</source>
          <target state="translated">Nel primo esempio utilizza il formato tradizionale in cui i nomi dei parametri vengono omessi.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The parameter values appear in position order in the command.</source>
          <target state="translated">I valori dei parametri vengono visualizzati in ordine di posizione nel comando.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Copy-Item "test.txt" "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item "test2. txt" - WhatIf "txt"</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second example uses array splatting.</source>
          <target state="translated">Il secondo esempio viene utilizzato lo splatting di matrice.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first command creates an array of the parameter values and stores it in the $ArrayArguments variable.</source>
          <target state="translated">Il primo comando crea una matrice di valori di parametro e archiviarlo nella variabile $ArrayArguments.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The values are in position order in the array.</source>
          <target state="translated">I valori sono in ordine di posizione nella matrice.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The second command uses the $ArrayArguments variable in a command in splatting.</source>
          <target state="translated">Il secondo comando Usa la variabile $ArrayArguments in un comando nello splatting.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The At symbol (@ArrayArguments) replaces the dollar sign ($ArrayArguments) in the command.</source>
          <target state="translated">Il simbolo At (@ArrayArguments) sostituisce il segno di dollaro ($ArrayArguments) nel comando.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$ArrayArguments = "test.txt", "test2.txt" PS C:&gt;Copy-Item @ArrayArguments -WhatIf</source>
          <target state="translated">PS C: &gt; $ArrayArguments = "test. txt" c: "test2. txt" PS &gt; @ArrayArguments Copy-Item - WhatIf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">ESEMPI</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This example shows how to re-use splatted values in different commands.</source>
          <target state="translated">In questo esempio viene illustrato come riutilizzare i valori splatted nei comandi diversi.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The commands in this example use the Write-Host cmdlet to write messages to the host program console.</source>
          <target state="translated">I comandi in questo esempio utilizzano il cmdlet Write-Host in cui per scrivere i messaggi della console del programma host.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It uses splatting to specify the foreground and background colors.</source>
          <target state="translated">Usa lo splatting per specificare i colori di sfondo e primo piano.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To change the colors of all commands, just change the value of the $Colors variable.</source>
          <target state="translated">Per modificare i colori di tutti i comandi, è sufficiente modificare il valore della variabile $Colors.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter names and values and stores the hash table in the $Colors variable.</source>
          <target state="translated">Il primo comando crea una tabella hash di nomi di parametro e valori e la tabella hash viene archiviato nella variabile $Colors.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</source>
          <target state="translated">$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second and third commands use the $Colors variable for splatting in a Write-Host command.</source>
          <target state="translated">Il secondo e terzo comando utilizza la variabile $Colors per lo splatting in un comando Write-Host.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To use the $Colors variable, replace the dollar sign ($Colors) with an At symbol (@Colors).</source>
          <target state="translated">Per utilizzare la variabile $Colors, sostituire il segno di dollaro ($Colors) con un simbolo At (@Colors).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Write a message with the colors in $Colors Write-Host "This is a test."</source>
          <target state="translated">Scrivere un messaggio con i colori in $Colors Write-Host "È un test".</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>@Colors</source>
          <target state="translated">@Colors</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Write second message with same colors.</source>
          <target state="translated">Scrivere il messaggio secondo colori stesso.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The position of splatted hash table does not matter.</source>
          <target state="translated">La posizione della tabella hash splatted non è rilevante.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Write-Host @Colors "This is another test."</source>
          <target state="translated">Write-Host @Colors "This is a un altro test".</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example shows how to forward their parameters to other commands by using splatting and the $PSBoundParameters automatic variable.</source>
          <target state="translated">Questo esempio viene illustrato come inoltrare i propri parametri agli altri comandi utilizzando lo splatting e la variabile automatica $PSBoundParameters.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The $PSBoundParameters automatic variable is a dictionary (System.Collections.Generic.Dictionary) that contains all of the parameter names and values that are used when a script or function is run.</source>
          <target state="translated">La variabile automatica $PSBoundParameters è un dizionario (System.Collections.Generic.Dictionary) che contiene tutti i nomi dei parametri e valori che vengono utilizzati quando viene eseguito uno script o funzione.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, we use the $PSBoundParameters variable to forward the parameters values passed to a script or function from Test2 function to the Test1 function.</source>
          <target state="translated">Nell'esempio seguente, utilizziamo il $PSBoundParameters variabile per inoltrare i valori di parametri passata a una funzione o uno script dalla funzione Test2 alla funzione Test1.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both calls to the Test1 function from Test2 use splatting.</source>
          <target state="translated">Entrambe le chiamate alla funzione Test1 da Test2 usano lo splatting.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>function Test1 { param($a, $b, $c)</source>
          <target state="translated">funzione Test1 {param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>$a $b $c }</source>
          <target state="translated">$a $b $c}</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>function Test2 { param($a, $b, $c)</source>
          <target state="translated">funzione Test2 {param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $a, $b, and $c.</source>
          <target state="translated">Chiamare la funzione Test1 con $a $b e $c.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test1 @PsBoundParameters</source>
          <target state="translated">Test1 @PsBoundParameters</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $b and $c, but not with $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters }</source>
          <target state="translated">Chiamare la funzione Test1 con $b e $c, ma non con $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Test2 -a 1 -b 2 -c 3</source>
          <target state="translated">PS C: &gt; Test2 - 1 -b 2 - c 3</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>SPLATTING COMMAND PARAMETERS</source>
          <target state="translated">PARAMETRI DEL COMANDO LO SPLATTING</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use splatting to represent the parameters of a command.</source>
          <target state="translated">È possibile utilizzare lo splatting per rappresentare i parametri di un comando.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This technique is useful when you are creating a proxy function, that is, a function that calls another command.</source>
          <target state="translated">Questa tecnica è utile quando si crea una funzione di proxy, vale a dire, una funzione che chiama un altro comando.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">Questa funzionalità è stato introdotto in Windows PowerShell 3.0.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To splat the parameters of a command, use @Args to represent the command parameters.</source>
          <target state="translated">Per gocce i parametri di un comando, utilizzare @Args per rappresentare i parametri del comando.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This technique is easier than enumerating command parameters and it works without revision even if the parameters of the called command change.</source>
          <target state="translated">Questa tecnica è più semplice rispetto all'enumerazione parametri del comando e funziona senza revisione anche se i parametri del comando denominato.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The feature uses the $Args automatic variable, which contains all unassigned parameter values.</source>
          <target state="translated">La funzionalità utilizza la variabile automatica $Args, che contiene tutti i valori di parametro non assegnato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following function calls the Get-Process cmdlet.</source>
          <target state="translated">Ad esempio, la funzione seguente chiama il cmdlet Get-Process.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this function, @Args represents all of the parameters of the Get-Process cmdlet.</source>
          <target state="translated">In questa funzione, @Args rappresenta tutti i parametri del cmdlet Get-Process.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>function Get-MyProcess { Get-Process @Args }</source>
          <target state="translated">funzione Get-MyProcess {Get-Process @Args}</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use the Get-MyProcess function, all unassigned parameters and parameter values are passed to @Args, as shown in the following commands.</source>
          <target state="translated">Quando si utilizza la funzione Get-MyProcess, tutti i parametri non assegnati e i valori dei parametri vengono passati a @Args, come illustrato nei comandi seguenti.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-MyProcess-nome PowerShell</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Gestisce NPM(K) PM(K) WS(K) VM(M) Id CPU ProcessName</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>463      46   225484     237196   719    15.86   3228 powershell</source>
          <target state="translated">463 46 225484 237196 719 15.86 3228 powershell</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell_Ise -FileVersionInfo</source>
          <target state="translated">PS C: &gt; Get-MyProcess-nome PowerShell_Ise - FileVersionInfo</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>ProductVersion   FileVersion      FileName</source>
          <target state="translated">Versioneprodotto versionefile nomefile</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</source>
          <target state="translated">6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can use @Args in a function that has explicitly declared parameters.</source>
          <target state="translated">È possibile utilizzare @Args in una funzione che ha dichiarato in modo esplicito i parametri.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use it more than once in a function, but all parameters that you enter are passed to all instances of @Args, as shown in the following example.</source>
          <target state="translated">È possibile utilizzarlo più volte in una funzione, ma tutti i parametri immessi vengono passati a tutte le istanze di @Args, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Param ([switch]$P, [switch]$C) if ($P) { Get-Process @Args } if ($C) { Get-Command @Args } }</source>
          <target state="translated">funzione Get-nomecomando {Param ([parametro] $P, [opzione] $C) se ($P) {Get-Process @Args} se ($C) {Get-Command @Args}}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyCommand -P -C -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-nomecomando - P -C-nome PowerShell</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Gestisce NPM(K) PM(K) WS(K) VM(M) Id CPU ProcessName</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>408      28    75568      83176   620     1.33   1692 powershell</source>
          <target state="translated">408 28 75568 83176 620 1,33 1692 powershell</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Path               : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension          : .exe Definition         : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Visibility         : Public OutputType         : {System.String} Name               : powershell.exe CommandType        : Application ModuleName         : Module             : RemotingCapability : PowerShell Parameters         : ParameterSets      : HelpUri            : FileVersionInfo    : File:             C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</source>
          <target state="translated">Percorso: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe estensione: definizione .exe: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe visibilità: OutputType pubblico: {String} nome: CommandType powershell.exe: applicazione ModuleName: modulo: RemotingCapability: parametri PowerShell: ParameterSets: HelpUri: FileVersionInfo: File: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEDERE ANCHE</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</source>
          <target state="translated">about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>