<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3563c29053a4ad85d65587c5e77a30a2dbc7628</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Debuggers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d62753711baa35ff9b203ea8ccf445b98a619116</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d08eb5c290e8115c8fcfa118dc56a6beea7adf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Debuggers</source>
          <target state="translated">关于调试器</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes the Windows PowerShell debugger.</source>
          <target state="translated">介绍了 Windows PowerShell 调试程序。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Debugging is the process of examining a script while it is running to identify and correct errors in the script instructions.</source>
          <target state="translated">调试是它的运行状态才能识别并更正脚本说明中的错误时，检查脚本的过程。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can help you examine and identify errors and inefficiencies in your scripts, functions, commands, Windows PowerShell workflows, Windows PowerShell Desired State Configuration (DSC) configurations, or expressions.</source>
          <target state="translated">Windows PowerShell 调试器可以帮助您检查并识别错误和低效的脚本、 函数、 命令、 Windows PowerShell 工作流、 Windows PowerShell Desired State Configuration (DSC) 配置或表达式。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, the Windows PowerShell debugger has been updated to debug scripts, functions, workflows, commands, configurations, or expressions that are running in either the console or Windows PowerShell ISE on remote computers.</source>
          <target state="translated">从 Windows PowerShell 5.0 开始，Windows PowerShell 调试器已更新来调试脚本、 函数、 工作流、 命令、 配置或在远程计算机运行控制台或 Windows PowerShell ISE 中的表达式。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can run Enter-PSSession to start an interactive remote PowerShell session in which you can set breakpoints and debug script files and commands on the remote computer.</source>
          <target state="translated">您可以运行 Enter-pssession 来启动交互式远程 PowerShell 会话，您可以在其中设置断点并调试脚本文件和远程计算机上的命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running a script or command on a remote computer.</source>
          <target state="translated">已更新输入 PSSession 功能，使您重新连接到和输入断开连接的会话的远程计算机上运行脚本或命令。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">如果运行的脚本遇到断点，客户端会话将自动启动调试器。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the disconnected session that is running a script has already hit a breakpoint, and is stopped at the breakpoint, Enter-PSSession automatically starts the command-line debugger, after you reconnect to the session.</source>
          <target state="translated">如果断开连接的会话正在运行一个脚本具有已命中了断点，并在断点处停止，Enter-pssession 将自动启动命令行调试程序之后重新连接到会话。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can also be used to debug Windows PowerShell workflows, in either the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">此外可以使用 Windows PowerShell 调试器来调试 Windows PowerShell 工作流，在任一 Windows PowerShell 控制台中，或在 Windows PowerShell ISE 中。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can debug within running jobs or processes, either locally or remotely.</source>
          <target state="translated">从 Windows PowerShell 5.0 开始，您可以调试在本地或远程运行的作业或进程。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use the features of the Windows PowerShell debugger to examine a Windows PowerShell script, function, command, workflow, or expression while it is running.</source>
          <target state="translated">Windows PowerShell 调试器的功能可用于运行时检查的 Windows PowerShell 脚本、 函数、 命令、 工作流中或表达式。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger includes a set of cmdlets that let you set breakpoints, manage breakpoints, and view the call stack.</source>
          <target state="translated">Windows PowerShell 调试器包括一组 cmdlet，您可以设置断点、 管理断点，并查看调用堆栈。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Debugger Cmdlets The Windows PowerShell debugger includes the following set of cmdlets:</source>
          <target state="translated">调试器 Cmdlet 的 Windows PowerShell 调试器包括下面的 cmdlet 集︰</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Set-PsBreakpoint:     Sets breakpoints on lines, variables, and commands.</source>
          <target state="translated">Set-psbreakpoint︰ 在行、 变量和命令上设置断点。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Get-PsBreakpoint:     Gets breakpoints in the current session.</source>
          <target state="translated">Get-psbreakpoint︰ 获取当前会话中的断点。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint: Turns off breakpoints in the current session.</source>
          <target state="translated">Disable-psbreakpoint︰ 关闭当前会话中的断点。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enable-PsBreakpoint:  Re-enables breakpoints in the current session.</source>
          <target state="translated">Enable-psbreakpoint︰ 将当前会话中重新启用断点。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Remove-PsBreakpoint:  Deletes breakpoints from the current session.</source>
          <target state="translated">Remove-psbreakpoint︰ 从当前会话中删除断点。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Get-PsCallStack:      Displays the current call stack.</source>
          <target state="translated">Get-pscallstack︰ 显示当前调用堆栈。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Starting and Stopping the Debugger To start the debugger, set one or more breakpoints.</source>
          <target state="translated">启动和停止调试器到启动调试器，设置一个或多个断点。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Then, run the script, command, or function that you want to debug.</source>
          <target state="translated">然后，运行脚本、 命令或你想要调试的函数。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When you reach a breakpoint, execution stops, and control is turned over to the debugger.</source>
          <target state="translated">当到达断点，执行将停止，并控制移交给调试器。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To stop the debugger, run the script, command, or function until it is complete.</source>
          <target state="translated">若要停止调试器，请运行脚本、 命令或函数直至完成。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Or, type "stop" or "t".</source>
          <target state="translated">或者，键入"停止"或"t"。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Debugger Commands When you use the debugger in the Windows PowerShell console, use the following commands to control the execution.</source>
          <target state="translated">调试器命令时使用 Windows PowerShell 控制台中的调试器，使用以下命令来控制执行。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell ISE, use commands on the Debug menu.</source>
          <target state="translated">在 Windows PowerShell ISE 中，使用调试菜单上的命令。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note: For information about how to use the debugger in other host applications, see the host application documentation.</source>
          <target state="translated">注意︰ 有关如何在其他宿主应用程序中使用调试器的信息，请参阅主机应用程序文档。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>s, Step-into        Executes the next statement and then stops.</source>
          <target state="translated">s，逐语句执行下一条语句，然后停止。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>v, Step-over        Executes the next statement, but skips functions and invocations.</source>
          <target state="translated">v、 逐过程执行下一个语句，但跳过函数和调用。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">将执行跳过的语句，但不会单步遍历。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Ctrl+Break (Break All in ISE)  Breaks into a running script within either the Windows PowerShell console, or Windows PowerShell ISE.</source>
          <target state="translated">Ctrl + Break （全部中断在 ISE 中） 到 Windows PowerShell 控制台或 Windows PowerShell ISE 中运行脚本的分页符。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that Ctrl+Break in Windows PowerShell 2.0, 3.0, and 4.0 closes the program.</source>
          <target state="translated">请注意，Windows PowerShell 2.0、 3.0 和 4.0 中的 Ctrl + Break 将关闭该程序。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Break All works on both local and remote interactively-running scripts.</source>
          <target state="translated">本地和远程以交互方式运行脚本时中断都能正常工作。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>o, Step-out         Steps out of the current function; up one level if nested.</source>
          <target state="translated">o，-跳出跳出当前函数;如果嵌套的一级。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If in the main body, it continues to the end or the next breakpoint.</source>
          <target state="translated">如果在主正文中，它将继续到下一个断点处或结束。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">将执行跳过的语句，但不会单步遍历。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>c, Continue         Continues to run until the script is complete or until the next breakpoint is reached.</source>
          <target state="translated">c 中，继续将继续运行该脚本完成之前，或直至到达下一个断点。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">将执行跳过的语句，但不会单步遍历。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>l, List             Displays the part of the script that is executing.</source>
          <target state="translated">l，列表将显示正在执行脚本的一部分。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, it displays the current line, five previous lines, and 10 subsequent lines.</source>
          <target state="translated">默认情况下，它将显示当前行标识符、 五个以前的行和 10 随后几行。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To continue listing the script, press ENTER.</source>
          <target state="translated">若要继续列出其余脚本，按 enter 键。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph>, List         Displays 16 lines of the script beginning with the line number specified by <ph id="ph2">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph>, ，以指定的行号开头的脚本的列表显示 16 行 <ph id="ph2">&lt;m&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, List     Displays <ph id="ph3">&lt;n&gt;</ph> lines of the script, beginning with the line number specified by <ph id="ph4">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, ，列表显示 <ph id="ph3">&lt;n&gt;</ph> 行脚本，以指定的行号开头 <ph id="ph4">&lt;m&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>q, Stop, Exit       Stops executing the script, and exits the debugger.</source>
          <target state="translated">q，停止，请退出将停止执行该脚本，并退出调试器。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you are debugging a job by running the Debug-Job cmdlet, the Exit command detaches the debugger, and allows the job to continue running.</source>
          <target state="translated">如果正在运行调试作业 cmdlet 调试一个作业，退出命令将分离调试器，并允许继续运行该作业。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>k, Get-PsCallStack  Displays the current call stack.</source>
          <target state="translated">k、 Get-pscallstack 显示当前的调用堆栈。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Repeats the last command if it was Step (s), Step-over (v), or List (l).</source>
          <target state="translated">重复的最后一个命令，如果它是步骤 (s)、 跨距 (v) 或列表 (l)。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, represents a submit action.</source>
          <target state="translated">否则，表示提交操作。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>?, h                Displays the debugger command Help.</source>
          <target state="translated">？，h 用于显示调试器命令的帮助。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To exit the debugger, you can use Stop (q).</source>
          <target state="translated">若要退出调试器，您可以使用停止 (q)。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can run the Exit command to exit a nested debugging session that you started by running either Debug-Job or Debug-Runspace.</source>
          <target state="translated">从 Windows PowerShell 5.0 开始，可以运行退出命令退出嵌套在调试会话，它通过运行调试作业或调试运行空间开始。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By using these debugger commands, you can run a script, stop on a point of concern, examine the values of variables and the state of the system, and continue running the script until you have identified a problem.</source>
          <target state="translated">通过使用这些调试器命令，可以运行脚本、 的关注点上停止、 检查变量和系统的状态的值并继续运行脚本，直到确定问题。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>NOTE:  If you step into a statement with a redirection operator, such as "&gt;", the Windows PowerShell debugger steps over all remaining statements in the script.</source>
          <target state="translated">注意︰ 如果你单步执行一条语句与重定向运算符，如"&gt;"，Windows PowerShell 调试器逐句通过脚本中的所有剩余语句。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Displaying the Values of script Variables</source>
          <target state="translated">显示脚本变量的值</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>While you are in the debugger, you can also enter commands, display the value of variables, use cmdlets, and run scripts at the command line.</source>
          <target state="translated">当您在调试器中，您也可以输入命令，显示的变量的值、 使用的 cmdlet，和在命令行运行脚本。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can display the current value of all variables in the script that is being debugged, except for the following automatic variables:</source>
          <target state="translated">在下面的自动变量除外，正在调试的脚本中，可以显示所有变量的当前值︰</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>$Args $Input $MyInvocation $PSBoundParameters</source>
          <target state="translated">$Args $Input $MyInvocation $PSBoundParameters</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you try to display the value of any of these variables, you get the value of that variable for in an internal pipeline the debugger uses, not the value of the variable in the script.</source>
          <target state="translated">如果你尝试显示这些变量中的任何一个的值，你将获取调试器使用的内部管道中变量的值，而不是脚本中变量的值。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To display the value these variables for the script that is being debugged, in the script, assign the value of the automatic variable to a new variable.</source>
          <target state="translated">若要显示的值的脚本，正在调试，这些变量在脚本中，分配给一个新变量自动变量的值。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Then you can display the value of the new variable.</source>
          <target state="translated">然后您可以显示新变量的值。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如，</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>$scriptArgs = $Args $scriptArgs</source>
          <target state="translated">$scriptArgs = $Args $scriptArgs</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the example in this topic, the value of the $MyInvocation variable is reassigned as follows:</source>
          <target state="translated">在本主题中示例中，$MyInvocation 变量的值重新分配，如下所示︰</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Debugger Environment When you reach a breakpoint, you enter the debugger environment.</source>
          <target state="translated">调试器环境时到达一个断点，请输入调试器环境。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The command prompt changes so that it begins with "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</source>
          <target state="translated">命令提示符将更改，以便它开始于"<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:"。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you are debugging a workflow, the prompt is "[WFDBG]".</source>
          <target state="translated">如果正在调试工作流，提示将是"[WFDBG]"。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can customize the prompt.</source>
          <target state="translated">您可以自定义提示。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, in some host applications, such as the Windows PowerShell console, (but not in Windows PowerShell Integrated Scripting Environment [ISE]), a nested prompt opens for debugging.</source>
          <target state="translated">此外，在某些主机应用程序，如 Windows PowerShell 控制台中 （但不是在 Windows PowerShell 集成脚本环境 [ISE]），嵌套的提示将打开以进行调试。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can detect the nested prompt by the repeating greater-than characters (ASCII 62) that appear at the command prompt.</source>
          <target state="translated">您可通过更高版本与重复检测嵌套的提示-比在命令提示符下显示的字符 (ASCII 62)。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, the following is the default debugging prompt in the Windows PowerShell console:</source>
          <target state="translated">例如，下面是默认调试在 Windows PowerShell 控制台中的提示︰</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can find the nesting level by using the $NestedPromptLevel automatic variable.</source>
          <target state="translated">通过使用 $NestedPromptLevel 自动变量，您可以找到的嵌套级别。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Additionally, an automatic variable, $PSDebugContext, is defined in the local scope.</source>
          <target state="translated">此外，将自动变量，$PSDebugContext，在本地作用域内定义。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use the presence of the $PsDebugContext variable to determine whether you are in the debugger.</source>
          <target state="translated">$PsDebugContext 变量存在可用于确定是否在调试器中。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>if ($psdebugcontext) {"Debugging"} else {"Not Debugging"}</source>
          <target state="translated">如果 ($psdebugcontext) {"调试"} else {"不调试"}</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the value of the $PSDebugContext variable in your debugging.</source>
          <target state="translated">可以在您调试使用 $PSDebugContext 变量的值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Name   CommandLineParameters  UnboundArguments  Location</source>
          <target state="translated">名称 CommandLineParameters UnboundArguments 位置</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>=      {}                     {}                C:\ps-test\vote.ps1 (1)</source>
          <target state="translated">= {} {} C:\ps-test\vote.ps1 (1)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Debugging and Scope Breaking into the debugger does not change the scope in which you are operating, but when you reach a breakpoint in a script, you move into the script scope.</source>
          <target state="translated">调试和中断到调试器中作用域不会更改作用域在其只运行，但在您即将在脚本中的断点时，您将移动到的脚本作用域。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The script scope is a child of the scope in which you ran the debugger.</source>
          <target state="translated">脚本作用域是作用域中运行调试器的子级。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To find the variables and aliases that are defined in the script scope, use the Scope parameter of the Get-Alias or Get-Variable cmdlets.</source>
          <target state="translated">若要查找的变量和在脚本范围中定义的别名，请使用 Get-alias 或 Get-variable cmdlet 的作用域参数。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the variables in the local (script) scope:</source>
          <target state="translated">例如，以下命令获取在本地 （脚本） 作用域中的变量︰</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>get-variable -scope 0</source>
          <target state="translated">获取变量的作用域 0</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">您可以将命令缩写为︰</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>gv -s 0</source>
          <target state="translated">gv-s 0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is a useful way to see only the variables that you defined in the script and that you defined while debugging.</source>
          <target state="translated">这是有用的方式，若要查看仅变量在脚本中定义并且您在调试时定义。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Debugging at the Command Line When you set a variable breakpoint or a command breakpoint, you can set the breakpoint only in a script file.</source>
          <target state="translated">在命令行时调试设置变量断点或命令断点，您可以仅在脚本文件中设置断点。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, by default, the breakpoint is set on anything that runs in the current session.</source>
          <target state="translated">但是，默认情况下，断点设置在当前会话中运行的任何内容。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if you set a breakpoint on the $name variable, the debugger breaks on any $name variable in any script, command, function, script cmdlet or expression that you run until you disable or remove the breakpoint.</source>
          <target state="translated">例如，如果您设置了断点 $name 变量，调试器中断在任何脚本、 命令、 函数、 脚本 cmdlet 或表达式中任何 $name 变量上，您运行直到您禁用或删除的断点。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This allows you to debug your scripts in a more realistic context in which they might be affected by functions, variables, and other scripts in the session and in the user's profile.</source>
          <target state="translated">这样，您可以调试在其中它们可能会受函数、 变量和其他脚本在会话中并且在用户的配置文件中更真实上下文中的脚本。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Line breakpoints are specific to script files, so they are set only in script files.</source>
          <target state="translated">因此，这些设置仅在脚本文件中，行断点是特定于脚本文件。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Debugging Workflows The Windows PowerShell 4.0 debugger can be used to debug Windows PowerShell workflows, either in the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">调试工作流的 Windows PowerShell 4.0 可以使用调试器来调试 Windows PowerShell 工作流，在 Windows PowerShell 控制台中，或在 Windows PowerShell ISE。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There are some limitations with using the Windows PowerShell debugger to debug workflows.</source>
          <target state="translated">有一些限制与使用 Windows PowerShell 调试器来调试工作流。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>-- You can view workflow variables while you are in the debugger, but setting workflow variables from within the debugger is not supported.</source>
          <target state="translated">-您可以查看工作流变量，而是在调试器中，但不是支持设置从在该调试器内的工作流变量。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>-- Tab completion when stopped in the workflow debugger is not available.</source>
          <target state="translated">-Tab 自动补全在工作流调试器中停止时将不可用。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>-- Workflow debugging works only with synchronous running of workflows from a Windows PowerShell script.</source>
          <target state="translated">-工作流调试仅适用于从 Windows PowerShell 脚本的工作流的同步正在运行。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot debug workflows if they are running as a job (with the –AsJob parameter).</source>
          <target state="translated">如果它们 （使用 – AsJob 参数中） 运行作为作业，则不能调试工作流。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-- Other nested debugging scenarios--such as a workflow calling another workflow, or a workflow calling a script--are not implemented.</source>
          <target state="translated">-其他嵌套的调试方案 — 如调用另一个工作流，工作流或工作流调用脚本-未实现。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example demonstrates debugging a workflow.</source>
          <target state="translated">下面的示例演示如何调试工作流。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that when the debugger steps into the workflow function, the debugger prompt changes to [WFDBG].</source>
          <target state="translated">请注意，当调试器单步执行工作流函数中的，调试器提示符将更改为 [WFDBG]。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Set-PSBreakpoint -Script C:\TestWFDemo1.ps1 -Line 8</source>
          <target state="translated">PS c: &gt; Set-psbreakpoint-脚本 C:\TestWFDemo1.ps1-是第 8 行</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ID Script           Line Command    Variable     Action</source>
          <target state="translated">ID 脚本行命令变量操作</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>0 TestWFDemo1.ps1   8</source>
          <target state="translated">0 TestWFDemo1.ps1 8</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>PS C:&gt; C:\TestWFDemo1.ps1 Entering debug mode.</source>
          <target state="translated">PS c: &gt; C:\TestWFDemo1.ps1 进入调试模式。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或？</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">获取帮助。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\TestWFDemo1.ps1:8'</source>
          <target state="translated">在 C:\TestWFDemo1.ps1:8 命中的行断点</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>At C:\TestWFDemo1.ps1:8 char:5</source>
          <target state="translated">在 C:\TestWFDemo1.ps1:8 char: 5</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Now writing output:"</source>
          <target state="translated">将输出写入 InputObject"现在正在写入的输出:"</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~</source>
          <target state="translated">+!包括 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>3:</source>
          <target state="translated">3：</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4︰ 工作流 SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>8:*     Write-Output -InputObject "Now writing output:" 9:      Write-Output -Input $MyOutput</source>
          <target state="translated">8: * Write-output-InputObject"现在正在写入的输出:"9: Write-output-输入 $MyOutput</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output-InputObject"获取 PowerShell 进程:"12: Get-process-名称 powershell</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-InputObject"工作流函数完成"。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # 调用工作流函数 18: SampleWorkflowTest MyOutput"Hello"</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">Hello</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Now writing output: At C:\TestWFDemo1.ps1:9 char:5</source>
          <target state="translated">现在正在写入的输出︰ 在 C:\TestWFDemo1.ps1:9 char: 5</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Write-Output -Input $MyOutput</source>
          <target state="translated">写入-Output-输入 $MyOutput</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~</source>
          <target state="translated">+!包括 [] ~</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4︰ 工作流 SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>8:      Write-Output -InputObject "Now writing output:" 9:*     Write-Output -Input $MyOutput</source>
          <target state="translated">8: Write-output-InputObject"现在正在写入的输出:"9: * Write-output-输入 $MyOutput</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output-InputObject"获取 PowerShell 进程:"12: Get-process-名称 powershell</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-InputObject"工作流函数完成"。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # 调用工作流函数 18: SampleWorkflowTest MyOutput"Hello"</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Hello At C:\TestWFDemo1.ps1:11 char:5</source>
          <target state="translated">Hello 在 C:\TestWFDemo1.ps1:11 char: 5</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Get PowerShell process:"</source>
          <target state="translated">将输出写入 InputObject"获取 PowerShell 进程:"</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~</source>
          <target state="translated">+!包括 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Get PowerShell process:</source>
          <target state="translated">获取 PowerShell 进程︰</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)   WS(K) VM(M)   CPU(s)     Id ProcessName    PSComputerName</source>
          <target state="translated">处理 npm （k) pm （k) ws （k) vm （m) CPU(s) Id ProcessName PSComputerName</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>433      35   106688   128392   726     2.67   7124 powershell    localhost 499      44   134244   172096   787     2.79   7452 powershell    localhost Workflow function complete.</source>
          <target state="translated">433 35 106688 128392 726 为 2.67 7124 powershell localhost 499 44 134244 172096 787 2.79 7452 powershell localhost 完成的工作流函数。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Debugging Functions When you set a breakpoint on a function that has Begin, Process, and End sections, the debugger breaks at the first line of each section.</source>
          <target state="translated">调试器将调试函数在具有 Begin、 Process 和 End 部分的函数设置断点时，每个部分的第一行处中断。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>function test-cmdlet { begin { write-output "Begin" } process { write-output "Process" } end { write-output "End" } }</source>
          <target state="translated">函数测试 cmdlet {开始 {写入输出"Begin"} {写入输出"进程"} 进程结束 {写入输出"End"}}</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; set-psbreakpoint -command test-cmdlet</source>
          <target state="translated">C:\PS &gt; 设置的命令测试 cmdlet</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; test-cmdlet</source>
          <target state="translated">C:\PS &gt; 测试 cmdlet</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Begin Entering debug mode.</source>
          <target state="translated">开始进入调试模式。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或？</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">获取帮助。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">命令断点命中在提示︰ test-cmdlet</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">测试 cmdlet</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Process Entering debug mode.</source>
          <target state="translated">处理输入调试模式。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或？</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">获取帮助。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">命令断点命中在提示︰ test-cmdlet</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">测试 cmdlet</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Entering debug mode.</source>
          <target state="translated">结束输入调试模式。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或？</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">获取帮助。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">命令断点命中在提示︰ test-cmdlet</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">测试 cmdlet</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;</source>
          <target state="translated"><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS &gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Debugging Remote Scripts Starting in Windows PowerShell 5.0, you can run the Windows PowerShell debugger in a remote session, in either the console, or Windows PowerShell ISE.</source>
          <target state="translated">调试远程脚本启动 Windows PowerShell 5.0 中，可以在远程会话中，在控制台中，或 Windows PowerShell ISE 中运行 Windows PowerShell 调试程序。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running on a remote computer, and currently running a script.</source>
          <target state="translated">已更新输入 PSSession 功能，使您重新连接到和输入断开连接的会话是远程计算机上运行并且当前正在运行一个脚本。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">如果运行的脚本遇到断点，客户端会话将自动启动调试器。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following is an example that shows how this works, with breakpoints set in a script at lines 6, 11, 22, and 25.</source>
          <target state="translated">下面是一个示例，说明工作原理，在第 6、 11、 22 和 25 行在脚本中设置断点。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Note that in the example, when the debugger starts, there are two identifying prompts: the name of the computer on which the session is running, and the DBG prompt that lets you know you are in debugging mode.</source>
          <target state="translated">请注意，在示例中，调试器在启动时，有两个标识的提示︰ 运行该会话的计算机和 DBG 提示，您可以了解自己在调试模式中的名称。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Enter-Pssession -Cn localhost</source>
          <target state="translated">输入 Pssession-Cn localhost</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>ID Script          Line     Command          Variable          Action</source>
          <target state="translated">ID 脚本行命令变量操作</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0 ttest19.ps1          6 1 ttest19.ps1          11 2 ttest19.ps1          22 3 ttest19.ps1          25</source>
          <target state="translated">0 ttest19.ps1 6 1 ttest19.ps1 11 2 ttest19.ps1 22 3 ttest19.ps1 25</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\psscripts\ttest19.ps1:11'</source>
          <target state="translated">在 C:\psscripts\ttest19.ps1:11 命中的行断点</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:11 char:1</source>
          <target state="translated">在 C:\psscripts\ttest19.ps1:11 char: 1</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>$winRMName = "WinRM"</source>
          <target state="translated">$winRMName ="WinRM"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>6:      1..5 | foreach { sleep 1; Write-Output "hello2day $_" } 7:  }</source>
          <target state="translated">6: 1..5 |foreach {睡眠 1;Write-output"hello2day $_"} 7:}</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>8:</source>
          <target state="translated">8:</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>9:  $count = 10 10:  $psName = "PowerShell" 11:* $winRMName = "WinRM" 12:  $myVar = 102</source>
          <target state="translated">9: $count = 10 10: $psName ="PowerShell"11: * $winRMName ="WinRM"12: $myVar = 102</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>14:  for ($i=0; $i -lt $count; $i++) 15:  { 16:      sleep 1 17:      Write-Output "Loop iteration is: $i" 18:      Write-Output "MyVar is $myVar"</source>
          <target state="translated">14︰ 对于 ($i = 0; $i lt $count; $i + +) 15: {16︰ 睡眠 1 17: Write-output"循环迭代都是︰ $i"18: Write-output"MyVar 是 $myVar"</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>20:      hello2day</source>
          <target state="translated">20: hello2day</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>21:</source>
          <target state="translated">21:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:12 char:1</source>
          <target state="translated">在 C:\psscripts\ttest19.ps1:12 char: 1</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>$myVar = 102</source>
          <target state="translated">$myVar = 102</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">本地主机</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>PS C:\psscripts&gt;</source>
          <target state="translated">PS C:\psscripts &gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Examples This test script detects the version of the operating system and displays a system-appropriate message.</source>
          <target state="translated">此测试脚本检测到的操作系统版本，并显示相应系统的消息的示例。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It includes a function, a function call, and a variable.</source>
          <target state="translated">它包括函数、 函数调用和一个变量。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following command displays the contents of the test script file:</source>
          <target state="translated">下面的命令显示测试脚本文件的内容︰</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>c:&gt;\PS-test&gt;  get-content test.ps1</source>
          <target state="translated">c: &gt; \PS-test &gt; get 内容 test.ps1</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>function psversion { "Windows PowerShell " + $psversiontable.psversion if ($psversiontable.psversion.major -lt 2) { "Upgrade to Windows PowerShell 2.0!"</source>
          <target state="translated">函数 psversion {"Windows PowerShell"+ $psversiontable.psversion 如果 ($psversiontable.psversion.major lt 2) {"升级到 Windows PowerShell 2.0 ！"</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>} else { "Have you run a background job today (start-job)?"</source>
          <target state="translated">} else {"您是否已经运行后台作业今天 (start-job)？"</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>} }</source>
          <target state="translated">} }</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path psversion "Done $scriptname."</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path psversion"已完成 $scriptname。"</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To start, set a breakpoint at a point of interest in the script, such as a line, command, variable, or function.</source>
          <target state="translated">若要开始，请在脚本中，如行、 命令、 变量或函数的感兴趣的点处设置断点。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Start by creating a line breakpoint on the first line of the Test.ps1 script in the current directory.</source>
          <target state="translated">首先在 Test.ps1 脚本当前目录中的第一行上创建一个行断点。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -line 1 -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; 设置-行 1-脚本 test.ps1</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">可将此命令缩写为：</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; spb 1 -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; 存储 1-s test.ps1</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The command returns a line-breakpoint object (System.Management.Automation.LineBreakpoint).</source>
          <target state="translated">该命令返回一个行断点对象 (System.Management.Automation.LineBreakpoint)。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Column     : 0 Line       : 1 Action     : Enabled    : True HitCount   : 0 Id         : 0 Script     : C:\ps-test\test.ps1 ScriptName : C:\ps-test\test.ps1</source>
          <target state="translated">列︰ 0 行︰ 1 项操作︰ 启用︰ True 点击次数︰ 0 Id: 0 脚本︰ C:\ps-test\test.ps1 ScriptName: C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">现在，以下命令启动脚本。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When the script reaches the first breakpoint, the breakpoint message indicates that the debugger is active.</source>
          <target state="translated">当脚本到达第一个断点时，断点消息指示调试器处于活动状态。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It describes the breakpoint and previews the first line of the script, which is a function declaration.</source>
          <target state="translated">它介绍该断点并预览该脚本，它是函数声明的第一行。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The command prompt also changes to indicate that the debugger has control.</source>
          <target state="translated">命令提示符下也会更改以指示调试器有控件。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The preview line includes the script name and the line number of the previewed command.</source>
          <target state="translated">预览行包括脚本名称和预览命令的行号。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Entering debug mode.</source>
          <target state="translated">进入调试模式。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或？</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">获取帮助。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\ps-test\test.ps1:1'</source>
          <target state="translated">在 C:\ps-test\test.ps1:1 命中的行断点</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>test.ps1:1   function psversion {</source>
          <target state="translated">test.ps1:1 函数 psversion {</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Use the Step command (s) to execute the first statement in the script and to preview the next statement.</source>
          <target state="translated">若要在脚本中执行的第一个语句和预览的下一个语句，请使用步骤命令 (s)。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The next statement uses the $MyInvocation automatic variable to set the value of the $ScriptName variable to the path and file name of the script file.</source>
          <target state="translated">下一条语句使用 $MyInvocation 自动变量将 $ScriptName 变量的值设置为脚本文件的路径和文件名的名称。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:11  $scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">DBG &gt; s test.ps1:11 $scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is not populated, but you can verify the value of the variable by displaying its value.</source>
          <target state="translated">在这种情况下，未填充 $ScriptName 变量，但您可以通过显示值验证该变量的值。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In this case, the value is $null.</source>
          <target state="translated">在这种情况下，值为 $null。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Use another Step command (s) to execute the current statement and to preview the next statement in the script.</source>
          <target state="translated">若要执行当前语句和预览在脚本中的下一个语句，请使用另一个步骤命令 (s)。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The next statement calls the PsVersion function.</source>
          <target state="translated">下一条语句调用 PsVersion 函数。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is populated, but you verify the value of the variable by displaying its value.</source>
          <target state="translated">此时，将填充 $ScriptName 变量，但通过显示值验证变量的值。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>In this case, the value is set to the script path.</source>
          <target state="translated">在这种情况下，将值设置为脚本路径。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Use another Step command to execute the function call.</source>
          <target state="translated">使用另一个步骤命令来执行函数调用。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Press ENTER, or type "s" for Step.</source>
          <target state="translated">按 ENTER，或键入"s"步骤。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:2       "Windows PowerShell " + $psversiontable.psversion</source>
          <target state="translated">DBG &gt; s test.ps1:2"Windows PowerShell"+ $psversiontable.psversion</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The debug message includes a preview of the statement in the function.</source>
          <target state="translated">调试消息包括在函数中的语句的预览。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To execute this statement and to preview the next statement in the function, you can use a Step command.</source>
          <target state="translated">若要执行此语句并预览该函数中的下一个语句，您可以使用步骤命令。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But, in this case, use a Step-Out command (o).</source>
          <target state="translated">但是，在这种情况下，使用 Step-out 命令 (o)。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It completes the execution of the function (unless it reaches a breakpoint) and steps to the next statement in the script.</source>
          <target state="translated">（除非它到达断点时） 完成函数的执行和在脚本中的下一个语句的步骤。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>DBG&gt; o Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; o Windows PowerShell 2.0 已运行后台作业今天 (start-job)？</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">"已完成 $scriptname"test.ps1:13</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Because we are on the last statement in the script, the Step, Step-Out, and Continue commands have the same effect.</source>
          <target state="translated">因为我们在脚本中，该步骤中的最后一个语句上步骤扩展和继续命令具有相同的效果。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In this case, use Step-Out (o).</source>
          <target state="translated">在这种情况下，使用跳出 (o)。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1 PS C:\ps-test&gt;</source>
          <target state="translated">完成 C:\ps-test\test.ps1 PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The Step-Out command executes the last command.</source>
          <target state="translated">Step-out 命令执行的最后一个命令。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The standard command prompt indicates that the debugger has exited and returned control to the command processor.</source>
          <target state="translated">标准命令提示符表示调试器已退出，控制权返回给命令处理器。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Now, run the debugger again.</source>
          <target state="translated">现在，再次运行调试器。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>First, to delete the current breakpoint, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">首先，要删除当前断点，请使用 Get-psbreakpoint 和 Remove-psbreakpoint cmdlet。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>(If you think you might reuse the breakpoint, use the Disable-PsBreakpoint cmdlet instead of Remove-PsBreakpoint.)</source>
          <target state="translated">（如果您认为可能会重复使用断点，使用 Disable-psbreakpoint cmdlet 而不是 Remove-psbreakpoint。）</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">可将此命令缩写为：</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; gbp | rbp</source>
          <target state="translated">PS C:\ps-test &gt; gbp |rbp</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Or, run the command by writing a function, such as the following function:</source>
          <target state="translated">或者，通过编写一个函数，如下面的函数来运行命令︰</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>function delbr { gbp | rbp }</source>
          <target state="translated">函数 delbr {gbp | rbp}</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Now, create a breakpoint on the $scriptname variable.</source>
          <target state="translated">现在，$scriptname 变量上创建一个断点。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -variable scriptname -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; 设置-变量 scriptname-test.ps1 脚本</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">您可以将命令缩写为︰</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -v scriptname -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-v scriptname-s test.ps1</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">现在，以下命令启动脚本。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The script reaches the variable breakpoint.</source>
          <target state="translated">该脚本可能会达到变量断点。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The default mode is Write, so execution stops just before the statement that changes the value of the variable.</source>
          <target state="translated">默认模式是写的因此只需更改变量的值在语句前执行将停止。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Variable breakpoint on 'C:\ps-test\test.ps1:$scriptname' (Write access)</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 变量命中断点上 C:\ps-test\test.ps1:$scriptname （写入访问权限）</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>test.ps1:11  $scriptname = $MyInvocation.mycommand.path</source>
          <target state="translated">test.ps1:11 $scriptname = $MyInvocation.mycommand.path</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Display the current value of the $scriptname variable, which is $null.</source>
          <target state="translated">显示 $scriptname 变量，即 $null 的当前值。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to execute the statement that populates the variable.</source>
          <target state="translated">使用步骤命令 (s) 来执行用于填充该变量的语句。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Then, display the new value of the $scriptname variable.</source>
          <target state="translated">然后，显示 $scriptname 变量的新值。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to preview the next statement in the script.</source>
          <target state="translated">使用步骤命令 (s) 预览在脚本中的下一个语句。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The next statement is a call to the PsVersion function.</source>
          <target state="translated">下一个语句是对 PsVersion 函数的调用。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To skip the function but still execute it, use a Step-Over command (v).</source>
          <target state="translated">若要跳过该函数，但仍可以执行它，使用逐过程命令 (v)。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>If you are already in the function when you use Step-Over, it is not effective.</source>
          <target state="translated">如果您已在函数中使用逐过程时，，才会生效。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The function call is displayed, but it is not executed.</source>
          <target state="translated">将显示函数调用，但不是执行。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>DBG&gt; v Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; v Windows PowerShell 2.0 已运行后台作业今天 (start-job)？</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">"已完成 $scriptname"test.ps1:13</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The Step-Over command executes the function, and it previews the next statement in the script, which prints the final line.</source>
          <target state="translated">逐过程命令执行函数，并且可以预览打印的最后一行脚本中的下一个语句。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use a Stop command (t) to exit the debugger.</source>
          <target state="translated">使用 Stop 命令 (t，) 退出调试器。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The command prompt reverts to the standard command prompt.</source>
          <target state="translated">命令提示符下将恢复为标准的命令提示符。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>C:\ps-test&gt;</source>
          <target state="translated">C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>To delete the breakpoints, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">若要删除断点，请使用 Get-psbreakpoint 和 Remove-psbreakpoint cmdlet。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Create a new command breakpoint on the PsVersion function.</source>
          <target state="translated">有关 PsVersion 函数创建一个新的命令断点。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Set-PsBreakpoint -command psversion -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-psbreakpoint-命令 psversion-test.ps1 脚本</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command to:</source>
          <target state="translated">你可以将此命令对缩写︰</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -c psversion -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-c psversion-s test.ps1</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">现在，运行该脚本。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion' 上的.\test.ps1 命中命令断点</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The script reaches the breakpoint at the function call.</source>
          <target state="translated">该脚本可能会达到函数调用处的断点。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>At this point, the function has not yet been called.</source>
          <target state="translated">此时，尚未调用该函数。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This gives you the opportunity to use the Action parameter of Set-PsBreakpoint to set conditions for the execution of the breakpoint or to perform preparatory or diagnostic tasks, such as starting a log or invoking a diagnostic or security script.</source>
          <target state="translated">这使您可以使用 Set-psbreakpoint 的操作参数可以设置断点的执行条件或执行准备或诊断任务，如开始记录或调用诊断或安全脚本。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>To set an action, use a Continue command (c) to exit the script, and a Remove-PsBreakpoint command to delete the current breakpoint.</source>
          <target state="translated">若要设置某项操作，使用继续命令 (c) 退出该脚本并 Remove-psbreakpoint 命令以删除当前断点。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>(Breakpoints are read-only, so you cannot add an action to the current breakpoint.)</source>
          <target state="translated">（断点是只读的因此无法将操作添加到当前断点处。）</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>DBG&gt; c Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; c Windows PowerShell 2.0 已运行后台作业今天 (start-job)？</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1</source>
          <target state="translated">完成的 C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; get-psbreakpoint | remove-psbreakpoint PS C:\ps-test&gt;</source>
          <target state="translated">PS C:\ps-test &gt; get psbreakpoint |删除 psbreakpoint PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Now, create a new command breakpoint with an action.</source>
          <target state="translated">现在，与操作创建新的命令断点。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The following command sets a command breakpoint with an action that logs the value of the $scriptname variable when the function is called.</source>
          <target state="translated">以下命令将设置命令断点，当调用该函数时，记录 $scriptname 变量的值的操作。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Because the Break keyword is not used in the action, execution does not stop.</source>
          <target state="translated">由于在操作中未使用 Break 关键字，则不会停止执行。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the line-continuation character.)</source>
          <target state="translated">（反引号 （'） 是行继续符。）</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -command psversion -script test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname is $scriptname."</source>
          <target state="translated">PS C:\ps-test &gt; 设置-命令 psversion-脚本 test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname 是 $scriptname。"</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>` -path action.log}</source>
          <target state="translated">-路径 action.log}</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can also add actions that set conditions for the breakpoint.</source>
          <target state="translated">此外可以添加设置断点的条件的操作。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>In the following command, the command breakpoint is executed only if the execution policy is set to RemoteSigned, the most restrictive policy that still permits you to run scripts.</source>
          <target state="translated">在下面的命令，仅当执行策略设置为 RemoteSigned，仍允许您运行脚本的限制性最强的策略执行命令断点。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the continuation character.)</source>
          <target state="translated">（反引号 （'） 是继续符。）</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -script test.ps1 -command psversion ` -action { if ((get-executionpolicy) -eq "RemoteSigned") { break }}</source>
          <target state="translated">PS C:\ps-test &gt; 设置-test.ps1 脚本的命令 psversion '-操作 {如果 ((get-executionpolicy)-eq"RemoteSigned") {中断}}</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The Break keyword in the action directs the debugger to execute the breakpoint.</source>
          <target state="translated">在操作中的 Break 关键字指示调试器能够在执行断点。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>You can also use the Continue keyword to direct the debugger to execute without breaking.</source>
          <target state="translated">Continue 关键字还可用于指示调试器要执行但不会破坏。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Because the default keyword is Continue, you must specify Break to stop execution.</source>
          <target state="translated">Default 关键字为 Continue，因为您必须指定要停止执行中断。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">现在，运行该脚本。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion' 上的.\test.ps1 命中命令断点</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Because the execution policy is set to RemoteSigned, execution stops at the function call.</source>
          <target state="translated">因为执行策略设为 RemoteSigned，则会在函数调用处停止执行。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>At this point, you might want to check the call stack.</source>
          <target state="translated">此时，您可能想要检查调用堆栈。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Use the Get-PsCallStack cmdlet or the Get-PsCallStack debugger command (k).</source>
          <target state="translated">使用 Get-pscallstack cmdlet 或 Get-pscallstack 调试器命令 (k)。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The following command gets the current call stack.</source>
          <target state="translated">以下命令将获取当前的调用堆栈。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>DBG&gt; k 2: prompt 1: .\test.ps1: $args=[] 0: prompt: $args=[]</source>
          <target state="translated">DBG &gt; k 2︰ 提示 1:.\test.ps1: $args = [0]: 提示符︰ $args =]</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example demonstrates just a few of the many ways to use the Windows PowerShell debugger.</source>
          <target state="translated">此示例演示一些使用 Windows PowerShell 调试程序的很多方法。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For more information about the debugger cmdlets, type the following command:</source>
          <target state="translated">有关调试器 cmdlet 的详细信息，请键入以下命令︰</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>help &lt;cmdlet-name&gt; -full</source>
          <target state="translated">帮助 &lt; t e &gt;-完整</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>For example, type:</source>
          <target state="translated">例如，键入︰</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>help set-psbreakpoint -full</source>
          <target state="translated">帮助设置-完整</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Other Debugging Features in Windows PowerShell</source>
          <target state="translated">Windows PowerShell 中其他调试功能</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>In addition to the Windows PowerShell debugger, Windows PowerShell includes several other features that you can use to debug scripts and functions.</source>
          <target state="translated">除了 Windows PowerShell 调试程序，Windows PowerShell 中包含可用于调试脚本和函数的其他几个功能。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-- Windows PowerShell Integrated Scripting Environment (ISE) includes an interactive graphical debugger.</source>
          <target state="translated">-Windows PowerShell 集成脚本环境 (ISE) 包括非交互式图形调试器。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, start Windows PowerShell ISE and press F1.</source>
          <target state="translated">有关详细信息，启动 Windows PowerShell ISE 并按 F1。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-- The Set-PSDebug cmdlet offers very basic script debugging features, including stepping and tracing.</source>
          <target state="translated">--Set-psdebug cmdlet 提供了非常简单的脚本调试功能，其中包括单步执行和跟踪。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-- Use the Set-StrictMode cmdlet to detect references to uninitialized variables, to references to non-existent properties of an object, and to function syntax that is not valid.</source>
          <target state="translated">--使用 Set-strictmode cmdlet 来检测到未初始化的变量，以对不存在的对象的属性的引用以及对不是有效的函数语法的引用。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>-- Add diagnostic statements to a script, such as statements that display the value of variables, statements that read input from the command line, or statements that report the current instruction.</source>
          <target state="translated">--添加诊断语句到一个脚本，如显示的变量的值的语句、 读取从命令行输入的语句或报告当前指令的语句。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Use the cmdlets that contain the Write verb for this task, such as Write-Host, Write-Debug, Write-Warning, and Write-Verbose.</source>
          <target state="translated">使用包含对于此任务，如 Write-host Write-debug，Write-warning 写谓词和写入详细的 cmdlet。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</source>
          <target state="translated">Disable-psbreakpoint 启用-PsBreakpoint Get-psbreakpoint Get-PsCallStack Remove-psbreakpoint Set-psbreakpoint Set-psdebug 设置-Strictmode Write-debug Write-verbose</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>