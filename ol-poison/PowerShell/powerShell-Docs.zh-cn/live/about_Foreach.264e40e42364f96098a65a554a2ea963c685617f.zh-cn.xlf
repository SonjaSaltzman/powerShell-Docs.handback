<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f31f43a46b7310525bae25f8c51c138d3ae0a7cf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a4052ae04996c162cc37e7970e28e6f60409e9e9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">有关 ForEach</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">描述可用于遍历集合中的项的所有项的语言命令。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">Foreach 语句 （也称为 Foreach 循环） 是一种语言构造个逐句通过 （循环） 的一系列集合中的项的值。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">要遍历集合的最简单、 最典型类型是一个数组。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">在 Foreach 循环中，很普遍对数组中的每个项运行一个或多个命令。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">以下语法显示了 ForEach 语法︰</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">foreach ($<ph id="ph1">&lt;item&gt;</ph> <ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">简化的语法启动 Windows PowerShell 3.0 中，语法与语言关键字，如 Where 和极大地简化了 ForEach。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">在集合中的成员工作的比较运算符被视为参数。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">可以在集合中的成员上使用一种方法，而无需包含在脚本块或添加自动变量"$_"。。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">请考虑以下两个示例︰</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">dir cert: \-Recurse |foreach GetKeyAlgorithm dir cert: \-Recurse |foreach {$_。GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">尽管这两个命令起作用，但第一个返回的结果而不使用脚本块或 $_。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">自动变量。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">方法 GetKeyAlgorithm 视为 ForEach 的参数。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">第一个命令将返回相同的结果，但不会出错，因为简化的语法不会尝试返回为其指定的参数未应用的项目的结果。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">在此示例中，Get-process 属性的说明传递作为参数传递的 ForEach 语句。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">结果是活动进程的描述。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-process |ForEach 说明</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">命令管道 Foreach 语句括在括号中的一部分之外的 Foreach 语句表示变量和要循环访问的集合。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell 将创建该变量 ($<ph id="ph1">&lt;item&gt;</ph>) 自动在 Foreach 循环运行。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">在每次迭代循环时之前, 该变量设置为集合中的值。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">在 Foreach 语句之后的块 {<ph id="ph1">&lt;statement list&gt;</ph>} 包含一组对集合中的每个项执行命令。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">示例的示例中，下面的示例中的 Foreach 循环显示 $letterArray 数组中的值。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray ="a"、"b"、"c"，"d"foreach ($letter 中 $letterArray) {Write-host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">在此示例中，创建和使用字符串的值初始化 $letterArray 数组"a"、"b"、"c"和"d"。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">首次 Foreach 语句运行时，它将设置 $letter 变量为相等的第一项 $letterArray ("a") 中。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">然后，它使用 Write-host cmdlet 来显示字母。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">下一次执行循环时，$letter 设置为"b"，依次类推。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">Foreach 循环显示字母 d 后，Windows PowerShell 将退出的循环。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">整个 Foreach 语句必须出现在单个行来将其作为一个命令在 Windows PowerShell 命令提示符下运行。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">整个 Foreach 语句没有改为将此命令在.ps1 脚本文件的情况下出现在一行上。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">此外可以与返回的项的集合的 cmdlet 一起使用 Foreach 语句。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">在下面的示例中，Get-childitem cmdlet 返回的项的列表的 Foreach 语句步骤。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">foreach ($file 中的 Get-childitem) {Write-host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">您可以优化该示例通过使用 If 语句，以限制返回的结果。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">在下面的示例中，Foreach 语句执行相同的循环操作与前面的示例中，但它添加 If 语句，以将结果限制为大于 100 的千字节 (KB) 的文件︰</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">foreach ($file 中的 Get-childitem) {如果 ($file.length-gt 100 KB) {Write-host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">在此示例中，Foreach 循环使用 $file 变量的属性来执行比较运算 ($file.length-gt 100 KB)。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">$File 变量包含的 Get-childitem cmdlet 返回的对象中的所有属性。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">因此，您可以返回远不止一个文件名。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">在下一个示例中，Windows PowerShell 将返回的长度和上次访问时间内的语句列表︰</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">foreach ($file 中的 Get-childitem) {如果 ($file.length-gt 100 KB) {Write-host $file Write-host $file.length Write-host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">在此示例中，您并不局限于在一个语句列表运行单个命令。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">您还可以使用 Foreach 循环之外的变量，并递增该变量在循环内。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">下面的示例计算文件超过 100 KB 的大小︰</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i = 0 foreach ($file 中的 Get-childitem) {如果 ($file.length-gt 100 KB) {Write-host $file"文件的大小:"($file.length / 1024年)。ToString("F0") KB $i = $i + 1}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">如果 ($i ne 0) {Write-host Write-host $i"文件超过 100 KB 到当前目录中。"}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">else {Write-host"没有文件大于 100 KB 当前目录中。"</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">在前面的示例中，$i 变量设置为 0 跳出循环，并在循环中的每个文件，它位于大小超过 100 KB 递增该变量。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">在循环时退出，If 语句的评估结果 $i 以显示所有文件超过 100 KB 数的值。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">或者，它将显示一条消息表明已找到的任何文件超过 100 KB。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">前面的示例还演示如何设置文件长度结果的格式︰</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length / 1024年)。ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">值除以 1024，以千字节为单位，而不是个字节，在显示的结果，然后使用定点格式说明符从结果中删除任何十进制值格式化所得到的值。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">0 使显示没有小数位的格式说明符。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Foreach 语句内命令管道时 Foreach 出现在命令管道中，Windows PowerShell 将使用 foreach 别名，该调用 Foreach-object 命令别名。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">当您在命令管道中使用 foreach 别名时，但不包括 ($<ph id="ph1">&lt;item&gt;</ph> <ph id="ph2">&lt;collection&gt;</ph>) 与您的语法使用 Foreach 语句执行操作。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">这是因为在管道中以前的命令会提供此信息。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">当在命令管道中使用的 foreach 别名的语法是，如下所示︰</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">|foreach {&lt; command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">例如，下面的命令中的 Foreach 循环显示的进程的工作集 （内存使用率） 是大于 20 兆字节 (MB)。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">Get-Process 命令可获取计算机上的所有进程。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Foreach 别名命令在执行上的每个进程的脚本块的序列中。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">IF 语句将选择具有大于 20 兆字节为单位的工作集 (WS) 的进程。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">Write-host cmdlet 将写入进程跟一个冒号的名称。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">它会将划分工作集值，该值以字节为单位存储 1 兆字节来获取工作集值单位为兆字节。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">然后它将转换结果一个双精度值为字符串。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">它显示的值为具有零个小数位 (F0)，空间分隔符固定点数字 ("")，然后"mb"。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">写入主机"与工作集大于 20 MB 的进程"。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-process |foreach {如果 ($_。WS-gt 20 MB) {Write-host $.name":"（$。WS/1MB)。ToString("F0") MB-分隔符""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">Foreach 别名还支持开始命令块，中间命令块和最终命令块。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">开始和结束命令块运行一次，并每次 Foreach 循环通过集合或数组的步骤时运行的中间命令块。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">Foreach 别名的命令管道中含有一开头、 中间和结束组命令块中使用时的语法是，如下所示︰</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">|foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">下面的示例演示如何将开头、 中间颜色和结束命令块。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-childitem |foreach {$fileCount = $directoryCount = 0} {如果 ($_。PsIsContainer) {$directoryCount + +} else {$fileCount + +}} {"$directoryCount 目录和 $fileCount 文件"}</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">开始阻止创建并初始化为 0 的两个变量︰</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount = $directoryCount = 0}</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">中间块评估是否由 Get-childitem 返回的每一项是目录还是文件︰</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{如果 ($_。PsIsContainer) {$directoryCount + +} else {$fileCount + +}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">如果返回的项是一个目录，$directoryCount 变量增加 1。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">如果该项不是一个目录，$fileCount 变量增加 1。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">结束块运行后的中间块完成其循环操作，然后返回操作的结果︰</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{"$directoryCount 目录和 $fileCount 文件"}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">通过使用开始、 中间和结束命令块结构并使用管道运算符，您可以重写前面的示例查找任何文件是大于 100 KB，如下所示︰</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-childitem |foreach {$i = 0} {如果 ($_.length-gt 100 KB) {Write-host $.name"文件的大小:"($.length / 1024年)。ToString("F0") KB $i + +}} {如果 ($i ne 0) {Write-host Write-host"$i 文件超过 100 KB 当前目录中。"</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-host"没有文件大于 100 KB 当前目录中。"}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">下面的示例中，它将返回脚本和脚本模块中使用的函数的函数演示如何使用 MoveNext 方法 （它为"skip X"，在 For 循环的工作方式与此类似） 和 foreach 脚本块中，内部 $foreach 变量的 Current 属性，即使跨多个行来声明函数名称的异常或不一致间距函数定义。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">此示例还处理中是否存在注释在脚本或脚本模块中使用的函数。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">函数获取 FunctionPosition {[CmdletBinding()] [OutputType('FunctionPosition')] param ([参数 (位置 = 0 时，必需，ValueFromPipeline，ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String []] $Path</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">进程 {尝试 {$filesToProcess = if ($_-是 [System.IO.FileSystemInfo]) {</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-item-路径 $Path} foreach ($item 中 $filesToProcess) {如果 ($item。PSIsContainer-或 $item。扩展的不足 @('.ps1','.psm1')) {继续} $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile ($item。FullName,([REF]$tokens),([REF]$errors)) 如果 ($errors) {Write-warning"文件 $($item.FullName)' 具有 $($errors.计数） 分析器错误。"</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: tokenLoop foreach ($token 中 $tokens) {如果 ($token。类型-ne Function) {继续} $position = $token。Extent.StartLineNumber 执行 {如果 (-不 $foreach。MoveNext()) {中断 tokenLoop} $token = $foreach。当前} 直到 ($token。类型-在 @('Generic','Identifier')) $functionPosition = [pscustomobject] @{名称 = $token。文本行号 = $position 路径 = $item。FullName} Add-member-InputObject $functionPosition-TypeName FunctionPosition-PassThru}}} catch {throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">about_Automatic_Variables about_If Foreach 对象</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>