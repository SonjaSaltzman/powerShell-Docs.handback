<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d59635115104ea0d446e96863147805402a802b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Methods.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da528ad56c762ad7c9c2abd8777cc6e758400983</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">353d62fac859ec6df86fc2836233a7e9182defea</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_methods</source>
          <target state="translated">about_methods</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About methods</source>
          <target state="translated">有关方法</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_methods</source>
          <target state="translated">about_methods</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_methods</source>
          <target state="translated">about_methods</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use methods to perform actions on objects in  Windows PowerShell�.</source>
          <target state="translated">描述如何使用方法来对 Windows PowerShell 中的对象执行操作。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses objects to represent the items in data stores or the state of the computer.</source>
          <target state="translated">Windows PowerShell 使用对象来表示数据存储区或计算机的状态中的项。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, FileInfo objects represent the files in file system drives and ProcessInfo objects represent the processes on the computer.</source>
          <target state="translated">例如，FileInfo 对象表示在文件系统驱动器的文件，并且 ProcessInfo 对象表示在计算机上的进程。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Objects have properties, which store data about the object, and methods that let you change the object.</source>
          <target state="translated">对象具有属性，其中存储有关对象的数据，并允许您更改该对象的方法。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A "method" is a set of instructions that specify an action you can perform on the object.</source>
          <target state="translated">"方法"是一组指定可对对象执行的操作的说明。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For example, the FileInfo object includes the CopyTo method that copies the file that the FileInfo object represents.</source>
          <target state="translated">例如，FileInfo 对象包括将 FileInfo 对象都表示该文件复制 CopyTo 方法。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>To get the methods of any object, use the Get-Member cmdlet.</source>
          <target state="translated">若要获取的任何对象的方法，请使用 Get-member cmdlet。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Use its MemberType property with a value of "Method".</source>
          <target state="translated">其 MemberType 属性值为"方法"一起使用。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following command gets the methods of process objects.</source>
          <target state="translated">以下命令将获取进程对象的方法。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To perform or "invoke" a method of an object, type a dot (.), the method name, and a set of parentheses "()".</source>
          <target state="translated">若要执行或"调用"对象的方法，请键入句点 （.）、 方法名称和一组括号"（）"。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If the method has arguments, place the argument values inside the parentheses.</source>
          <target state="translated">如果该方法具有参数，将放在括号内的参数值。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The parentheses are required for every method call, even when there are no arguments.</source>
          <target state="translated">即使没有参数时，需要为每个方法调用，括号。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For example, the following command invokes the Kill method of processes to end the Notepad process on the computer.</source>
          <target state="translated">例如，下面的命令时，调用 Kill 方法要结束的计算机上 Notepad 进程的进程。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>As a result, the instance of Notepad closes.</source>
          <target state="translated">因此，关闭记事本的实例。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>(The Get-Process command is enclosed in parentheses to insure that it runs before the Kill method is invoked.</source>
          <target state="translated">（Get-process 命令括在圆括号中以确保其在 Kill 方法调用前运行。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Another very useful process is the Split method of strings.</source>
          <target state="translated">另一个非常有用的进程是字符串的拆分方法。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The split method takes a delimiter character argument that tells the method where to split the string.</source>
          <target state="translated">Split 方法采用分隔符字符参数指示该方法将字符串拆分的位置。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>As shown in the previous examples, you can invoke a method on an object that you get by using a command or an object in a variable.</source>
          <target state="translated">如前面的示例中所示，可以调用一个对象，您通过使用命令或变量中的某个对象上的方法。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Starting in  Windows PowerShell 4.0, method invocation by using dynamic method names is supported.</source>
          <target state="translated">从 Windows PowerShell 4.0 开始，支持通过使用动态方法名称的方法调用。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>LEARNING ABOUT METHODS</source>
          <target state="translated">学习使用方法</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>To find definitions of the methods of an object, go to help topic for the object type in MSDN and look for its methods page.</source>
          <target state="translated">若要查找的对象的方法定义，依次转到帮助主题的 MSDN 中的对象类型，然后查找其方法页。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, the following page describes the methods of process objects (System.Diagnostics.Process).</source>
          <target state="translated">例如，以下页面描述进程对象 (System.Diagnostics.Process) 的方法。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To determine the arguments of a method, review the method definition, which is like the syntax diagram of a  Windows PowerShell cmdlet.</source>
          <target state="translated">若要确定一种方法的参数，检查方法定义，这类似于 Windows PowerShell cmdlet 的语法关系图。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A method definition might have one or more method signatures, which are like the parameter sets of  Windows PowerShell cmdlets.</source>
          <target state="translated">方法定义可能会有一个或多个方法签名，类似于 Windows PowerShell cmdlet 的参数集。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The signatures show all of the valid formats of commands to invoke the method.</source>
          <target state="translated">签名显示所有命令来调用该方法的有效格式。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, the CopyTo method of the FileInfo class contains the following two method signatures:</source>
          <target state="translated">例如，FileInfo 类 CopyTo 方法包含下面的两个方法签名︰</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The first method signature takes the destination file name (and a path).</source>
          <target state="translated">第一个方法签名将目标文件名称 （和路径）。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following example use The first CopyTo method to copy the Final.txt file to the C:\Bin directory.</source>
          <target state="translated">下面的示例使用第一种 CopyTo 方法将 Final.txt 文件复制到 C:\Bin 目录。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The second method signature take a destination file name and a Boolean value that determines whether the destination file should be overwritten, if it already exists.</source>
          <target state="translated">第二个方法签名将目标文件名称和一个布尔值，确定是否应覆盖目标文件，如果已经存在。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following example use The second CopyTo method to copy the Final.txt file to the C:\Bin directory, and to overwrite existing files.</source>
          <target state="translated">若要将 Final.txt 文件复制到 C:\Bin 目录，并覆盖现有文件，下面的示例将使用第二种 CopyTo 方法。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>METHODS OF SCALAR OBJECTS AND COLLECTIONS</source>
          <target state="translated">标量对象和集合的方法</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The methods of one ("scalar") object of a particular type are often different from the methods of a collection of objects of the same type.</source>
          <target state="translated">特定类型的一个 （"标量"） 的方法通常是集合的对象的不同于相同类型的对象的方法。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, every process has a Kill method, but a collection of processes does not have a Kill method.</source>
          <target state="translated">例如，每个进程具有 Kill 方法，但进程的集合不具有 Kill 方法。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Beginning in  Windows PowerShell 3.0,  Windows PowerShell tries to prevent scripting errors that result from the differing methods of scalar objects and collections.</source>
          <target state="translated">从 Windows PowerShell 3.0 开始，Windows PowerShell 将尝试以防止脚本出现错误而导致的标量对象和集合的不同方法。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Beginning in  Windows PowerShell 4.0, collection filtering by using a method syntax is supported.</source>
          <target state="translated">从 Windows PowerShell 4.0 开始，支持使用方法语法筛选集合。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If you submit a collection, but request a method that exists only on single ("scalar") objects, Windows invokes the method on every object in the collection.</source>
          <target state="translated">如果您提交的集合，但请求仅存在于单个 （"标量"） 的对象的方法，Windows 将调用在集合中每个对象上的方法。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If the method exists on the individual objects and on the collection,  Windows PowerShell does not alter the result.</source>
          <target state="translated">如果该方法存在的各个对象和集合，则 Windows PowerShell 不会更改结果。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This feature also works on properties of scalar objects and collections.</source>
          <target state="translated">此功能还适用于标量对象和集合的属性。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>For more information, see about_Properties.</source>
          <target state="translated">有关详细信息，请参阅 about_Properties。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following example runs the Kill method of individual process objects on a collection of process objects.</source>
          <target state="translated">下面的示例进程对象的集合上运行单个进程对象的 Kill 的方法。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This example works only on  Windows PowerShell 3.0 and later versions of  Windows PowerShell.</source>
          <target state="translated">此示例仅适用于 Windows PowerShell 3.0 和更高版本的 Windows PowerShell。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The first command starts three instances of the Notepad process.</source>
          <target state="translated">第一个命令启动 Notepad 进程的三个实例。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The second command uses the Get-Process command to get all three instance of the Notepad process and save them in the $p variable.</source>
          <target state="translated">第二个命令使用 Get-process 命令获取 Notepad 进程的所有三个实例，并将其保存在 $p 变量中。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The third command uses the Count property of all collections to verify that there are three processes in the $p variable.</source>
          <target state="translated">第三个命令使用所有集合的 Count 的属性以验证 $p 变量中有三个进程。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The fourth command runs the Kill method on all three processes in the $p variable.</source>
          <target state="translated">第四个命令在 $p 变量中的所有三个进程上运行 Kill 方法。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This command works even though a collection of processes does not have a Kill method.</source>
          <target state="translated">该命令有效，即使进程的集合不具有 Kill 方法也是如此。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The fifth command uses the Get-Process command to confirm that the Kill command worked.</source>
          <target state="translated">第五个命令使用 Get-process 命令确认 Kill 命令起作用。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To perform the same task on  Windows PowerShell 2.0, use the Foreach-Object cmdlet to run the method on each object in the collection.</source>
          <target state="translated">若要在 Windows PowerShell 2.0 上执行相同的任务，使用 Foreach-object cmdlet 在集合中的每个对象上运行该方法。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>about_Objects</source>
          <target state="translated">about_Objects</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>about_Properties</source>
          <target state="translated">about_Properties</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Get-Member</source>
          <target state="translated">Get-Member</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>