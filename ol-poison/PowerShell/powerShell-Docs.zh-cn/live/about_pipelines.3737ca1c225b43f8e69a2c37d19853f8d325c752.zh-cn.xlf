<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">20e67e887ff53c88b589ae818c944386806d6d00</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_pipelines.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f1e01c64d2d409182826ef26a186d63b0bcc8ffb</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d8327ea469f7eb12fa1f0450258f6248348467a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Pipelines</source>
          <target state="translated">有关管道</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_pipelines</source>
          <target state="translated">about_pipelines</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Combining commands into pipelines in the Windows PowerShell</source>
          <target state="translated">为 Windows PowerShell 中管道的合并命令</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A pipeline is a series of commands connected by pipeline operators (|)(ASCII 124).</source>
          <target state="translated">管道是一系列命令通过管道运算符 (|) 连接(ASCII 124)。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Each pipeline operator sends the results of the preceding command to the next command.</source>
          <target state="translated">每个管道运算符将前一个命令的结果发送到下一个命令。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use pipelines to send the objects that are output by one command to be used as input to another command for processing.</source>
          <target state="translated">您可以使用管道发送由一个命令以用作处理对另一个命令的输入输出的对象。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>And you can send the output of that command to yet another command.</source>
          <target state="translated">并可以将该命令的输出发送到另一个命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The result is a very powerful command chain or "pipeline" that is comprised of a series of simple commands.</source>
          <target state="translated">结果是一个非常强大的命令链或"管道"组成的一系列简单的命令。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如，</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Command-1 | Command-2 | Command-3</source>
          <target state="translated">命令 1 |命令 2 |命令 3</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In this example, the objects that Command-1 emits are sent to Command-2.</source>
          <target state="translated">在此示例中，命令 1 发出的对象发送到命令-2。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Command-2 processes the objects and sends them to Command-3.</source>
          <target state="translated">命令 2 处理这些对象，并将其发送到命令 3。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Command-3 processes the objects and send them down the pipeline.</source>
          <target state="translated">命令 3 处理对象，并将其发送管道向下。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Because there are no more commands in the pipeline, the results are displayed at the console.</source>
          <target state="translated">由于管道中有没有更多命令，在控制台中显示结果。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In a pipeline, the commands are processed from left to right in the order that they appear.</source>
          <target state="translated">在管道中，这些命令从左到右处理它们出现的顺序。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The processing is handled as a single operation and output is displayed as it is generated.</source>
          <target state="translated">默认情况下，处理作为单个操作并生成，因此会显示输出。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Here is a simple example.</source>
          <target state="translated">下面是一个简单的示例。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following command gets the Notepad process and then stops it.</source>
          <target state="translated">以下命令获取 Notepad 进程，然后停止它。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>get-process notepad | stop-process</source>
          <target state="translated">获取进程记事本 |停止进程</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The first command uses the Get-Process cmdlet to get an object representing the Notepad process.</source>
          <target state="translated">第一个命令使用 Get-process cmdlet 获取表示记事本进程的对象。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator (|) to send the process object to the Stop-Process cmdlet, which stops the Notepad process.</source>
          <target state="translated">它使用管道运算符 (|) 将进程对象发送给 Stop-process cmdlet，后者停止 Notepad 进程。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Notice that the Stop-Process command does not have a Name or ID parameter to specify the process, because the specified process is submitted through the pipeline.</source>
          <target state="translated">请注意，停止处理命令不具有名称或 ID 参数来指定此过程中，因为指定的进程提交通过管道。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Here is a practical example.</source>
          <target state="translated">下面是一个实际示例。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command pipeline gets the text files in the current directory, selects only the files that are more than 10,000 bytes long, sorts them by length, and displays the name and length of each file in a table.</source>
          <target state="translated">此命令管道获取当前目录中的文本文件、 选择仅将超过 10000 个字节的文件、 按长度、 对其进行排序和表中显示的名称和每个文件的长度。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt | Where-Object {$_.length -gt 10000} | Sort-Object -property Length | Format-Table -property name, length</source>
          <target state="translated">Get-childitem-路径 *.txt |Where-object {$_.length-gt 10000} |排序对象的属性长度 |表格格式的属性名称、 长度</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This pipeline is comprised of four commands in the specified order.</source>
          <target state="translated">此管道由四个命令中指定的顺序。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The command is written horizontally, but we will show the process vertically in the following graphic.</source>
          <target state="translated">该命令会写入水平，但我们将在下图中垂直显示进程。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt</source>
          <target state="translated">Get-childitem-路径 *.txt</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         )</source>
          <target state="translated">|  （FileInfo 对象） |  (    .txt         )</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Where-Object {$_.length -gt 10000}</source>
          <target state="translated">Where-object {$_.length-gt 10000}</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         ) |   ( Length &gt; 10000  )</source>
          <target state="translated">|  （FileInfo 对象） |  (    .txt         ) |  (长度 &gt; 10000)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Sort-Object -property Length</source>
          <target state="translated">排序对象的属性长度</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects  ) |   (    .txt          ) |   ( Length &gt; 10000   ) |   ( Sorted by length )</source>
          <target state="translated">|  （FileInfo 对象） |  (    .txt          ) |  (长度 &gt; 10000) |  （按长度）</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Format-Table -property name, length</source>
          <target state="translated">表格格式的属性名称、 长度</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects     ) |   (    .txt             ) |   ( Length &gt; 10000      ) |   ( Sorted by length    ) |   (Formatted in a table )</source>
          <target state="translated">|  （FileInfo 对象） |  (    .txt             ) |  (长度 &gt; 10000) |  （按长度排序） |  （在表格格式）</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Name                       Length</source>
          <target state="translated">名称长度</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>tmp1.txt                    82920 tmp2.txt                   114000 tmp3.txt                   114000</source>
          <target state="translated">tmp1.txt 82920 tmp2.txt 114000 tmp3.txt 114000</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>USING PIPELINES</source>
          <target state="translated">使用管道</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell cmdlets were designed to be used in pipelines.</source>
          <target state="translated">Windows PowerShell cmdlet 旨在在管道中使用。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, you can usually pipe the results of a Get cmdlet to an action cmdlet (such as a Set, Start, Stop, or Rename cmdlet) for the same noun.</source>
          <target state="translated">例如，您可以通常通过管道传递到操作 cmdlet （如组、 开始、 停止，或重命名 cmdlet 中) 以供相同名词 Get cmdlet 的结果。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, you can pipe any service from the Get-Service cmdlet to the Start-Service or Stop-Service cmdlets (although disabled services cannot be restarted in this way).</source>
          <target state="translated">例如，您可以通过管道传递 Get-service cmdlet 启动服务或停止服务 cmdlet 的任何服务 （尽管被禁用的服务不能以这种方式重新启动）。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This command pipeline starts the WMI service on the computer:</source>
          <target state="translated">此命令管道在计算机上启动 WMI 服务︰</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>get-service wmi | start-service</source>
          <target state="translated">获取服务 wmi |启动服务</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The cmdlets that get and set objects of the Windows PowerShell providers, such as the Item and ItemProperty cmdlets, are also designed to be used in pipelines.</source>
          <target state="translated">获取和设置对象的 Windows PowerShell 提供程序，如项和 ItemProperty cmdlet 的 cmdlet 还用于在管道中使用。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the results of a Get-Item or Get-ChildItem command in the Windows PowerShell registry provider to the New-ItemProperty cmdlet.</source>
          <target state="translated">例如，您可以在 Windows PowerShell 注册表提供程序给 New-itemproperty cmdlet 通过管道 Get-item 或 Get-childitem 命令的结果。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This command adds a new registry entry, NoOfEmployees, with a value of 8124, to the MyCompany registry key.</source>
          <target state="translated">此命令将新注册表条目 NoOfEmployees 8124，值添加到 MyCompany 注册表项。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>get-item -path HKLM:\Software\MyCompany | new-Itemproperty -name NoOfEmployees -value 8124</source>
          <target state="translated">获取项的路径 HKLM:\Software\MyCompany |新 Itemproperty-命名 NoOfEmployees-值 8124</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Many of the utility cmdlets, such as Get-Member, Where-Object, Sort-Object, Group-Object, and Measure-Object are used almost exclusively in pipelines.</source>
          <target state="translated">许多实用程序 cmdlet，如 Get-member，Where-object，Sort-object 的组对象和度量值对象用几乎都是在管道中。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can pipe any objects to these cmdlets.</source>
          <target state="translated">您可以通过管道传递给这些 cmdlet 的任何对象。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, you can pipe all of the processes on the computer to the Sort-Object command and have them sorted by the number of handles in the process.</source>
          <target state="translated">例如，可以给 Sort 对象命令的计算机上通过管道传递的所有进程，而将这些项排序的进程中的句柄的数量。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>get-process | sort-object -property handles</source>
          <target state="translated">获取进程 |排序对象的属性句柄</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Also, you can pipe any objects to the formatting cmdlets, such as Format-List and Format-Table, the Export cmdlets, such as Export-Clixml and Export-CSV, and the Out cmdlets, such as Out-Printer.</source>
          <target state="translated">此外，可以通过管道传递给 Format-list 和 Format-table，导出 cmdlet 如 Export-clixml 和 EXPORT-CSV，等 Out cmdlet，如 Out-printer 的格式设置 cmdlet 的任何对象。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the Winlogon process to the Format-List cmdlet to display all of the properties of the process in a list.</source>
          <target state="translated">例如，您可以通过管道传递给 Format-list cmdlet，以显示所有进程的属性列表中的 Winlogon 进程。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>get-process winlogon | format-list -property *</source>
          <target state="translated">获取进程 winlogon |格式列表的属性 *</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>With a bit of practice, you'll find that combining simple commands into pipelines saves time and typing, and makes your scripting more efficient.</source>
          <target state="translated">使用稍加练习，您会发现，将简单的命令合并到管道可以节省时间和键入，并使脚本编写更高效。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>HOW PIPELINES WORK</source>
          <target state="translated">管道的工作方式</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When you "pipe" objects, that is send the objects in the output of one command to another command, Windows PowerShell tries to associate the piped objects with one of the parameters of the receiving cmdlet.</source>
          <target state="translated">当您""对象，它是发送管道将对象传递给另一个命令的一个命令的输出中时，Windows PowerShell 尝试将管道的对象与接收 cmdlet 的参数之一相关联。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To do so, the Windows PowerShell "parameter binding" component, which associates input objects with cmdlet parameters, tries to find a parameter that meets the following criteria:</source>
          <target state="translated">若要这样做，Windows PowerShell"参数绑定"组件，将输入的对象关联的 cmdlet 参数，尝试查找满足以下条件的参数︰</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>-- The parameter must accept input from a pipeline (not all do) -- The parameter must accept the type of object being sent or a type that the object can be converted to.</source>
          <target state="translated">--参数必须接受来自管道 （并非所有执行操作） 的输入--正在发送的对象类型或该对象可以转换为类型，必须接受参数。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>-- The parameter must not already be used in the command.</source>
          <target state="translated">不必须在命令中已使用--参数。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, the Start-Service cmdlet has many parameters, but only two of them, Name and InputObject accept pipeline input.</source>
          <target state="translated">例如，Start-service cmdlet 都有许多参数，但只有两个，名称和 InputObject 接受管道输入。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Name parameter takes strings and the InputObject parameter takes service objects.</source>
          <target state="translated">Name 参数采用字符串并 InputObject 参数将服务对象。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Therefore, you can pipe strings and service objects (and objects with properties that can be converted to string and service objects) to Start-Service.</source>
          <target state="translated">因此，您可以通过管道传递字符串和服务对象 （和具有可以转换为字符串和服务对象的属性的对象） 到启动服务。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If the parameter binding component of Windows PowerShell cannot associate the piped objects with a parameter of the receiving cmdlet, the command fails and Windows PowerShell prompts you for the missing parameter values.</source>
          <target state="translated">如果 Windows PowerShell 的参数绑定组件不能将接收 cmdlet 的参数与关联的管道的对象，该命令将失败，并且 Windows PowerShell 会提示您输入缺少的参数值。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You cannot force the parameter binding component to associate the piped objects with a particular parameter -- you cannot even suggest a parameter.</source>
          <target state="translated">不能强制与某个特定参数相关联的管道的对象参数绑定组件 — 您甚至无法建议参数。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Instead, the logic of the component manages the piping as efficiently as possible.</source>
          <target state="translated">相反，该组件的逻辑管理管道尽可能高效。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>ONE-AT-A-TIME PROCESSING</source>
          <target state="translated">一个 AT A 时处理</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Piping objects to a command is much like using a parameter of the command to submit the objects.</source>
          <target state="translated">管道对象传递给命令非常类似于使用该命令的参数来提交这些对象。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, piping objects representing the services on the computer to a Format-Table command, such as:</source>
          <target state="translated">例如，管道如到 Format-table 命令，表示在计算机上的服务对象︰</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>get-service | format-table -property name, dependentservices</source>
          <target state="translated">获取服务 |表格格式的属性名称、 dependentservices</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>is much like saving the service objects in a variable and using the InputObject parameter of Format-Table to submit the service object.</source>
          <target state="translated">非常类似的变量中保存的服务对象，并使用表格格式的 InputObject 参数提交服务对象。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>$services = get-service format-table -inputobject $services -property name, dependentservices</source>
          <target state="translated">$services = get 服务表格格式-inputobject $services-属性 name，dependentservices</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>or imbedding the command in the parameter value</source>
          <target state="translated">或嵌入在参数值中的命令</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>format-table -inputobject (get-service wmi) -property name, dependentservices</source>
          <target state="translated">表格格式-inputobject (get 服务 wmi) 的属性名称、 dependentservices</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>However, there is an important difference.</source>
          <target state="translated">但是，是一项重大差异。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When you pipe multiple objects to a command, Windows PowerShell sends the objects to the command one at a time.</source>
          <target state="translated">当你通过管道传递给命令的多个对象时，Windows PowerShell 将一次将对象发送到其中一个命令上。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use a command parameter, the objects are sent as a single array object.</source>
          <target state="translated">当您使用命令参数时，这些对象的单个数组对象作为发送。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This seemingly technical difference can have interesting, and sometimes useful, consequences.</source>
          <target state="translated">这种看似技术差异可能会造成有趣，而且有时很有用，后果。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For example, if you pipe multiple process objects from the Get-Process cmdlet to the Get-Member cmdlet, Windows PowerShell sends each process object, one at a time, to Get-Member.</source>
          <target state="translated">例如，如果你通过管道传递给 Get-member cmdlet 多个进程对象中 Get-process cmdlet，Windows PowerShell 会将每个进程对象，一次一个地发送到 Get-member。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Get-Member displays the .NET class (type) of the process objects, and their properties and methods.</source>
          <target state="translated">获取成员显示进程对象及其属性和方法的.NET 的类 （类型）。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>(Get-Member eliminates duplicates, so if the objects are all of the same type, it displays only one object type.)</source>
          <target state="translated">(Get-member 消除重复项，因此如果对象是所有相同的类型，它将显示只有一种对象类型。)</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In this case, Get-Member displays the properties and methods of each process object, that is, a System.Diagnostics.Process object.</source>
          <target state="translated">在这种情况下，获取成员显示的属性和方法的每个进程对象，即 System.Diagnostics.Process 对象。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>get-process | get-member</source>
          <target state="translated">获取进程 |获取成员</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>TypeName: System.Diagnostics.Process</source>
          <target state="translated">类型名称︰ System.Diagnostics.Process</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name                           MemberType     Definition</source>
          <target state="translated">名称 MemberType 定义</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Handles                        AliasProperty  Handles = Handlecount Name                           AliasProperty  Name = ProcessName NPM                            AliasProperty  NPM = NonpagedSystemMemorySize</source>
          <target state="translated">处理 AliasProperty 句柄 = Handlecount 名称 AliasProperty 名称 = ProcessName NPM AliasProperty NPM = NonpagedSystemMemorySize</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>However, if you use the InputObject parameter of Get-Member, then Get-Member receives an array of System.Diagnostics.Process objects as a single unit, and it displays the properties of an array of objects.</source>
          <target state="translated">但是，如果使用 Get-member 的 InputObject 参数，然后获取成员中接收的 System.Diagnostics.Process 对象数组作为单个单元，并显示一个对象数组的属性。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(Note the array symbol ([]) after the System.Object type name.)</source>
          <target state="translated">（请注意数组符号 ([]) 的 System.Object 类型名称之后。）</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>get-member -inputobject (get-process)</source>
          <target state="translated">获取成员-inputobject （get 进程）</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>TypeName: System.Object[]</source>
          <target state="translated">类型名称︰ System.Object]</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Name               MemberType    Definition</source>
          <target state="translated">名称 MemberType 定义</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Count              AliasProperty Count = Length Address            Method        System.Object&amp; Address(Int32 ) Clone              Method        System.Object Clone()</source>
          <target state="translated">计数 AliasProperty 计数 = 长度地址方法 System.Object &amp; 地址 (Int32) 克隆方法 System.Object clone （）</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This result might not be what you intended, but after you understand it, you can use it.</source>
          <target state="translated">此结果可能不是您的预期，但了解它之后，您可以使用它。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example, an array of process objects has a Count property that you can use to count the number of processes on the computer.</source>
          <target state="translated">例如，进程对象的数组具有 Count 属性，它可用于计算机上的进程数目进行计数。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>(get-process).count</source>
          <target state="translated">（get 进程）.count</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This distinction can be important, so remember that when you pipe objects to a cmdlet, they are delivered one at a time.</source>
          <target state="translated">这一区别很重要，因此请务必确保当通过管道传递给 cmdlet 的对象，它们都已传递一次一个地。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>ACCEPTS PIPELINE INPUT</source>
          <target state="translated">接受管道输入</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In order to receive objects in a pipeline, the receiving cmdlet must have a parameter that accepts pipeline input.</source>
          <target state="translated">为了接收管道中的对象，该接收 cmdlet 必须接受管道输入参数。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can use a Get-Help command with the Full or Parameter parameters to determine which, if any, of a cmdlet's parameters accepts pipeline input.</source>
          <target state="translated">可以使用完全或参数的参数使用 Get-help 命令来确定，如果有的话的 cmdlet 的参数接受管道输入。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the Get-Help default display, the "Accepts pipeline input" item appears in a table of parameter attributes.</source>
          <target state="translated">在 Get-help 默认显示中，"接受管道输入"项目参数特性的表中显示。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This table is displayed only when you use the Full or Parameter parameters of the Get-Help cmdlet.</source>
          <target state="translated">仅当使用 Get-help cmdlet 的完全或参数参数时，将显示此表。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, to determine which of the parameters of the Start-Service cmdlet accepts pipeline input, type:</source>
          <target state="translated">例如，若要确定哪些 Start-service cmdlet 的参数接受管道输入，类型︰</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>get-help start-service -full</source>
          <target state="translated">获取帮助启动服务-完整</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>get-help start-service -parameter *</source>
          <target state="translated">获取帮助启动服务的参数 *</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, the help for the Start-Service cmdlet shows that the Name and InputObject parameters accept pipeline input ("true").</source>
          <target state="translated">例如，Start-service cmdlet 的帮助显示 Name 和 InputObject 参数接受管道输入 ("true")。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>All other parameters have a value of "false" in the "Accept pipeline input?"</source>
          <target state="translated">所有其他参数都具有值为"false"中的"接受管道输入？"</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>row.</source>
          <target state="translated">行。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>-name &lt;string[]&gt; Specifies the service names for the service to be started.</source>
          <target state="translated">-name &lt; string [] &gt; 指定要启动该服务的服务名称。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parameter name is optional.</source>
          <target state="translated">参数名为可选项。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You can use "-Name" or its alias, "-ServiceName", or you can omit the parameter name.</source>
          <target state="translated">可以使用“-Name”或其别名“-ServiceName”，也可以忽略该参数名。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">是否必需？</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">true 位置？</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>1 Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">默认值 1--&gt; 接受管道输入？</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>true (ByValue, ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">true （ByValue、 ByPropertyName） 是否接受通配符？</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-inputObject &lt;ServiceController[]&gt; Specifies ServiceController objects representing the services to be started.</source>
          <target state="translated">-inputObject &lt; ServiceController [] &gt; 指定 ServiceController 对象来表示要启动服务。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects or type a command or expression that gets the objects.</source>
          <target state="translated">输入一个包含对象的变量，或键入可获取对象的命令或表达式。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">是否必需？</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>false Position?</source>
          <target state="translated">false 位置？</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>named Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">已命名的默认值--&gt; 接受管道输入？</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>true (ByValue) Accept wildcard characters?</source>
          <target state="translated">true (ByValue) 接受通配符？</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This means that you can send objects (PsObjects) through the pipeline to the Where-Object cmdlet and Windows PowerShell will associate the object with the InputObject parameter.</source>
          <target state="translated">通过给 Where-object cmdlet 管道这意味着您可以发送对象 (Psobject) 和 Windows PowerShell 将该对象将与相关联的 InputObject 参数。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>METHODS OF ACCEPTING PIPELINE INPUT</source>
          <target state="translated">接受管道输入方法</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Cmdlets parameters can accept pipeline input in one of two different ways:</source>
          <target state="translated">Cmdlet 参数可接受管道输入两种不同方法之一︰</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>-- ByValue: Parameters that accept input "by value" can accept piped objects that have the same .NET type as their parameter value or objects that can be converted to that type.</source>
          <target state="translated">-ByValue︰ 具有相同的.NET 类型作为其参数值的对象或可以转换为该类型的对象，通过管道传递接受输入"value"可接受的参数。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service accepts pipeline input by value.</source>
          <target state="translated">例如，启动服务的 Name 参数接受管道输入的值。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>It can accept string objects or objects that can be converted to strings.</source>
          <target state="translated">它可以接受字符串对象或可以转换为字符串的对象。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>-- ByPropertyName: Parameters that accept input "by property name" can accept piped objects only when a property of the object has the same name as the parameter.</source>
          <target state="translated">-ByPropertyName︰ 仅当对象的属性具有相同的名称作为参数时，接受"按属性名称"输入可以接受的参数传送对象。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service can accept objects that have a Name property.</source>
          <target state="translated">例如，启动服务的 Name 参数可以接受具有 Name 属性的对象。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>(To list the properties of an object, pipe it to Get-Member.)</source>
          <target state="translated">（若要列出的对象的属性，管道将它传递到 Get-member。）</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Some parameters can accept objects by value or by property name.</source>
          <target state="translated">某些参数可以接受对象按值或按属性名称。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>These parameters are designed to take input from the pipeline easily.</source>
          <target state="translated">这些参数用于轻松地接受输入管道中。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>INVESTIGATING PIPELINE ERRORS</source>
          <target state="translated">调查管道错误</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If a command fails because of a pipeline error, you can investigate the failure and rewrite the command.</source>
          <target state="translated">如果命令失败由于管道错误，可以调查失败和重写该命令。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example, the following command tries to move a registry entry from one registry key to another by using the Get-Item cmdlet to get the destination path and then piping the path to the Move-ItemProperty cmdlet.</source>
          <target state="translated">例如，以下命令将尝试将注册表条目从一个注册表项移动到另一个，︰ 使用 Get-item cmdlet 获取的目标路径，然后管道传递给 Move-itemproperty cmdlet 的路径。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Specifically, the command uses the Get-Item cmdlet to get the destination path.</source>
          <target state="translated">具体而言，该命令使用 Get-item cmdlet 获取的目标路径。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator to send the result to the Move-ItemProperty cmdlet.</source>
          <target state="translated">它使用管道运算符将结果发送给 Move-itemproperty cmdlet。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The Move-ItemProperty command specifies the current path and name of the registry entry to be moved.</source>
          <target state="translated">Move-itemproperty 命令指定的当前路径和要移动的注册表项的名称。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">获取项的路径 hklm:\software\mycompany\sales |移动 itemproperty-路径 hklm:\software\mycompany\design-名称产品</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The command fails and Windows PowerShell displays the following error message:</source>
          <target state="translated">该命令将失败，Windows PowerShell 显示以下错误消息︰</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Move-ItemProperty : The input object cannot be bound to any parameters for the command either because the command does not take pipeline input or the input and its properties do not match any of the parameters that take pipeline input.</source>
          <target state="translated">Move-itemproperty︰ 输入的对象不能绑定到命令的任何参数或者因为该命令不起管道输入，或者输入并将其属性不匹配任何接受管道输入的参数。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>At line:1 char:23</source>
          <target state="translated">在行︰ 1 char: 23</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>$a | move-itemproperty &lt;&lt;&lt;&lt;  -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">$ |移动 itemproperty &lt;&lt;&lt;&lt;-路径 hklm:\software\mycompany\design-名称产品</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>To investigate, use the Trace-Command cmdlet to trace the Parameter Binding component of Windows PowerShell.</source>
          <target state="translated">若要调查，请使用 Trace-command cmdlet 跟踪参数绑定的 Windows PowerShell 组件。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following command traces the Parameter Binding component while the command is processing.</source>
          <target state="translated">处理命令时，以下命令将跟踪参数绑定的组件。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It uses the -pshost parameter to display the results at the console and the -filepath command to send them to the debug.txt file for later reference.</source>
          <target state="translated">它使用-pshost 参数来将结果显示在控制台和-filepath 命令以将其发送给 debug.txt 文件以供将来参考。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>trace-command -name parameterbinding -expression {get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product} -pshost -filepath debug.txt</source>
          <target state="translated">trace 命令的名称 parameterbinding-表达式 {get 项的路径 hklm:\software\mycompany\sales | 移动 itemproperty-路径 hklm:\software\mycompany\design-名称产品}-pshost-filepath debug.txt</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The results of the trace are lengthy, but they show the values being bound to the Get-Item cmdlet and then the named values being bound to the Move-ItemProperty cmdlet.</source>
          <target state="translated">跟踪的结果较长，但它们会显示绑定到 Get-item cmdlet 的值，然后绑定到 Move-itemproperty cmdlet 的已命名的值。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>BIND NAMED cmd line args [Move-ItemProperty] BIND arg [hklm:\software\mycompany\design] to parameter [Path]</source>
          <target state="translated">将绑定命名 cmd 行 args [Move-itemproperty] 绑定 arg [hklm:\software\mycompany\design] 到 [Path] 参数</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>BIND arg [product] to parameter [Name]</source>
          <target state="translated">将 arg [product] 绑定到参数 [Name]</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>....</source>
          <target state="translated">....</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>BIND POSITIONAL cmd line args [Move-ItemProperty]</source>
          <target state="translated">将绑定位置的命令行参数 [Move-itemproperty]</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Finally, it shows that the attempt to bind the path to the Destination parameter of Move-ItemProperty failed.</source>
          <target state="translated">最后，它表明尝试绑定到 Move-itemproperty 失败的目标参数的路径。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>BIND PIPELINE object to parameters: [Move-ItemProperty] PIPELINE object TYPE = [Microsoft.Win32.RegistryKey] RESTORING pipeline parameter's original values Parameter [Destination] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION Parameter [Credential] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION</source>
          <target state="translated">将绑定管道对象传递给参数: [Move-itemproperty] 管道对象的类型 = [Microsoft.Win32.RegistryKey] RESTORING 管道参数原始值参数 [Destination] 管道输入 ValueFromPipelineByPropertyName NO 强制参数 [凭据] 管道输入 ValueFromPipelineByPropertyName 否强制</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>To investigate the failure, use the Get-Help cmdlet to view the attributes of the Destination parameter.</source>
          <target state="translated">若要调查失败，请使用 Get-help cmdlet 以查看在 Destination 参数的属性。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The following command gets detailed information about the Destination parameter.</source>
          <target state="translated">以下命令将获取在 Destination 参数的详细的信息。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>get-help move-itemproperty -parameter destination</source>
          <target state="translated">获取帮助移动 itemproperty-参数目标</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The results show that Destination takes pipeline input only "by property name".</source>
          <target state="translated">结果显示目标仅"按属性名称"接受管道输入。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>That is, the piped object must have a property named Destination.</source>
          <target state="translated">也就是说，管道的对象必须具有名为目标的属性。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>-destination <ph id="ph1">&lt;string&gt;</ph> Specifies the path to the destination location.</source>
          <target state="translated">-目标 <ph id="ph1">&lt;string&gt;</ph> 指定目标位置的路径。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">是否必需？</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">true 位置？</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>2 Default value Accept pipeline input?</source>
          <target state="translated">2 个默认值接受管道输入？</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>true (ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">true (ByPropertyName) 接受通配符？</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>To see the properties of the object being piped to the Move-ItemProperty cmdlet, pipe it to the Get-Member cmdlet.</source>
          <target state="translated">若要查看的属性传递给 Move-itemproperty cmdlet 的对象，管道它传递给 Get-member cmdlet。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following command pipes the results of the first part of the command to the Get-Member cmdlet.</source>
          <target state="translated">以下命令通过管道传递给 Get-member cmdlet 的命令的第一部分的结果。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | get-member</source>
          <target state="translated">获取项的路径 hklm:\software\mycompany\sales |获取成员</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The output shows that the item is a Microsoft.Win32.RegistryKey that does not have a Destination property.</source>
          <target state="translated">该输出显示该项目是不具有目标属性 Microsoft.Win32.RegistryKey。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>That explains why the command failed.</source>
          <target state="translated">说明该命令失败的原因。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>To fix the command, we must specify the destination in the Move-ItemProperty cmdlet.</source>
          <target state="translated">若要解决该命令，我们必须 Move-itemproperty cmdlet 中指定的目标。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>We can use a Get-ItemProperty command to get the path, but the name and destination must be specified in the Move-ItemProperty part of the command.</source>
          <target state="translated">我们可以使用 Get-itemproperty 命令可获取的路径，但必须在该命令的 Move-itemproperty 部分指定的名称和目标。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\design | move-itemproperty -dest hklm:\software\mycompany\design -name product</source>
          <target state="translated">获取项的路径 hklm:\software\mycompany\design |移动 itemproperty-dest hklm:\software\mycompany\design-名称产品</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>To verify that the command worked, use a Get-ItemProperty command:</source>
          <target state="translated">若要验证该命令正常运行，请使用 Get-itemproperty 命令︰</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>get-itemproperty hklm:\software\mycompany\sales</source>
          <target state="translated">get-itemproperty hklm:\software\mycompany\sales</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The results show that the Product registry entry was moved to the Sales key.</source>
          <target state="translated">结果显示产品注册表项被移动到销售参数。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName  : sales PSDrive      : HKLM PSProvider   : Microsoft.PowerShell.Core\Registry Product      : 18</source>
          <target state="translated">PSPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName︰ 销售 PSDrive: HKLM PSProvider: Microsoft.PowerShell.Core\Registry 产品︰ 18</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>about_objects about_parameters about_command_syntax about_foreach</source>
          <target state="translated">about_objects about_parameters about_command_syntax about_foreach</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>